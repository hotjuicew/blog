---
title: "弘源旅途项目开发记录"
date: 2022-08-04T23:32:01+08:00
categories: ["项目"]
tags: []
draft: true
---

## 创建Vue项目之后首先要做的事情

1.项目配置:
- 在`public-favicon.ico`配置项目的icon
- 在`index.html`中配置项目的标题

2.项目目录结构划分
─src
    ├─assets
    │  ├─css
    │  ├─font
    │  └─img
    ├─components  公共组件
    ├─hooks   组件里抽取出来的公共逻辑
    ├─mock  模拟的数据
    ├─router  路由
    ├─services  网络请求相关
    ├─stores  状态管理
    ├─utils  工具
    └─views  大的视图

3.CSS样式的重置
- normalize.css
 ```shell
 npm install normalize.css
 ```
- reset.css
 `assets-css-reset.css`
 ```css
body, h1, h2, h3, h4, ul, li {
  padding: 0;
  margin: 0;
}

ul, li {
  list-style: none;
}

a {
  text-decoration: none;
  color: #333;
}

img {
  vertical-align: top;
}
 ```
- common.css
```css
:root {
--primary-color: #ff9854;
}

body {
  font-size: 14px;
}
```
- index.css
```css
@import "./reset.css";
@import "./common.css";
```
4.路由配置
在view下为每个页面创建文件夹，每个文件夹创建vue文件
然后就可以在`router-index.js`配置路由映射

> 遇到问题：Git忽略规则.gitignore不生效
> 在项目开发过程中个，一般都会添加 .gitignore 文件，规则很简单，但有时会发现，规则不生效。
> 原因是 .gitignore 只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。
> 那么解决方法就是先把本地缓存删除（改变成未track状态），然后再提交。
> git rm -r --cached .
> git add .
> git commit -m 'update .gitignore'

5.配置pinia

## 遇到的问题

#### 1.动态引入图片路径

使用:src调用了v-bind指令处理其内容，相对路径不会被webpack的file-loader处理。编译后，资源目录assets结构已变，而代码的目录没变，所以相对路径这种方式不行，而绝对路径没有问题。需要把路径用require()包裹，比如require('@/assets/img/a.jpg')。这样才能正确引用到资源。

但是此次项目使用的是vite环境，没有require，怎么解决呢？
自己封装一个函数

```js
export const getAssetURL = (image) => {
  return new URL(`../assets/img/${image}`, import.meta.url).href
}
```

> - new URL(url, [base]) 生成一个url
>
> - import. meta提供上下文的元数据，包含有关当前模块的信息
>
> - ${} 这是模板字符串的知识，代表字符串插值
>
>   ```js
>   var foo = 'bar';
>   console.log(`Let's meet at the ${foo}`);
>   // Let's meet at the bar
>   ```

### 2.重写UI库某个类的样式

```css
  // :deep(.class)找到子组件的类, 让子组件的类也可以生效
  :deep(.van-tabbar-item__icon) {
    font-size: 50px;
  }
```

> 修改第三方U1组件库的样式
>
> 1.用插槽，插入自己的元素
> 那么在自己的作用域中直接修改这个元素
>
> 2.全局定义一个变量覆盖它默认变量的值
> 缺点:全局修改
>
> 3.布局定义一个变量覆盖它默认变量的值
> 优点:布局修改
>
> 4.直接查找对应的子组件选择器，进行修改
> :deep(子组件中元素的选择器)进行修改
> 直接修改CSS

### 3.flex:1 代表什么

[MDN](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FCSS%2Fflex)给了定义一个值的时候的解释，如果flex只定义了一个数字值，则 flex-basis 的值为 0；
所以：`flex:1` 为：`flex: 1 1 0`;

```none
flex-grow : 1;    ➜ The div will grow in same proportion as the window-size       
flex-shrink : 1;  ➜ The div will shrink in same proportion as the window-size 
flex-basis : 0;   ➜ The div does not have a starting value as such and will 
                     take up screen as per the screen size available for
                     e.g:- if 3 divs are in the wrapper then each div will take 33%.
```

- 起关键作用的是flex-grow：它指定了flex容器中剩余空间的多少应该分配给项目（flex增长系数），而这个系数如果不设置时默认是0，代表的意义就是即使flex容器有剩余空间，那么项目（flex-item）也不会使用那些剩余空间。所以如果一个flex-item的flex-grow为1而其他的flex-item没有设置，则设置了的就使用剩余空间的1/1*100%=100%的空间。

### 4.App.vue中的tabbar在有些页面需要隐藏

4.1`router-index.js`
在需要隐藏的页面的路由中加入信息` hideTabBar: true`

```js
{
            path: '/city',
            component: () => import("@/views/city/city.vue"),
            meta:{
                hideTabBar: true
            }
        },
```

4.2 `App.vue`
通过`useRoute()`拿到当前活跃路由，

```js
const route=useRoute()
```

```vue
<tab-bar v-if="!route.meta.hideTabBar"></tab-bar>
```

### 5.将顶部固定

要将某一部分固定住，使他不跟着一起滚动

- 方法一：`position: fixed;`,再让另外元素加上margin
  缺点：滚动条依然包含这个固定元素，很不好看

    ```css
    .top {
         position: fixed;
         top: 0;
         left: 0;
         right: 0;
       }
  
     .content {
         margin-top: 98px;
       }
    ```

- 方法二：设置局部滚动

  ```css
    .content {
      height: calc(100vh - 98px);
      overflow-y: auto;
    }
  ```

  

### 6.在同一的地方发送网络请求

可以在store的action中封装好请求，（用service中封装好的函数），再在大组件中发送请求。小组件去请求store里的数据

不要在小组件里发生网络请求，很难管理

### 7.监听元素的滚动

如何监听页面的滚动？上拉加载更多、显示搜索框

* 上拉加载更多很可能多个组件都需要用到  所以对其进行`hooks`的`useScroll`封装  用于方便使用
  * 获取客户端  `scrollTop`  `scrollHeight`的高度  定义`isReachBottom`控制网络请求的再次的触发
  * 当客户端的高度  `+`  上滑的高度  `>=`  内容滑块总高度时  就说明已经滚动到底部了  就可再次请求数据
  * 当然这里为了提升性能   可用节流函数
  * 事件需要在声明周期`onMounted`中进行(因为`setup`内部东西加载是处于(`beforeCreate和create声明周期之间`)  进行完成之后记得取消事件
  
  ```js
  import { onMounted, onUnmounted, ref } from "vue";
  import { throttle } from "lodash";
  
  export default function useScroll() {
    const isReachBottom = ref(false)
  
    const clientHeight = ref(0)
    const scrollTop = ref(0)
    const scrollHeight = ref(0)
   // 获取各种高度(客户端  上滑高度   滑块内容总高度)
    const scrollListenerHandler = throttle(() => {
      clientHeight.value = document.documentElement.clientHeight
      scrollTop.value = document.documentElement.scrollTop
      scrollHeight.value = document.documentElement.scrollHeight
  
      if (clientHeight.value + scrollTop.value >= scrollHeight.value) {
        // 滚动到底部触发
        // console.log('gundao dibu l')
        isReachBottom.value = true
      }
    }, 150)
    // 监听事件
    onMounted(() => {
      window.addEventListener('scroll', scrollListenerHandler)
    })
    //移除事件
    onUnmounted(() => {
      window.removeEventListener('scroll', scrollListenerHandler)
    })
  
    return { isReachBottom, clientHeight, scrollTop, scrollHeight }
  }
  ```