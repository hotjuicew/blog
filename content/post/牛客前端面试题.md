---
title: "牛客前端面试题"
date: 2022-11-17T21:27:14+08:00
categories: ["面试"]
tags: ["面试"]
---



### 1.说一说html语义化

1.提高了代码的可读性 有利于阅读和团队代码管理

2.有利于SEO（搜索引擎优化）：爬虫是依赖标签来确定关键字权重的，可帮助爬虫抓去更多有效信息

3.优化代码结构：使页面在没有css的情况下也能呈现很好的内容结构

### 2.说一说盒模型

css盒模型本质是一个盒子，盒子包裹着html内容，包含content padding border margin。

有两种盒模型：W3C标准盒模型和IE怪异盒模型。标准盒模型的width/height不包含padding和border。怪异盒模型的width/height包含padding和border。

默认使用标准盒模型，也可以通过控制box-sizing属性决定盒模型：border-box代表怪异盒模型、content-box代表标准盒模型

### 3.说一说浮动

浮动的定义：
使元素脱离文档流，按照指定的方向（左或右发生移动），直到它的外边缘碰到包含框或另一个浮动框的边框为止。
浮动的效果：
\* 文本环绕
\* 块级元素横排显示
\* 内联元素设置宽
浮动元素脱离文档流，可能造成父元素高度塌陷的问题，如何解决？
1.给父级添加高度 
2.给父级添加overflow：hidden （开启bfc）
3.在父元素的最后创建一个空白div,添加clear：both 属性（对其进行清除浮动，这样可以通过这个空白的div来撑开父元素的高度）
4.添加一个after伪类 

```css
.clearfix:after{
/*添加一个内容*/
content: "";
/*转换为一个块元素*/
display: block;
/*清除两侧的浮动*/
clear: both;
}
```



```
什么是高度塌陷？什么是高度塌陷？什么是高度塌陷？
* 在文档流中，父元素的高度默认是被子元素撑开的，
* 也就是子元素多高，父元素就多高。
* 但是当为子元素设置浮动以后，子元素会完全脱离文档流，
* 此时将会导致子元素无法撑起父元素的高度，导致父元素的高度塌陷。
* 由于父元素的高度塌陷了，则父元素下的所有元素都会向上移动，这样将会导致页面布局混乱。
* 所以在开发中一定要避免出现高度塌陷的问题,
* 我们可以将父元素的高度写死，以避免塌陷的问题出现，
* 但是一旦高度写死，父元素的高度将不能自动适应子元素的高度，所以这种方案是不推荐使用的。
```



### 4.说一说JS数据类型有哪些,区别是什么？

JS数据类型一共有8种
分为两类：
一类是基本数据类型，包含7种，分别是Number 、String、Boolean、BigInt、Symbol、Null、Undefined。
另一类是引用数据类型Object，普通对象，数组，正则，日期，Math数学函数都属于Object。

数据分成两大类的本质区别：在内存中的存储方式不同。 基本数据类型是直接存储在栈中的简单数据段，占据空间小，属于被频繁使用的数据。 引用数据类型是存储在堆内存中，占据空间大。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址，当解释器寻找引用值时，会检索其在栈中的地址，取得地址后从堆中获得实体。

Symbol是ES6新出的一种数据类型，这种数据类型的特点就是没有重复的数据，由于Symbol()创建数据具有唯一性，需要使用Object.getOwnPropertySymbols(obj)获得这个obj对象中key类型是Symbol的key值。 
BigInt也是ES6新出的一种数据类型，这种数据类型的特点就是数据涵盖的范围大，能够解决超出普通数据类型范围报错的问题。

### 5.说一说你对闭包的理解？

闭包是指有权访问另一个函数作用域中的变量的函数。

闭包形成的原理：作用域链，当前作用域可以访问上级作用域中的变量
闭包中变量存储的位置：闭包中的变量存储的位置是堆内存。假如闭包中的变量存储在栈内存中，那么栈的回收 会把处于栈顶的变量自动回收。所以闭包中的变量如果处于栈中那么变量被销毁后，闭包中的变量就没有了。所以闭包引用的变量是出于堆内存中的。
闭包解决的问题：能够让函数作用域中的变量在函数执行结束之后不被销毁，同时也能在函数外部可以访问函数内部的局部变量。 
闭包带来的问题：由于垃圾回收器不会将闭包中变量销毁，于是就造成了内存泄露 
闭包的应用，能够模仿块级作用域，能够实现柯里化，在构造函数中定义特权方法、Vue中数据响应式Observer中使用闭包等。

>柯里化：把 接受多个参数 的函数变换成 接受单一参数 的函数
>
>function unCurried(x, y) {
>  return x + y;
>}
>
>function curried(x) {
>  return function(y) {
>    return x + y;
>  }
>}
>
>curried(1)(2)

### 6.说一说promise是什么与使用方法？

1.promise是异步编程的一种解决方案，解决了回调地狱的问题，让代码看起来更加优雅。就像一个容器，保存着某个未来才会结束的事件的结果。

2.promise存在三种状态pending，fulfilled，rejected。 Promise通过new Promise()将构造函数实例化，使用new构建一个Promise，Promise的构造函数接收一个函数作为参数，并且传入两个参数，resolve 和 reject，分别表示异步操作执行成功和失败后的回调函数。promise的实例对象可以通过.then()查看成功消息，.catch()查看失败消息。then和catch最后也是返回promise对象，所以可以链式调用。

3.Promise.all()：返回一个新的promise对象，该promise对象在参数对象里所有的promise对象都成功的时候才会触发成功， Promise.any()：接收一个Promise对象的集合，当其中的一个 promise 成功，就返回那个成功的promise的值。
Promise.race()：当参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象。

### 7.说一说跨域是什么？如何解决跨域问题？

跨域就是违反了浏览器的同源策略造成的，当前页面中的某个接口请求的地址和当前页面的地址如果协议、域名、端口其中有一项不同，就说该接口跨域了。比如web 端地址为 localhost:8000 服务端地址为 localhost:8080,就跨域了

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/1717441c9498fb98~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)

> 同源策略（同域名、同端口、同协议）
>
> 补充：在默认情况下 http 可以省略端口 80， https 省略 443。

跨域的解决方案：https://juejin.cn/post/7075261878997352462

**1.JSONP （全称 JSON with Padding）**

由于同源策略的限制，浏览器只允许请求当前源（域名、协议、端口）的资源，而 HTML 的 script 元素是一个例外。利用script 的 src属性加载资源时不受同源策略的影响的这一特性，并且script会将引用的外部文件的文本内容当做js代码来进行解析

**2.后端可以设置CORS允许跨域实现；**

虽然浏览器出于安全考虑做了“跨域”访问的限制，但开发时不可避免会有这样不同源资源访问的需求，因此 W3C 就制定了 CORS( 跨域资源共享) 的机制。`CORS`需要浏览器和服务器同时支持，整个 `CORS`通信过程，都是浏览器自动完成不需要用户参与，对于开发者来说，`CORS`的代码和正常的 `ajax` 没有什么差别，浏览器一旦发现跨域请求，就会添加一些附加的头信息，

服务器需要在 Response Header 上添加 Access-Control-xxx-yyy 的字段，浏览器识别到了，才能放行该请求。比如，最常见的就是加 Access-Control-Allow-Origin 这个返回头，值设置为需要放行的域名。

在 CORS 中会有 `简单请求` 和 `复杂请求`的概念。

> 凡是同时满足以下两种情况的就是简单请求，反之则非简单请求，浏览器对这两种请求的处理不一样
>
> - 请求方法是以下方三种方法之一
>   - HEAD
>   - GET
>   - POST
> - HTTP的头信息不超出以下几种字段
>   - Accept
>   - Accept-Language
>   - Content-Language
>   - Last-Event-ID
>   - Content-Type：只限于三个值 `application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`

对于简单请求来说，浏览器之间发送`CORS`请求，具体来说就是在头信息中，增加一个`origin`字段，来看一下例子

```http
GET /cors? HTTP/1.1
Host: localhost:2333
Connection: keep-alive
Origin: http://localhost:2332
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36
```

上面的头信息中，`Origin`字段用来说名本次请求来自哪个源,服务器根据这个值,决定是否同意这次请求。

如果`Origin`指定的源不在允许范围之内,服务器就会返回一个正常的`HTTP`回应,然后浏览器发现头信息中没有包含`Access-Control-Allow-Origin` 字段,就知道出错啦,然后抛出错误,反之则会出现这个字段(实例如下)

```js
Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Credentials: true
Access-Control-Expose-Headers: FooBar
Content-Type: text/html; charset=utf-8
```

- Access-Control-Allow-Origin 这个字段是必须的,表示接受那些域名的请求(*为所有)
- Access-Control-Allow-Credentials 该字段可选, 表示是否可以发送cookie
- Access-Control-Expose-Headers 该字段可选,`XHMHttpRequest`对象的方法只能够拿到六种字段: `Cache-Control`、`Content-Language`、`Content-Type`、`Expires`、`Last-Modified`、`Pragma` ,如果想拿到其他的需要使用该字段指定。

如果你想要连带`Cookie`一起发送,是需要服务端和客户端配合的

```js
// 服务端
Access-Control-Allow-Credentials: true
// 客户端
var xhr = new XMLHttpRequest();
xhr.withCredentials = true;
// 但是如果省略withCredentials属性的设置,有的浏览器还是会发送cookie的
xhr.withCredentials = false;
```

非简单请求则是不满足上边的两种情况之一,比如请求的方式为 `PUT`,或者请求头包含其他的字段
非简单请求的`CORS`请求是会在正式通信之前进行一次预检请求.浏览器先询问服务器,当前网页所在的域名是否可以请求您的服务器,以及可以使用那些`HTTP`动词和头信息,只有得到正确的答复,才会进行正式的请求

```js
// 前端代码
var url = 'http://localhost:2333/cors';
var xhr = new XMLHttpRequest();
xhr.open('PUT', url, true);
xhr.setRequestHeader('X-Custom-Header', 'value');
xhr.send();
```

由于上面的代码使用的是` PUT` 方法,并且发送了一个自定义头信息.所以是一个非简单请求,当浏览器发现这是一个非简单请求的时候,会自动发出预检请求,看看服务器可不可以接收这种请求,下面是`"预检"`的 `HTTP` 头信息

```http
OPTIONS /cors HTTP/1.1
Origin: localhost:2333
Access-Control-Request-Method: PUT // 表示使用的什么HTTP请求方法
Access-Control-Request-Headers: X-Custom-Header // 表示浏览器发送的自定义字段
Host: localhost:2332
Accept-Language: zh-CN,zh;q=0.9
Connection: keep-alive
User-Agent: Mozilla/5.0...
```

`"预检"`使用的请求方法是 `OPTIONS` , 表示这个请求使用来询问的,

预检请求后的回应，服务器收到`"预检"`请求以后，检查了`Origin`、`Access-Control-Request-Method`和`Access-Control-Request-Headers`字段以后，确认允许跨源请求，就可以做出回应。

预检的响应头:

```http
HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:15:39 GMT
Server: Apache/2.0.61 (Unix)
Access-Control-Allow-Origin: http://localhost:2332 // 表示http://localhost:2332可以访问数据
Access-Control-Allow-Methods: GET, POST, PUT      
Access-Control-Allow-Headers: X-Custom-Header    
Content-Type: text/html; charset=utf-8
Content-Encoding: gzip
Content-Length: 0
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Content-Type: text/plain
```

如果浏览器否定了`"预检"`请求,会返回一个正常的`HTTP`回应,但是没有任何`CORS`的头相关信息,这是浏览器就认定,服务器不允许此次访问,从而抛出错误

预检之后的请求
当预检请求通过之后发出正经的`HTTP`请求,还有一个就是一旦通过了预检请求就会,请求的时候就会跟简单请求,会有一个`Origin`头信息字段。

通过预检之后的,浏览器发出发请求

```http
PUT /cors HTTP/1.1
Origin: http://api.bob.com // 通过预检之后的请求,会自动带上Origin字段
Host: api.alice.com
X-Custom-Header: value
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
```

**关于 CORS 的 cookie 问题**

想要传递 `cookie` 需要满足 3 个条件

1.web 请求设置`withCredentials`

这里默认情况下在跨域请求，浏览器是不带 cookie 的。但是我们可以通过设置 `withCredentials` 来进行传递 `cookie`.

```js
// 原生 xml 的设置方式
var xhr = new XMLHttpRequest();
xhr.withCredentials = true;
// axios 设置方式
axios.defaults.withCredentials = true;
```

2.`Access-Control-Allow-Credentials` 为 `true`

3.`Access-Control-Allow-Origin`为非 `*`

这里请求的方式，在 `chrome` 中是能看到返回值的，但是只要不满足以上其一，浏览器会报错，获取不到返回值。

**3.代理**

### 8.说一说BFC

什么是bfc？https://juejin.cn/post/6950082193632788493
根据W3C的标准，在页面中元素都一个隐含的属性叫做Block Formatting Context简称BFC，该属性可以设置打开或者关闭，默认是关闭的。当元素开启BFC，它就变成一个独立的容器，内部的元素和外部元素互不影响

如何开启元素的BFC
- 1.设置元素浮动
  使用这种方式开启，虽然可以撑开父元素，但是会导致父元素的宽度丢失。而且使用这种方式也会导致下边的元素上移，不能解决问题

- 2.设置元素绝对定位

- 3.设置元素为inline-block
  可以解决问题，但是会导致宽度丢失，不推荐使用这种方式

- 4.将元素的overflow设置为一个非visible的值    

推荐方式：将overflow设置为hidden是副作用最小的开启BFC的方式。

这里简单列举几个触发BFC使用的CSS属性
overflow: hidden
display: inline-block
position: absolute
position: fixed
display: table-cell
display: flex

### 9.说一说Vuex是什么，每个属性是干嘛的，如何使用 ？

Vuex是为Vue开发的管理状态模式，集中存储管理所有组件的状态。属性分别由state、getters、mutations、actions、module。 

（1）state用来定义所要存储的数据，通过$store.state调用数据 

（2）getters可以认为是store的计算属性，通过$store.getters调用属性 

（3）mutations用来存放改变state数据的同步方法，每个方法接收的参数都是state，用$store.commit来调用mutations中的同步方法 

（4）actions用来存放异步方法，接收的参数是context（mutations中的方法），通过$store.dispatch调用actions中的方法 （5）module将store分割成模块，每个模块有自己的state、getters、mutations、actions、甚至嵌套子模块，从上至下进行同步分割 前四个属性除了用$store的方法调用，还能通过import { mapState/mapGetters/... } from 'vuex'引入，再用...mapState/mapGetter/...(['属性/方法名'])的形式映射进来调用

### 10.说一说JavaScript有几种方法判断变量的类型？

1、typeof 用来判断基本数据类型，对于引用数据类型function 返回function，其他都返回Object.

2、instanceof 主要用于区分引用数据类型，检测方法是检测的类型再当前实例的原型链上，用其检测出来的结果都是true,不太适合检测简单数据类型的检测，检测过程繁琐且对简单数据类型中的undefined null symbol检测不出来。

3、constructor:用于检测引用数据类型，检测方法是获取实例的构造函数判断和某个类是否相同，如哦相同就说明该数据是符合那个数据类型的，这种方法不会把原型链上的其他类也加入进来，避免了原型链的干扰。 

4、Object.prototype.toString.call():适用于所有类型的检测，检测方法是Object.prototype.toString.call(数据)返回的是该数据类型的字符串。最精准的就是这个方法

### 11.说一说样式优先级的规则是什么？

important>内联样式>id选择器>类选择器=伪类选择器=属性选择器>标签选择器=伪元素选择器>通配符选择器>继承样式>浏览器默认样式

### 12.说一说JS实现异步的方法？

> javascript语言的执行环境是"单线程"(single thread)，就是指一次只能完成一件任务。如果有多个任务，就必须排队，等前面一个任务完成，再执行后面一个任务，以此类推。
>  这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。

> JS的事件循环机制:同步任务和异步任务会进入不同的场所，同步任务进入主线程，而异步任务会进入EventTable并注册函数，当指定的事件完成之后，异步任务会从EventTable进入事件队列，等待主进程结束之后再执行，

**回调函数**是异步操作的最基本方法，比如AJAX回调，回调函数的优点：简单，容易理解和实现，缺点：不利于代码的阅读和维护。而且每个任务只能指定一个回调函数，不能使用try catch 捕获错误。**promise**不仅能捕获错误，而且很好的解决了地狱回调问题，缺点是无法取消promise，错误需要通过回调函数捕获。Generator 函数是 ES6 提供的一种异步编程解决方案。**async/await**是基于Promise实现的，async/awt使得异步代码看起来像同步代码，所以优点是，使用方法清晰明了，缺点是awt 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 awt 会导致性能上的降低，代码没有依赖性的话，完全可以使用 Promise.all 的方式。

### 13.说一说Vue2.0 双向绑定的原理与缺陷？

Vue响应式指的是：组件的data发生变化，立刻触发视图的更新

vue的双向绑定是采用数据劫持和发布者订阅者模式的方式来实现响应式，通过object.defineProperty来劫持数据的getter，setter,在数据变化时发送消息给订阅者，订阅者收到消息后进行相应的处理。

Object.defineProperty的缺点：

1.无法监听数组变化（在Vue2.x中，通过重写Array原型上的方法解决了这个问题）
2.不能监听对象的新增属性和删除属性

### 14.说一说数组去重都有哪些方法？

1.ES6的set去重（*但是Set去重有一个弊端，他无法去重引用类型的数据。比如对象数组。*）
2.双重循环去重
3.filter配合indexOf去重

```js
const handleRemoveRepeat = (arr) => arr.filter((item,index) => arr.indexOf(item) === index);
```

### 15.说一说null 和 undefined 的区别，如何让一个属性变为null

null表示一个值被定义了，但是是空值，但是undefined表示未被定义。null和undefined在if判断中都会被解析为false，但是在用Number运算时，null的结果为0，undefined的结果为NaN，让属性变为null就需要先定义，再赋空值。

### 16.说一说es6中箭头函数？

1.写法简洁 
2.无自己的this，继承上一个作用域的this（全局或上一个函数） 
3.箭头函数的this永远不会变，call、apply、bind也无法改变 
4.arguments的特殊性（window下保存，this指向上一个函数则arguments表示上一个函数的参数） 
5.箭头函数没有原型prototype
6.箭头函数不能当成一个构造函数(没有自己的this，this的指向不会变，没有原型)

> 我们知道new内部实现其实是分为以下四步：
>
> - 新建一个空对象
>
> - 为该对象添加原型属性`__proto__`，将该属性链接至构造函数的原型对象prototype
>
> - 构造函数绑定新对象的this
>
> - 返回新对象
>

7.箭头函数没有自己的arguments。 箭头函数处于全局作用域中，则没有arguments，箭头函数处于普通函数的函数作用域中，arguments则是上层普通函数的arguments。但可以用可以使用rest参数代替（...)

箭头函数不适用场景:
1.对象方法，且方法中使用了this

```js
var name = '南玖'
var person = {
    name: 'nanjiu',
    say: function() {
        console.log('say:',this.name)
    },
    say2: () => {
        console.log('say2:',this.name)
    }
}

person.say() // say: nanjiu
person.say2() //say2: 南玖

```
person.say2()方法是一个箭头函数，调用person.say2()时，使得this指向全局对象，因此不会得到预期结果。这是因为对象不构成单独的作用域，导致say2()箭头函数定义时的作用域就是全局作用域。而say()定义的是一个普通函数，它内部的this就指向调用它的那个对象，所以使用普通函数符合预期。
2.当函数需要动态this时

### 17.说一说call apply bind的作用和区别？

首先，call apply bind三个方法都可以用来**改变函数的this指向**，具体区别如下：
1、fn.call (newThis,params) call函数的第一个参数是this的新指向，后面依次传入**函数fn要用到的参数**。会**立即**执行fn函数。
2、fn.apply (newThis,paramsArr) apply函数的第一个参数是this的新指向,第二个参数是**fn要用到的参数数组**，会**立即**执行fn函数。
3、fn.bind (newThis,params) bind函数的第一个参数是this的新指向，后面的参数可以直接传递，也可以按数组的形式传入。  **不会立即**执行fn函数，且只能改变一次fn函数的指向，后续再用bind更改无效。返回的是已经更改this指向的新fn

简略版：1.call apply改变this，直接调用，bind改变this,返回函数 2.call:参数是参数们，apply参数是数组

### 18.说一说this指向（普通函数、箭头函数）？

在全局环境中调用普通函数，严格模式下this指向undefined，非严格模式下this指向全局变量window；
通过一个对象来调用函数内部的方法，this指向该对象；
new关键字搭建好的新对象，构造函数里面的this指向新对象本身。

箭头函数没有this，一般是继承外部普通函数的this指向

```js
//全局中调用普通函数
var doSth = function(){
    console.log(this);
}
doSth();//非严格模式下输出全局变量window，严格模式下输出undefined
```

```js
//对象调用函数内部的方法
var doSth = function(){
    console.log(this.name);
}
var student = {
    name: '若川',
    doSth: doSth,
    other: {
        name: 'other',
        doSth: doSth,
    }
}
student.doSth(); // '若川'
```

```js
function Student(name){
    this.name = name;
    console.log(this); 
}
var result = new Student('若川');//输出 Student { name: '若川' }
```

简略版：普通函数中的this指向函数调用者，箭头函数中的this指向所在执行上下文中的this

### 19.说一说CSS尺寸设置的单位

px：绝对像素
rem：相对于根元素像素
em：相对于父元素像素 
vw：视口宽度
vh：视口高度

### 20.说几个未知宽高元素水平垂直居中方法

**1、设置父元素为flex布局**

```html
<body>
<div class="wrapper flex-center">
  <p>horizontal and vertical</p>
</div>
</body>
<style>
  .wrapper {
    width: 300px;
    height: 300px;
    border: 1px solid #ccc;
      
    display: flex;//设置父元素为flex布局
    justify-content: center;//设置主轴的排列方式
    align-items: center;//设置交叉轴的排列方式
  }

</style>
```

**2、absolute定位+transform **

```html
<body>
<div class="wrapper">
  <img src="https://p3-passport.byteimg.com/img/user-avatar/44193963b7d6dde4fca72c6facebe465~100x100.awebp">
</div>
</body>
<style>
  .wrapper {
    width: 300px;
    height: 300px;
    border: 1px solid #ccc;

    position: relative;//外层设置定位
  }

  .wrapper > img {
    position: absolute;//内层设置绝对定位
    left: 50%;//相对于父元素往右偏移50%
    top: 50%;//相对于父元素往下偏移50%
    transform: translate(-50%, -50%);
  }

</style>
```

> 相对定位relative相对定位是元素在移动的时候，是相对于它原来的位置来说的。
>
> 绝对定位absolute是元素在移动的时候，是相对于它祖先元素（父，爷，曾爷）来说的。(如果没有祖先元素或者祖先元素没有定位，则以浏览器(body)为准定位)

### 21.说一说JS变量提升？

变量提升是指，在ES6以前我们在定义变量并且赋值时，JavaScript 引擎把首先会将变量和函数的声明提升到代码开头进行声明,并赋值undefined。这导致我们可以未声明变量的情况下提前使用该变量，并且不会报错。

```js
console.log(a)//undefined
var a=4
console.log(a)//4
```

在es6出来以后，let 和 const声明的变量必须先声明才能使用，否则会报错，并且let 和 const会有暂时性死区（在初始化之前访问let和const创建的变量会报错）的概念

### 22.说一说 HashRouter 和 HistoryRouter的区别和原理？
history和hash都是利用浏览器的2种特性实现前端路由，history是利用浏览历史记录栈的API实现，hash是监听location hash值变化事件来实现 
1.history的url没有#号，hash有#号 
2.history需要后端配合，如果后端不配合刷新页面会出现404;hash不需要后端配合hash（可以理解为只在前端自生自灭）
3.相同的url,history会触发添加到浏览器历史记录栈中，hash不会触发

hashRouter原理：通过window.onhashchange获取url中hash值.当井号 # 后面的路径发生变化时，浏览器并不会重新发起请求，而是会触发 onhashchange 事件。
historyRouter原理：通过history.pushState,使用它做页面跳转不会触发页面刷新，使用window.onpopstate监听浏览器的前进和后退

### 23.说一说map 和 forEach 的区别？

forEach和map都不改变原数组，但是能改变原数组的对象中的属性；
map会返回一个新的数组和原数组长度一样的数组，而forEach没有返回值，只是起到遍历作用
map的处理速度比forEach快，更推荐使用map

### 24.说一说事件循环Event loop，宏任务与微任务？
**Event Loop(事件循环)**

<img src="C:\Users\Jasmine\Desktop\面试\img\222.awebp" alt="cmd-markdown-logo" style="zoom: 67%;" />

（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。 
（2）主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。 
（3）一但"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。 
（4）主线程不断重复上面的第三步。

简略版：js是单线程的，主线程在执行时会不断循环往复的从同步队列中读取任务，执行任务，当同步队列执行完毕后再从异步队列中依次执行。

宏任务与微任务都属于异步任务，再执行上微任务的优先级高于宏任务，因此每一次都会先执行完微任务在执行宏任务。宏任务有定时器，Dom事件，ajax事件，requestAnimationFrame。微任务有：promise的回调、MutationObserver 的回调 ,process.nextTick

### 25.说一说Vue3.0 实现数据双向绑定的方法 ？

在Vue2.0的基础上将Object.definedproperty换成了功能更强大的proxy，原理相同。在vue实例初始化的时候（vm._init()执行的时候）调用Observe类的实例方法observe，传入数据（若是对象则发生递归），将其中每个数据进行一遍数据劫持（get实现依赖收集，set实现事件派发（这里的模式为发布订阅模式））。

相对vue2.0解决的问题：解决无法监听新增属性或删除属性的响应式问题、解决无法监听数组长度和index变化问题。

### 26.说一下Diff算法？

![截屏2021-08-07 下午10.59.31.png](C:\Users\Jasmine\Desktop\面试\img\121.awebp)

> `虚拟DOM`是一个`对象`，一个什么样的对象呢？**一个用来表示真实DOM的对象**

> 例如 如果只有一个li标签修改了文本，其他都是不变的，所以没必要所有的节点都要更新，只更新这个li标签就行，Diff算法就是查出这个li标签的算法。

**Diff算法是一种对比算法**。对比旧虚拟DOM和新虚拟DOM，对比出是哪个虚拟节点更改了，找出这个虚拟节点，并只更新这个虚拟节点所对应的真实节点，

Diff算法的原理：
1.同层对比
新旧虚拟DOM对比的时候，Diff算法比较只会在同层级进行, 不会跨层级比较。 所以Diff算法是:深度优先算法。 时间复杂度:O(n)

<img src="C:\Users\Jasmine\Desktop\面试\img\232.awebp" alt="截屏2021-08-08 上午11.32.47.png" style="zoom:50%;" />

2.Diff对比流程
当数据改变时，会触发setter，并且通过Dep.notify去通知所有订阅者，订阅者们就会调用patch方法，给真实DOM打补丁，更新相应的视图。

![截屏2021-08-08 上午11.49.38.png](C:\Users\Jasmine\Desktop\面试\img\32.awebp)

3.patch方法：对比当前同层的虚拟节点是否为同一种类型的标签(同一类型的标准，下面会讲)
是：继续执行patchVnode方法进行深层比对
否：没必要比对了，直接整个节点替换成新虚拟节点

### 27.实现两栏布局和三栏布局？

**两栏布局**实现效果是将页面分割成左右宽度不登的两列,宽度较小的列设置为固定高度,剩余宽度由另一列撑满。

实现：flex布局 左边固定宽度，右边自适应

```xml
<body>
<div class="box">
  <div class="left">left</div>
  <div class="right">right</div>
</div>
</body>
<style>
  .wrapper {
    display: flex;//将外层设置为flex布局
  }

  .left {
    width: 100px;//固定宽度
    height: 300px;
    background-color: pink;
  }

  .right {
    height: 300px;
    background-color: orange;

    flex: 1;//元素充分利用剩余空间，同时不会侵占其他元素应有的宽度
  }
</style>
```

**三栏布局**

实现：flex布局 两边固定宽度，中间自适应

```xml
<div class="wrap">
    <div class="left">左侧</div>
    <div class="middle">中间</div>
    <div class="right">右侧</div>
</div>
<style type="text/css">
    .wrap {
        display: flex;//将外层设置为flex布局
    }

    .left,
    .right,
    .middle {
        height: 100px;
    }

    .left {
        width: 200px;//固定宽度
        background: pink;
    }

    .right {
        width: 120px;//固定宽度
        background: pink;
    }

    .middle {
        background: orange;
        flex: 1;//元素充分利用剩余空间，同时不会侵占其他元素应有的宽度
    }
</style>
```

### 28.说一下浏览器垃圾回收机制？
垃圾回收也就是定期找出那些不再用到的变量，然后释放其内存
垃圾回收机制分为栈垃圾回收和堆垃圾回收。
对于栈回收机制，当一个函数执行完成之后，JS会向下移动引擎来销毁该函数保存在栈中的执行上下文，遵循先进先出机制
对于堆空间中的数据，则需要依靠垃圾回收器进行回收。可以使用标记清除算法以及引用计数算法。
标记清除法：1.给内存所有对象打上标记，假设所有都是垃圾（全0），从一组根对象开始遍历，把不是垃圾的变为1，清除垃圾节点，销毁内存，把所有对象重新变0.但是清除后的内存空间不是连续的（内存碎片），存在分配问题。
引用计数法：对象是否需要=对象是否被其他对象引用，假设声明对象并使用引用赋值时引用次数为1，let a = new Object()，如果又被另一个值引用，再加1，如果引用变量被修改，减一，为0时，垃圾回收器回收空间，相较于标记清楚法，不需要循环遍历，能立即回收，但是维护计数器也会产生内存开销。

### 29.说一说 vue 的 keep-alive ？

使用`<keep-alive>`标签对需要缓存的组件进行包裹，默认情况下被`<keep-alive>`标签包裹的组件都会进行缓存

1.效果方面：能在内存保持其中的组件状态，放置重复渲染DOM，减少加载时间，从而提高性能。2.使用方面：有三个属性：include：指明要缓存的组件的名称，只有匹配的组件才会被保存。exclude：只有匹配的组件才不会被保存。max：最多能保存的组件数。3.结合Router使用：可以在相应组件下规定mate属性，并将keep-alive设置为true。4.源码实现方面：可以结合Vue组件实例加载顺序讲解，VNode->实例化->_updata->真实Node，在实例化的时候会判断该组件是否被keep-alive保存过，是的话则直接拿其中的DOM进行渲染。

### 30.CSRF攻击是什么？

跨域请求伪造。通过伪造受害者的请求并自动携带cookie给目标网站实行恶意操作

假设受害者用户A登录了目标网站某宝，且浏览器上存有某宝设置的鉴权cookie；攻击者B制作了钓鱼网站并在里面嵌入了发送伪造请求给某宝的恶意代码，B通过社会工程学诱导A点击了钓鱼网站；A的浏览器向某宝发送了B伪造的请求并自动携带上鉴权cookie，某宝服务器鉴权通过，造成A账户金额损失。

 防范CSRF攻击的方式： 1.给鉴权cookie设置sameSite=strict属性（使得 Cookie 在跨站请求时不会被发送），防止cookie自动携带至第三方请求上。 2.使用token进行鉴权，并将token存储在sessionStorage中。

### 31.XSS攻击是什么？

xss指跨站脚本攻击，是攻击者通过向被攻击网站注入恶意代码实现攻击，当被攻击者登陆这些网站时就会执行恶意代码，读取cookie、session以及其他敏感信息

 防范XSS攻击的方式：1.就是对输入框的内容进行过滤或使用转义符进行转码。2.使用CSP，就是`白名单`，告诉浏览器哪些外部资源可以加载执行。3.对一些敏感信息进行保护，在`Cookie`信息中添加`httpOnly`，告诉浏览器在保存Cookie，且不要对客户端脚本开放访问权限，然后就不能通过document.cookie获取cookie了

### 32.说一说js继承的方法和优缺点？

1、**原型链继承** （不推荐）
子类型的原型为父类型的一个实例对象。

优点：写法简单、容易理解。缺点：①无法向父类构造函数传参②父类的所有属性被共享，只要一个实例修改了属性，其他所有的子类实例都会被影响
2、**借用构造函数继承**（不推荐）
在子类型构造函数中通用call()调用父类型构造函数

优点：①父类的所有属性被共享；②在子类实例对象创建时，可以向父类传参；缺点：①无法实现函数复用，每个子类都有父类实例函数的副本，影响性能 ②只是子类的实例，不是父类的实例
3、**组合继承**(推荐)
组合 原型链继承 和 借用构造函数继承。
通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用。

 --- 融合原型链和借用构造函数的优点，是js中最常用的继承方式；缺点：调用了两次父类构造函数，一是创建子类原型对象时，二是子类构造函数内部。

4、**寄生组合继承**（推荐）
结合借用构造函数传递参数和寄生模式实现继承
通过借用构造函数继承属性,通过原型链的混成形式继承方法
使用寄生式继承来继承超类型的原型,然后在将结果指定给子类型的原型
--- 优点：高效率只调用一次父类构造函数，并且避免了子类原型对象上不必要、多余的属性，同时，还能将原型链保持不变，因此能使用instanceof 和 isPrototypeOf。缺点：代码复杂
5**.ES6中class 的继承**(最佳)
ES6中引入了class关键字，class可以通过extends关键字实现继承，还可以通过static关键字定义类的静态方法
ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。

代码实现


```js
//原型链继承
 //父类型
       function Person(name, age) {
           this.name = name,
           this.age = age,
           this.play = [1, 2, 3]
           this.setName = function () { }
       }
       Person.prototype.setAge = function () { }
       //子类型
       function Student(price) {
           this.price = price
           this.setScore = function () { }
       }
       Student.prototype = new Person() // 子类型的原型为父类型的一个实例对象
       var s1 = new Student(15000)
       var s2 = new Student(14000)


```

```js
// 借用构造函数继承
  function Person(name, age) {
    this.name = name,
    this.age = age,
    this.setName = function () {}
  }
  Person.prototype.setAge = function () {}
  function Student(name, age, price) {
    Person.call(this, name, age)
    this.price = price
  }
  var s1 = new Student('Tom', 20, 15000)


```

```js
//组合继承
        function Person(name, age) {
            this.name = name,
            this.age = age,
            this.setAge = function () { }
        }
        Person.prototype.setAge = function () {
            console.log("111")
        }
        function Student(name, age, price) {
            Person.call(this,name,age)
            this.price = price
            this.setScore = function () { }
        }
        Student.prototype = new Person()
        Student.prototype.constructor = Student//组合继承也是需要修复构造函数指向的
        Student.prototype.sayHello = function () { }
        var s1 = new Student('Tom', 20, 15000)
        var s2 = new Student('Jack', 22, 14000)
        console.log(s1)
        console.log(s1.constructor) //Student
        console.log(p1.constructor) //Person

```

```js
//ES6中class 的继承
       class Person {
            //调用类的构造方法
            constructor(name, age) {
                this.name = name
                this.age = age
            }
            //定义一般的方法
            showName() {
                console.log("调用父类的方法")
                console.log(this.name, this.age);
            }
        }
        let p1 = new  Person('kobe', 39)
        console.log(p1)
        //定义一个子类
        class Student extends Person {
            constructor(name, age, salary) {
                super(name, age)//通过super调用父类的构造方法
                this.salary = salary
            }
            showName() {//在子类自身定义方法
                console.log("调用子类的方法")
                console.log(this.name, this.age, this.salary);
            }
        }
        let s1 = new Student('wade', 38, 1000000000)
        console.log(s1)
        s1.showName()
```

### 33.说一说defer和async区别？

```html
<script src="script.js"></script>
<script  src="script.js" async></script>
<script  src="script.js" defer></script>
```

![img](C:\Users\Jasmine\Desktop\面试\img\mage)

前提：html文件都是按顺序执行的

`<script>` : 当HTML解析过程中遇到script标签时，浏览器中断HTML解析，随即下载script文件，完成后立即执行script，执行完成后再继续HTML解析

`<script async>` : 当HTML解析过程中遇到script标签时，不会中断HTML解析，同时并行下载script文件，下载完成后中断HTML解析并执行script，执行完成后再继续HTML解析（script的执行顺序不一定按照script标签的出现顺序，而是取决于script下载完成的顺序）

`<script defer>`（更合理） : 当HTML解析过程中遇到script标签时，不会中断HTML解析，同时并行下载script文件，直到HTML解析完成再执行script（script的执行顺序与script标签出现顺序一致）

### 34.说一下浏览器如何渲染页面的？

1、HTML被HTML解析器解析成DOM树。
2、CSS被CSS解析器解析成CSS规则树。
3、浏览器会将CSS规则树附着在DOM树上，并结合两者生成渲染树Render Tree。
4、生成布局（flow），浏览器通过解析计算出每一个渲染树节点的位置和大小，在屏幕上画出渲染树的所有节点。 
5、将布局绘制（paint）在屏幕上，显示出整个页面

简略版：
1.解析HTML，生成DOM树
2.解析CSS，生成CSSOM树
3.两棵树结合，生成Render树
4.计算布局，绘制页面的所有节点
5.绘制布局

### 35.说一说computed和watch的区别？

computed一般用于计算得出数据，并将数据缓存在内存当中，computed计算结果一般由他的依赖项所决定，只有当依赖项发生改变，computed才会重新计算，提升性能，在computed中只能进行同步操作。watch一般用于监听某一个属性或者多个属性甚至是一个对象，更多是监听管擦作用数据变化后会引发什么样的动作，在watch中可以进行异步操作

### 36.说一说 Vue 中 $nextTick 作用与原理？

> vue 采用的**异步更新策略**，当监听到数据发生变化的时候不会立即去更新DOM，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。 所以数据变化了，DOM却不会立即的更新，而是在下一个Tick中更新dom。
>
>  这种做法带来的好处就是可以将多次数据更新合并成一次，减少操作DOM的次数，
>  如果不采用这种方法，假设数据改变100次就要去更新100次DOM，而频繁的DOM更新是很耗性能的；

nexTick 的**作用**：nextTick 接收一个回调函数作为参数，并将这个回调函数延迟到DOM更新后才执行；

简略版：vue中数据更新的时候，页面不会立刻更新，而是等同一个事件循环的数据都变化后，才统一更新页面，换句话说，它是异步的，如果要在数据修改的时候拿到更新后的DOM，就需要从nexttick中获取，nexttick本质是返回promise

### 37.说一下token 能放在cookie中吗？

![批注 2022-06-20 232618.png](C:\Users\Jasmine\Desktop\面试\img\126f7awebp)



可以，token是用来判断用户是否登录的，客户端输入用户名和密码，服务器收到请求，去验证用户名和密码，验证成功后，服务端签发一个token发送给客户端，客户端可以把它保存在cookie和localStorage应用下次验证登录。`token` 是否过期，应该由后端来判断，不该前端来判断，所以`token`存储在`cookie`中只要不设置`cookie`的过期时间就ok了。

但最好不要放cookie里，容易产生CSRF问题

### 38.说一下浏览器输入URL发生了什么？

①url判断。判断输入的是搜索内容还是url。 ②查找本地缓存。如果能在本地找到缓存直接返回页面，如果没有缓存需要发送网络请求页面。 ③DNS解析：将域名转换为IP地址。 ④通过三次握手建立TCP连接。 ⑤合成请求头信息，发送http请求。 ⑥服务器响应返回结果。 ⑦通过四次挥手释放TCP连接。 ⑧浏览器渲染。 ⑨js引擎解析。

复杂版：输入地址，浏览器查找域名的 IP 地址。 浏览器向 该 IP 地址的web 服务器发送一个 HTTP 请求，在发送请求之前浏览器和服务器建立TCP的三次握手，判断是否是HTTP缓存，如果是强制缓存且在有效期内，不再向服务器发请求，如果是HTTP协商缓存向后端发送请求且和后端服务器对比，在有效期内，服务器返回304，直接从浏览器获取数据，如果不在有效期内服务器返回200，返回新数据。 请求发送出去服务器返回重定向，浏览器再按照重定向的地址重新发送请求。 如果请求的参数有问题，服务器端返回404，如果服务器端挂了返回500。 如果有数据一切正常，当浏览器拿到服务器的数据之后，开始渲染页面同时获取HTML页面中图片、音频、视频、CSS、JS，在这期间获取到JS文件之后，会直接执行JS代码，阻塞浏览器渲染，因为渲染引擎和JS引擎互斥，不能同时工作，所以通常把Script标签放在body标签的底部。 渲染过程就是先将HTML转换成dom树，再将CSS样式转换成stylesheet，根据dom树和stylesheet创建布局树，对布局树进行分层，为每个图层生成绘制列表，再将图层分成图块，紧接着光栅化将图块转换成位图，最后合成绘制生成页面。

### 39.说一说组件通信的方式？

1、父子组件通信常用props和$emit还有$refs；2、兄弟组件通信常用定义的公共事件bus的$on、$emit；3、祖先和子孙组件通信常用$attrs和$listener、provide和inject；4、复杂通信常用vuex，pinia

### 40.说一说 v-if 和 v-show区别？

v-if：是否渲染，耗费的性能大。 v-show：是否显示，相当于是否设置display:none。

 v-if: 适合使用在切换不频繁，且元素内容很多，渲染一次性能消耗很大的元素上。v-show: 适合使用在切换频繁显示/隐藏的元素上。

### 41.说一说伪数组和数组的区别？

1. 伪数组的特点：类型是object、不能使用数组方法、可以获取长度、可以使用for in遍历
2. 伪数组可以装换为数组的方法：a. Array.prototype.slice.call() b.Array.from() c. [...伪数组] 
3. 有哪些是伪数组：函数的参数arguments，Map和Set的keys()、values()和entires()



### 42.说一说cookie、sessionStorage、localStorage 区别？

共同点：
1.都是浏览器存储
2.都存储在浏览器本地 
区别：
1.cookie由服务器写入， sessionStorage以及localStorage都是由前端写入 
2.cookie的生命周期由服务器端写入时就设置好的，localStorage是写入就一直存在，除非手动清除，sessionStorage是由页面关闭时自动清除 
3.cookie存储空间大小约4kb， sessionStorage及localStorage空间比较大，大约5M 
4.三者的数据共享都遵循同源原则，sessionStorage还限制必须是同一个页面
> 什么是同源
> 在了解跨域这个概念之前首先要知道的是何为同源策略。所谓的同源是一种安全机制，为了预防某些恶意行为（例如 Cookie 窃取等），浏览器限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。而满足同源要具备三方面：协议相同、域名相同、端口相同。

5.前端给后端发送请求时，自动携带cookie, session 及 local都不携带 6.cookie一般存储登录验证信息或者token，localStorage常用于存储不易变动的数据，减轻服务器压力，sessionStorage可以用来监测用户是否是刷新进入页面，如音乐播放器恢复进度条功能

### 43.说一说如何实现可过期的localstorage数据？

localStorage一般用于长久保存浏览器的数据，保存的数据没有过期时间，直到手动删除。所以要如何实现可过期的localStorage缓存呢？目前有两种方法。1惰性删除，2.定时删除。

**惰性删除**是指某个键值过期后，该键值不会被马上删除，而是等到下次被使用的时候，才会被检查到过期，此时才能得到删除。

实现方法： 在获取数据的时候，我们可以对比存储的时间和当前的时间，判断有没有过期，如果过期了则清除localStorage。

**定时删除**是我们每隔一段时间执行一次删除操作

实现方法：获取所有设置过期时间的key判断是否过期，过期就存储到数组中，遍历数组，每隔1S（固定时间）删除5个（固定个数），直到把数组中的key从localstorage中全部删除。

### 44.说一说axios的拦截器原理及应用？

axios拦截器分为响应和请求拦截器:

请求拦截器 在请求发送前进行必要操作处理，例如添加统一cookie、请求体加验证、设置请求头等，相当于是对每个接口里相同操作的一个封装； 

响应拦截器 同理，响应拦截器也是如此功能，只是在请求得到响应之后，对响应体的一些处理，通常是数据统一处理等，也常来判断登录失效等。

### 45.说一说创建ajax过程？

> Ajax的工作原理相当于在用户和服务器之间加了一个中间层(AJAX引擎)，使用户操作与服务器响应异步化。客户端发送请求，请求交给xhr，xhr把请求提交给服务器，服务器进行业务处理，服务器响应数据交给xhr对象，xhr对象接收数据，由javascript把数据写到页面上，如下图所示：

![AJAX工作原理图](C:\Users\Jasmine\Desktop\面试\img\7adb89a0df3f.awebp)

（1）创建异步对象，即 XMLHttpRequest 对象。 

```js
 let xhr = new XMLHttpRequest();
```

（2）注册回调函数：注册 onreadystatechange 事件，状态改变时就会调用。如果要在数据完整请求回来的时候才调用，我们需要手动写一些判断的逻辑。 

```js
xhr.onreadystatechange = function callback() {
  // 判断异步对象的状态
  if(xhr.readyState == 4) {
    // 判断交互是否成功
    if(xhr.status == 200) {
      // 获取服务器响应的数据
      var res = xhr.responseText
      // 解析数据
      res = JSON.parse(res)
    }
  }
}
```

（3）使用open方法与服务器建立连接。open(method, url, async)。参数解释：请求的方法、请求的 url、是否异步。第三个参数如果不写，则默认为 true。 

```js
// get 方式
xhr.open("get", "test.php", true)

// post 方式发送数据 需要设置请求头
xhr.open("post", "test.php", true)
xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded")

```

（4）发送请求：send()。 

```js
// get 不需要传递参数
xhr.send(null)

// post 需要传递参数
xhr.send("name=jay&age=18")
```

（5）服务端响应，获取返回的数据。

### 46.说一下fetch 请求方式？

> Fetch 和 Axios/Ajax 的关系
>
**Axios是对XMLHttpRequest的封装，而Fetch是一种新的获取资源的接口方式，并不是对XMLHttpRequest的封装。**

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/515d70fb207e49b79e9edaa8b2d871c5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

fetch是一种HTTP数据请求的方式，是XHR的一种替代方案。Fetch函数就是原生js，没有使用XMLHttpRequest对象。给`fetch()` 提供一个参数指明资源路径，会返回一个包含响应结果的promise。

### 47.说一下有什么方法可以保持前后端实时通信？

前后端一般通过HTTP协议进行交互，但HTTP协议是基于“问答模式”的，即客户端发起询问，服务端才会响应。但对于一些实时的场景，比如股票趋势图、直播...等，服务端更新数据的速度很快，如果每次都要客户端询问，这样传输数据的效率十分低下，所以得通过其它交互模式支持实时通信。

实现实时通信有以下几种方式： 

1.短轮询：客户端设置定时器，每隔几秒就向服务端发送请求，通过频繁地请求到达实时的效果。这种方式要求服务器的响应速度很快。 

2.长轮询：客户端和服务端保持一条长连接，一旦服务端有新的数据，不等客户端请求就会主动发送给对方。这种方式要求服务器有高并发能力。

3.iframe流：在页面中插入一个隐藏的iframe，利用其src属性在服务器和客户端之间创建一条长连接，服务器向iframe传输数据（通常是HTML，内有负责插入信息的javascript），来实时更新页面。

4.WebSocket：一种全双工通信协议，客户端和服务端处于相同的地位。通过客户端与服务端建立的HTTP连接进行切换，客户端会发送一个带update:websocket字段的HTTP请求请求协议切换，服务端会回复带101状态码的响应表示协议切换成功。接着它们使用websocket进行通信，一旦有新的数据服务端可以直接发送给客户端。 

5.SSE（Server-Sent Event）：服务端与客户端建立的一个单向通道，只能由服务端传输特定形式的数据给服务端，这里并不是建立一个长连接。

短轮询适用于：小型应用，实时性不高。 长轮询适用于：一些早期的对及时性有一些要求的应用：web IM 聊天。 iframe适用于：客服通信等。 WebSocket适用于：微信、网络互动游戏等。 SSE适用于：金融股票数据、看板等

### 48.说一下重绘、重排区别如何避免？

重排：页面DOM元素的布局/位置发生变化，需要重新排列元素位置。

重绘：页面DOM元素的样式发生变化，需要重新绘制元素图层。

触发重排的方法有：

1. 初始化页面
2. 改变文字大小
3. 浏览器计算offsetHeight/width，resize
4. 设置css伪类 5. style属性。 

避免重排的方法有
1.尽量用class类的方式统一修改样式 
2.脱离文档流 
3.transform的方式调整位置 而不是 top、left、margin等，触发GPU加速 
4.减少使用table布局 
5.使用visibility：hidden ，隐藏元素而不是 display：none 更改文档流

https://juejin.cn/post/6854573209791135757

### 49.说一说 Vue 列表为什么加 key？

Vue列表加key的目的是为diff算法添加标识，因为diff算法判断新旧VDOM是否相同的依据是节点的tag和key。如果tag和key相同则会进一步进行比较，使得尽可能多的节点进行复用。此外，key绑定的值一般是一个唯一的值，比如id。如果绑定数组的索引index，则起不到优化diff算法的作用，因为一旦数组内元素进行增删，后续节点的绑定的key也会发生变化，导致diff进行多余的更新操作。

### 50.说一说vue-router 实现懒加载的方法？

懒加载的核心思想是按需加载，也叫做异步加载：只有请求到该组件的时候，才会对该组件进行网络请求并加载。懒加载有利于解决页面首次请求资源过多，导致白屏时间长的问题。 

vue-router的懒加载即通过箭头函数的写法导入组件如 `const Home= ()=> import('../路径')；`

### 51.说一说前端性能优化手段？

前端性能优化从两个方面入手，使浏览器获取页面资源更快和使浏览器渲染页面更快

**使浏览器获取页面资源更快**：

1. 让传输的数据包更小（压缩文件/图片）：图片压缩和文件压缩 
2. 减少网络请求的次数：雪碧图/精灵图、节流防抖 
3.  减少渲染的次数：缓存（HTTP缓存、本地缓存、Vue的keep-alive缓存等）

**使浏览器渲染页面更快**：

1. 提前渲染：ssr服务器端渲染 
2. 避免渲染阻塞：CSS放在HTML的head中 JS放在HTML的body底部 
3. 避免无用渲染：懒加载 
4. 减少渲染次数：对dom查询进行缓存、将dom操作合并、使用减少重排的标签

### 52.事件扩展符用过吗(...)，什么场景下？

对象中的扩展运算符(...)用于取出参数对象中的所有可遍历的属性，浅拷贝到当前的对象中

> 浅拷贝和深拷贝：浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。

1.数组去重`[...new Set(arr)] `2.数组拷贝`[...arr] `3.伪数组转真数组` [...伪数组]`

### 53.说一说vue钩子函数？

我们把一个对象从生成（new）到被销毁（destory）的过程，称为生命周期。Vue 为生命周期中的每个状态都设置了钩子函数(监听函数) 。每当 Vue 实例处于不同的生命周期时，对应的函数就会被触发调用。