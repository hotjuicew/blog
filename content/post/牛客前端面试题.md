---
title: "牛客前端面试题"
date: 2022-11-17T21:27:14+08:00
categories: ["面试"]
tags: ["面试"]
---





## 各公司面试

### 海康威视

**海康威视（杭州）前端实习一面**

1： 自我介绍

2： 项目
3： vue 组件通信方法，介绍一下

**1、父子组件通信：**

**props：使用 props 将数据从父组件传递到子组件。**

**$emit：子组件通过派发事件的方式给父组件数据。**

**$refs：父组件可以通过 ref 主动获取子组件的属性或者调用子组件的方法**

**2、兄弟组件通信：**

**EventBus: 使用 EventBus 的 $on、$emit 方法通过创建一个自定义事件来进行通信**

**3、祖先和子孙组件通信常用provide和inject；**

**4、复杂通信常用vuex，pinia**

4： 深拷贝和浅拷贝区别？数组深拷贝方法？

**对于数组、对象这些复杂数据类型，浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。**

**数组深拷贝方法：**
- **使用数组遍历赋值**
- **使用slice/map/concat返回新数组**
- **ES6扩展运算符**

5： vue 生命周期，各个周期做了什么

**每个组件都可能会经历从创建、挂载、更新、卸载等一系列的过程，称为生命周期。Vue 为生命周期中的每个状态都设置了钩子函数(监听函数) 。每当 Vue 实例处于不同的生命周期时，对应的函数就会被触发调用。**

**这些生命周期钩子包括：**

- **beforeCreate: 在实例初始化之后，在当前阶段 `data`、`methods`、`computed` 以及 `watch` 上的数据和方法都不能被访问。**
- **created: 实例已经创建完成之后被调用。当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发 `updated` 函数。可以做一些初始数据的获取，在当前阶段无法与 `Dom` 进行交互**
- **beforeMount: 发生在挂载之前，当前阶段虚拟 `Dom` 已经创建完成，即将开始渲染。**
- **mounted: 在挂载完成后发生，在当前阶段，真实的 `Dom` 挂载完毕，数据完成双向绑定，可以访问到 `Dom` 节点，使用 `$refs` 属性对 `Dom` 进行操作。**
- **beforeUpdate: 发生在更新之前，也就是响应式数据发生更新，虚拟 `dom` 重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染。**
- **updated: 发生在更新完成之后，当前阶段组件 `Dom` 已完成更新。**
- **beforeDestroy: 实例销毁之前调用。在这一步，实例仍然完全可用，我们可以在这时进行善后收尾工作，比如清除计时器。**
- **destroyed: Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，这个时候只剩下了 `dom` 空壳。。**

6： watch 和 computed 区别

**computed 是计算属性，watch是监听器，监听某个数据发生变化，然后执行一些操作。**

**Computed 更适合处理基于已有数据的计算值，它可以自动缓存和更新，而 Watch 更适合用于监听某些需要手动处理的数据变化，它可以在数据变化时触发一些额外的操作。**

7： 水平垂直居中方法，除了样式还有别的方法吗（这个我不知道，我只知道样式）

**1.使用 Flexbox 布局：Flexbox 是一种 CSS 布局模型，可以轻松地实现水平垂直居中。通过设置父元素的 display 为 flex，并设置 align-items 和 justify-content 属性，可以实现水平垂直居中。**

```css
.parent {
  display: flex;
  align-items: center;
  justify-content: center;
}
```

**2.使用 Grid 布局：Grid 布局是一种 CSS 布局模型，可以用来实现复杂的布局。通过设置父元素的 display 为 grid，并设置 align-items 和 justify-items 属性，可以实现水平垂直居中。**

```css
.parent {
  display: grid;
  align-items: center;
  justify-items: center;
}
```

8： rem em px

**px：绝对像素**
**rem：相对于根元素像素**
**em：相对于父元素像素（如果父元素没有设置字体大小，em 会继续向上查找父元素的父元素，直到找到设置了字体大小的元素为止。如果找不到设置了字体大小的元素，则会相对于浏览器默认字体大小进行计算。）**
**vw：视口宽度。1vw 相当于视口宽度的 1%。**
**vh：视口高度**

9： async await 
10： 路由守卫

**导航守卫就是路由跳转过程中的一些钩子函数，用于在路由跳转之前或之后进行特定的操作。路由守卫可以用来实现身份验证、权限控制等功能。**

**（1）全局守卫：是指路由实例上直接操作的钩子函数，特点是所有路由配置的组件都会触发，直白点就是触发路由就会触发这些钩子函数**

- **beforeEach（to，from， next）**
- **beforeResolve（to，from， next）**
- **afterEach（to，from）**

**（2）路由守卫： 是指在单个路由配置的时候也可以设置的钩子函数**

- **beforeEnter（to，from， next）**

**（3）组件守卫：是指在组件内执行的钩子函数，类似于组件内的生命周期，相当于为配置路由的组件添加的生命周期钩子函数。**

- **beforeRouteEnter（to，from， next）**
- **beforeRouteUpdate（to，from， next）**
- **beforeRouteLeave（to，from， next）**

**通常在路由守卫中使用 next() 函数来控制路由的跳转，next() 函数有以下三种用法:**

1. **next()：继续路由跳转。**
2. **next(false)：终止路由跳转。**
3. **next(‘/’)：跳转到指定路由。**

**如果你需要在路由跳转前进行身份验证，可以使用全局守卫或路由独享守卫，在 next() 函数中添加验证逻辑。**

**例如:**

```js
router.beforeEach((to, from, next) => {
  if (!isAuthenticated) {
    next('/login');
  } else {
    next();
  }
});
```

**这样在进入任何路由之前，都会先进行身份验证。**

11： url输入浏览器发生了什么

1. **浏览器通过DNS解析查找该域名的IP地址**
2. **浏览器检查是否是HTTP缓存，如果是强制缓存且在有效期内，不再向服务器发请求。如果是HTTP协商缓存，浏览器向该IP地址的web服务器发送一个HTTP请求，（在发送请求之前浏览器和服务器建立TCP的三次握手）如果在有效期内，服务器返回304，直接从浏览器获取数据。如果不在有效期内服务器返回200，返回新数据。**
3. **如果请求的参数有问题，服务器端返回404，如果服务器端挂了返回500。**
4. **如果有数据一切正常，当浏览器拿到服务器的数据之后，开始渲染页面同时获取HTML页面中图片、音频、视频、CSS、JS。**
5. **在这期间获取到JS文件之后，会直接执行JS代码，阻塞浏览器渲染，因为渲染引擎和JS引擎互斥，不能同时工作，所以通常把Script标签放在body标签的底部。**
6. **渲染过程是先将HTML转换成dom树，再将CSS样式转换成stylesheet，根据dom树和stylesheet创建布局树，对布局树进行分层，为每个图层生成绘制列表，再将图层分成图块，紧接着光栅化将图块转换成位图，最后合成绘制生成页面。**

12： 有没有封装过element-ui

我没有封装过element-ui, 但我熟悉使用它并且了解它的基本原理，它是基于Vue.js的一个组件库，能够帮助我们快速开发项目中的界面，我知道如何使用它的组件，如何自定义样式和事件等。

13： 反问

**实习面试**
1：是否配置过webpack

**是的，我曾经配置过webpack。我熟练地了解webpack的配置，能够使用webpack来打包项目中的资源，如js、css、图片、字体等。我知道如何配置webpack的入口、出口、模块、插件等，并且能够使用webpack优化项目的性能，如代码压缩，懒加载等。** 

1. **配置入口和出口，设置打包的入口文件和输出文件的路径。**
2. **配置模块，使用loaders来处理不同类型的文件，如babel-loader来编译js文件，css-loader和style-loader来处理css文件。**
3. **配置插件，使用插件来实现项目优化，如UglifyJsPlugin来压缩js文件，html-webpack-plugin来生成html文件。**
4. **配置环境变量，设置不同环境下的不同配置。如开发环境和生产环境的不同配置，如代码调试，source map等。**
5. **配置热更新，使用webpack-dev-server或者webpack-hot-middleware等工具，实现页面自动刷新。**
6. **配置懒加载，使用import()或者require.ensure()函数，实现按需加载，提高页面性能。**
7. **配置其他配置，如别名、路径等。**

2：图片的懒加载和预加载

**图片懒加载是指当用户滚动页面时，页面加载完成之后，才加载可见区域内的图片。为了减少初始加载时的请求数量，提高页面加载速度。**

**预加载是指在页面加载过程中，提前加载一些图片资源。这样可以减少用户等待时间，提高用户体验。**

**1.图片懒加载： 可以在图片标签中使用 "data-src" 或 "data-lazy" 属性来存储真实图片地址，然后在 JavaScript 中监听滚动事件或 IntersectionObserver API 来加载图片。**

```html
<img data-src="image.jpg" alt="example">
```

```js
// JavaScript
var images = document.querySelectorAll('img[data-src]');

function preloadImage(img) {
  var src = img.getAttribute('data-src');
  if (!src) {
    return;
  }
  img.src = src;
}

var observer = new IntersectionObserver(function(entries) {
  entries.forEach(function(entry) {
    if (entry.intersectionRatio > 0) {
      preloadImage(entry.target);
      observer.unobserve(entry.target);
    }
  });
});

images.forEach(function(image) {
  observer.observe(image);
});

```

**2.图片预加载： 可以使用 JavaScript 中的 Image() 对象或者 CSS 中的 "prefetch" 和 "preload" 来实现。**
CSS 实现方式： 可以使用 CSS 中的 "prefetch" 和 "preload" 来预加载图片。 "prefetch" 会在页面加载完成后异步加载， "preload" 会在页面加载过程中加载，这样会导致页面加载的稍微慢一点。

``` CSS
<link rel="prefetch" href="image.jpg">
<link rel="preload" as="image" href="image.jpg">
```

**JavaScript 实现方式： 可以使用 JavaScript 中的 Image() 对象来预加载图片。这个对象用于在 JavaScript 中创建一个图像对象，并可以通过它的 src 属性来指定图片的地址。**

> JavaScript 实现图片预加载的方式主要是通过创建一个 Image() 对象，并通过它的 src 属性指定要预加载的图片地址。当这个对象被创建时，浏览器会自动向指定的地址发起请求，并将图片下载到本地缓存中。
>
> 这个过程是异步的，因此不会影响页面的加载速度，而且一旦图片被下载并缓存到本地，当页面上需要使用这张图片时就可以立即调用，而不用再重新下载。

```js
// 创建一个图像对象
var img = new Image();

// 指定图片地址
img.src = 'image.jpg';

```

3：防抖源码

**防抖 是防止函数在短时间内连续触发多次，只在最后一次触发后的一段时间后才执行。**

```js
//这个函数并不会被多次执行
function debounce(fun, delay) {//fun：需要防抖的函数；delay：防抖的等待时间
    // 定时器变量
    let timer
    //返回一个新函数，这个匿名函数会立即执行，然后清除上一次的定时器，重新设置一个新的定时器
    //其实每次执行的只是这个函数
    return function () {
        if (timer) clearTimeout(timer)
        let args = arguments//将传递给匿名函数的参数分配给名为 "args" 的变量
        timer = setTimeout(() => {fun.apply(this, args)}, delay)//返回值是一个整数值，表示定时器的编号,这个编号可以用来取消对应的定时器。
    }
}
let search = debounce(sendSearchRequest, 500)
input.addEventListener('input', search())
```

**节流 可以限制函数在一段时间内最多只能执行一次。**

```js
function throttle(fun, time) {
    let start = 0
    return function () {
        let now = new Date()
        // 判断当前时间与起始时间之差是否大于设置的阈值
        if (now - start > time) {
            // 执行被节流的函数
            fun.apply(this, arguments)//把当前函数的上下文和arguments传入到被节流的函数中
            // 更新起始时间
            start = now
        }
    }
}
```

4：token的使用

**Token主要用于身份验证和授权。**

**当用户登录系统时，服务器会生成一个 token，并将其返回给前端。前端在与服务器进行交互时，会把这个 token 作为请求头中的一部分发送给服务器。服务器收到请求后，会对 token 进行验证。如果 token 是有效的，则允许请求通过；如果 token 是无效的，则拒绝请求。**

**好处：使用 token 后，用户只需要在登录时进行一次身份验证，之后就可以使用 token 来进行身份验证，这样就可以大大提高系统的效率。另外，token 还可以用来授权。服务器可以根据 token 中的信息来判断用户是否有权限访问某些资源。这样，就可以确保系统的安全性。**

详细过程：

- **首次登录时，后端服务器判断用户账号密码正确之后，根据用户id、用户名、定义好的秘钥、过期时间生成 token ，返回给前端；**
- **前端拿到后端返回的 token ,存储在 localStorage 和 Vuex 里；**
- **前端每次路由跳转，判断 localStorage 有无 token ，没有则跳转到登录页，有则请求获取用户信息，改变登录状态；**
- **每次请求接口，在 Axios 请求头里携带 token;**
- **后端接口判断请求头有无 token，没有或者 token 过期，返回401；**
- **前端得到 401 状态码，重定向到登录页面。**

5：深拷贝实现方法
6：原型链

**JavaScript中的对象都是由一个原型对象构建出来的。原型对象本身也是一个对象，它可以有自己的属性和方法。每个对象都有一个隐式的指针，指向它的原型对象。当我们在一个对象中查找某个属性或方法时，如果对象本身没有，就会继续在它的原型对象中查找，如果原型对象中还没有，就会继续查找它的原型对象的原型对象，直到找到为止，或者到达原型链的末尾，这样就形成了一条链，称为原型链.**

该对象的`_proto_`=构造函数的`prototype`（`_proto_`是每个对象内部属性，指向该对象的原型对象。`prototype`是每个构造函数内部属性，指向该构造函数的原型对象。）

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c631b657ca62427a8bdef1a2c145346a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

7：垂直居中的方法

1. **设置父元素为flex布局，可以使用`display: flex`、`align-items: center`、`justify-content: center`进行居中。**
2. **设置父元素为grid布局，可以使用`display: grid`、`place-items: center`进行居中。**
3. **利用绝对定位和负边距进行居中，可以使用`position: absolute`、`top: 50%`、`left: 50%`、`transform: translate(-50%, -50%)`进行居中。**

**秋招一面**

1. 首先让我自我介绍

2. 然后就问了CSS的盒子模型，box-sizing; position的常见属性；如何画一条0.5px的线[用scale缩放]

   **css盒模型本质是一个盒子，盒子包裹着html内容，包含content padding border margin。**

   **box-sizing属性可以设置盒子模型的计算方式，常见的有content-box（默认值，仅包含content ）和border-box（将padding 和border计入盒子大小）**

   **position的常见属性:**

   - **static（默认值）：元素按照正常文档流排列**
   - **relative：相对于元素的正常位置进行定位**
   - **absolute：相对于最近的已定位（position 属性为 absolute, fixed 或 relative 的元素被称为已定位元素）祖先元素进行定位**
   - **fixed：相对于浏览器窗口进行定位**
   - **sticky:相对于正常文档流排列，但在滚动到元素的时候，它将会固定在视口中。**

   **用transform属性。**

   ```css
   div {
     width: 100px;
     height: 1px;
     background-color: black;
     transform: scaleY(0.5);
   }
   ```

   

3. 问了JS的基本数据结构；数组常用的方法；数组遍历方式；var、let、const的区别；

   **JS数据类型一共有8种**

   - **一类是基本数据类型，包含7种，分别是Number 、String、Boolean、BigInt、Symbol、Null、Undefined。**

   - **另一类是引用数据类型Object，普通对象，数组，正则，日期，Math数学函数都属于Object。**

     

     **数组常用方法**

   - **push()：在数组末尾添加一个或多个元素**

   - **pop()：删除数组末尾的元素**

   - **shift()：删除数组开头的元素**

   - **unshift()：在数组开头添加一个或多个元素**

   - **splice()：在数组中插入或删除元素**

   - **slice()：返回数组的一个片段**

   - **sort()：对数组进行排序**

   - **reverse()：对数组进行反转**

   - **concat()：连接两个或多个数组**

   - **join()：将数组的所有元素连接成一个字符串**

     **数组遍历方式有多种，常用的有：**

     - **for循环：**

     ```js
     for (let i = 0; i < arr.length; i++) {
             console.log(arr[i]);
         }
     ```

     - **forEach()方法：**

     ```js
     arr.forEach(function(item) {
             console.log(item);
         });
     ```

     - **for...of循环**

     ```js
     for (let item of arr) {
             console.log(item);
         }
     ```

     **var、let、const三者都是用来声明变量的关键字，但是它们之间有一些区别。**

     - **var 是ES5中的变量声明方式，没有块级作用域的概念，会变量提升。**
     - **let是ES6中的变量声明方式，有块级作用域的概念，不会变量提升，不能重复声明。**
     - **const 也是ES6中的变量声明方式，有块级作用域的概念**

4. 问了vue的组件传值方式；vue路由传参的方式及区别；vue的computed、watch的区别，computed是不是非要return一个值；又问了vuex（我之前学过这个，还做了todoList的demo，后来没用到，就忘记了。从面试角度说也要再复习下的）

   computed应该返回一个值，如果不返回一个值，那么这个 computed 属性就没有任何意义了。

   **Vuex是集中存储管理所有组件的状态。属性分别由state、getters、mutations、actions、module。** 

   **（1）state用来定义所要存储的数据，通过$store.state调用数据** 

   **（2）getters可以认为是store的计算属性，通过$store.getters调用属性** 

   **（3）mutations用来存放改变state数据的同步方法，每个方法接收的参数都是state，用$store.commit来调用mutations中的同步方法** 

   **（4）actions用来存放异步方法，接收的参数是context（mutations中的方法），通过$store.dispatch调用actions中的方法 （5）module将store分割成模块，每个模块有自己的state、getters、mutations、actions、甚至嵌套子模块，从上至下进行同步分割 前四个属性除了用$store的方法调用，还能通过import { mapState/mapGetters/... } from 'vuex'引入，再用...mapState/mapGetter/...(['属性/方法名'])的形式映射进来调用**

5. 编程题：判断回文数————时间不够就说了思路

6. 反问阶段：
   - 我觉得海康是做硬件的吧，不知道前端这块能做什么？————主要是给官方机构做一些软件
   - 技术栈是啥咧————目前主要是用vue2，慢慢转向vue3了
   - 意见建议————基础挺好的，再掌握下vue的技术细节
   - 多长时间能有反馈————这个得看人事那边！

**海康威视-前端一面**
全程大概25min
1.自我介绍
2.围绕项目询问
3.vue的响应式原理

**Vue 2 的响应式系统是基于 Object.defineProperty() 方法来实现的，在初始化组件时会遍历 data 对象中的所有属性并使用 Object.defineProperty() 方法将它们转换为 getter/setter。这样，当 data 对象中的某个属性被访问或修改时，Vue 就能感知到这个变化并作出相应的更新。**

> Object.defineProperty() 方法是 JavaScript 中一种用来定义对象属性的方法，它可以通过定义 getter 和 setter 方法来控制对象属性的读写。

**Vue3 的响应式系统是基于 Proxy 对象来实现的，在初始化组件时会使用 Proxy 对象包装 data 对象。这样，当 data 对象中的某个属性被访问或修改时，Vue 就能感知到这个变化并作出相应的更新。**

**Vue 2 的响应式系统相对于 Vue 3 的响应式系统有以下不足：**

1. **性能问题：Vue 2 使用 Object.defineProperty() 方法来实现响应式，这种方式在性能上相对较差，特别是在处理大量数据时。**
2. **不支持新类型： Vue 2 只能对 Object 类型的数据进行响应式，而不能对 Map、Set、WeakMap、WeakSet 等类型进行响应式。**
3. **不能检测数组的变化：Vue 2 对数组的响应式是通过重写数组的常用方法来实现的，并不能直接检测到数组的变化。**
4. **无法检测新增属性的变化：Vue 2 只能在初始化时检测到数据的变化，如果在运行时新增了属性，Vue 2 是无法检测到这种变化的。**

**这些不足，在Vue3中基本都得到了改进。**

4.说一下flex布局

**Flex 布局是一种弹性布局方式，可以让元素在一条线上进行排列。它可以让元素的大小和位置随着容器的变化而变化。由两个部分组成：容器（container）和项目（items）。**

**flex 容器（flex 子元素的父元素）属性：flex-direction（row、row-reverse、column、column-reverse），justify-content，align-items，flex-wrap**

**flex 子元素属性：flex-shrink（flex-shrink: 0可以防止元素的高度被挤压），flex-grow，flex-basis，order，align-self**

5.js事件循环

https://www.bilibili.com/video/BV113411J7Pm/?spm_id_from=333.337.search-card.all.click&vd_source=a82467014333a92108701778c031bbb7

**js是单线程的，主线程在执行时会不断循环往复的从同步任务队列中读取任务，执行任务，当同步任务队列全部执行完毕后再从异步任务队列中依次执行。**

**异步任务分为宏任务和微任务。在同步任务执行完毕后，会先执行所有在此期间入队的微任务，再执行异步任务队列中的宏任务。**

**宏任务有：scrip(JS 整体代码)、setTimeout、setInterval、setImmediate、I/O、UI 交互**

**微任务有：Promise(重点关注)、process.nextTick(Node.js)、MutaionObserver**

**6.自己在前端方面还有什么不足**

**海康威视前端面经**

正常人都是两面，一面技术面一面hr面，只有前两面都是优秀评级才会有三面sp面。
一面面试官是女的，感觉人超好，问的都挺简单的。先问我觉得哪方面最擅长我回答的js，然后问了下js的问题。
问题都很简单，所以记不太清了，大概有这些:

js的数据类型，

js数组增删改查的方法，

原型链，

设计模式(这个我回答了几个模式，让我详细说了下单例模式，单例的实际应用，工厂模式，装饰器模式)，

**设计模式是软件工程中针对常见问题所提出的解决方案。常见的设计模式包括：**

- **单例模式：保证一个类只有一个实例，并提供一个全局访问点。**

  **在前端开发中，单例模式的实际应用主要包括以下几类:**

  1. **管理全局状态: 如管理用户登录状态、应用配置等。**

  2. **单例服务: 如网络请求服务、数据缓存服务等。**

  3. **全局事件管理: 如管理应用内部的事件、组件间的通信等。**

  4. **全局对象管理: 如管理页面中的DOM元素、组件实例等。**

  5. **全局函数库: 如封装公用的工具函数、格式化函数等。**

     **具体实现可以通过 JavaScript 中的静态类和闭包来实现单例模式。**

- **工厂模式：是一种创建型模式，其目的是将对象的创建过程和使用过程分开，通过工厂类来统一管理对象的创建。工厂模式包含两个部分，即工厂类和产品类。通过工厂类来统一管理产品类的创建。**

  **在前端开发中，工厂模式的实际应用主要包括以下几类:**

  1. **组件生成: 根据不同的参数或配置，生成不同的组件实例。**
  2. **数据处理: 根据不同的数据类型或格式，使用不同的处理方式。**
  3. **事件处理: 根据不同的事件类型或条件，使用不同的处理方式。**
  4. **请求生成: 根据不同的请求类型或参数，生成不同的请求实例。**
  5. **其它: 比如生成不同的图表、生成不同的页面布局等。**

  **具体实现可以通过 JavaScript 中的函数来实现工厂模式, 也可以通过类来实现。**

- **抽象工厂模式：抽象工厂模式是工厂模式的升级版，它更加灵活，提供一种创建相关或依赖对象的方式，而不需要指定具体类。**

  **举个例子，设计一个工厂模式来生产不同类型的人，比如中国人、美国人、英国人。**

  - **抽象工厂：PeopleFactory**
  - **具体工厂：ChinaFactory、USAFactory、UKFactory**

**在前端开发中，工厂模式的实际应用：在一个应用中有很多类似的组件，但是这些组件在某些方面有所不同。例如，一个组件可能需要在不同的环境中使用不同的图标或字体。抽象工厂模式可以帮助我们创建不同版本的组件，而不用重复编写代码。**
- **策略模式：定义一系列算法，并将它们封装起来，使它们可以互相替换。**

- **观察者模式：观察者模式是一种行为型设计模式，它允许一个对象（称为被观察者）维护一组依赖于它的对象（称为观察者），并在它的状态更改时通知所有观察者。**

  **在前端开发中，可以使用观察者模式来实现事件驱动程序，比如说当用户输入一个搜索关键词时，更新搜索结果列表。**

- **状态模式：是一种软件设计模式，允许对象在内部状态改变时改变它的行为。**

  **在前端开发中，状态模式可以用来管理组件的不同状态，例如按钮点击后的状态、输入框输入内容时的状态等。**

- **责任链模式：是一种设计模式，其中对象在一条链上传递请求，直到有一个对象处理它为止。**

- **装饰器模式：动态地给对象添加职责。**

  **装饰器模式是一种结构型设计模式，其主要目的是在不改变原有对象的情况下，通过对其进行包装来扩展或修改其功能。**

  **具体实现方式可以通过创建一个装饰器类，该类接收一个对象作为参数，并在其基础上添加新的功能。**

  **比如说在前端开发中，我们可以使用装饰器来给一个组件增加额外的属性或方法**

- **代理模式：是一种结构型设计模式，其主要目的是在不暴露实际对象的情况下，通过代理对象来控制对实际对象的访问。**

  **在前端开发中，可以使用代理模式来对请求进行拦截、缓存和验证，比如说使用代理对象来缓存 API 请求结果，减少对服务器的压力**

- 外观模式：为复杂的子系统提供一个统一的接口。

- 模板方法模式：定义一个操作中的算法骨架，而将一些步骤延迟到子类中。

- 迭代器模式：提供一种方法来访问聚合对象中各个元素，而又不暴露其内部表示。

- 访问者模式：在不改变集合元素的前提下定义作用于这些元素的操作。

- 解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。

vue组件通信，

nodejs作用，

**Node.js是一个JavaScript运行环境，可以在服务器端运行JavaScript代码。它使用Google V8引擎运行JS，并提供了一组丰富的API来访问文件系统、网络和其他系统资源。Node.js具有高性能、轻量级、事件驱动等特点，广泛应用于Web服务器、网络爬虫、实时应用程序等领域。**

css实现左定宽右响应有几种。

1. **使用浮动布局：左边元素使用 float:left，右边元素使用 margin-left 实现距离左边元素的距离。**
2. **使用绝对定位：左边元素使用 position: absolute 和 left: 0，右边元素使用 position: absolute 和 right: 0 实现左右元素的位置。**
3. **使用 flex 布局：左边元素设置 flex: 0 0 固定宽度，右边元素设置 flex: 1 1 auto 实现自适应。**
4. **使用 grid布局：左边元素设置grid-column:1 / 2; 右边元素设置grid-column: 2 / 3;**
5. **使用calc()函数：左边元素设置 width:固定值px;右边元素设置width:calc(100% - 固定值px);**

### 绿盟

**10.12 一面**
记忆深刻的实习过程中遇到的问题，采用什么排查方式把它解决
实习过程写了一个模块，可能会有一些bug,在改bug的时候应该注意什么问题

1. 明确问题：在修复bug时，首先需要明确问题的类型和位置，清楚的知道需要修改的部分。
2. 测试：在修改代码后，需要进行测试，确保修改后代码能够正常运行，并且不会影响其他模块。
3. 注释：在修改代码时，应该注释清楚修改的地方和原因，方便以后查看和维护。
4. 回滚：在修改代码时，如果发现问题更加复杂，或者修改后导致其他问题，应该做好备份，有回滚代码的准备。
5. 总结：在修改bug时，总结经验，并防止同样的问题再次出现。

**登录逻辑去判断有没有登录，登录鉴权**

**前端判断用户是否已登录的方法有以下几种：**

1. **在用户登录时，在本地存储（如local storage或cookie）中存储登录状态（例如布尔值），在后续页面加载时检查该存储的值。**
2. **通过向服务器发送API请求，以检查服务器端是否存在有效的用户会话。**

**前端鉴权主要通过以下几个步骤实现：**

1. **获取用户身份信息：首先，前端需要从后端获取用户身份信息，并将其存储到前端的本地存储中。**
2. **定义路由权限：前端需要定义每个路由的权限，以确保用户具有某些特定的权限才能访问某些页面。**
3. **路由拦截：在每次用户访问页面时，前端需要进行路由拦截，并对用户的权限进行校验。**
4. **访问限制：如果用户不具有访问该页面的权限，则前端需要对该请求进行限制，例如跳转到登录页面或提示错误信息。**

**登录逻辑如下：**

1. **输入用户名和密码：用户需要在前端的登录界面输入用户名和密码。**
2. **校验用户输入：前端需要对用户输入的信息进行校验，确保用户名和密码符合要求，如长度、格式等。**
3. **发送请求到后端：前端需要通过 HTTP 请求，将用户名和密码发送到后端。**
4. **后端验证：后端需要将用户名和密码与数据库中的用户信息进行比对，验证该用户是否存在，并确保用户名和密码是正确的。**
5. **返回验证结果：后端需要将验证结果返回给前端。**
6. **前端接收结果：前端需要接收后端返回的结果，并进行处理，如成功则跳转到下一个页面，失败则显示错误信息。**

浏览器本地存储方式，区别

一般有Cookie、Local Storage和Session Storage这三种

1. Cookie：Cookie 是最早的本地存储方式，它存储的内容将在请求时发送到服务器，因此它是可以跨域请求的。但是，Cookie 只能存储 4KB 的数据，并且不能存储结构化数据，只能存储字符串数据。
2. LocalStorage：LocalStorage 是 HTML5 中新出现的本地存储方式，它可以存储 5MB 的数据，并且可以存储结构化数据，而且存储的内容在不同的页面中共享。
3. SessionStorage：SessionStorage 和 LocalStorage 的实现方式类似，但是它存储的数据只存在于一个浏览器窗口中，当用户关闭该浏览器窗口时，SessionStorage 中的数据会被清除。

共同点：
1.都是浏览器存储
2.都存储在浏览器本地 
区别：
1.cookie由服务器写入， sessionStorage以及localStorage都是由前端写入 
2.cookie的生命周期由服务器端写入时就设置好的，localStorage是写入就一直存在，除非手动清除，sessionStorage是由页面关闭时自动清除 
3.cookie存储空间大小约4kb， sessionStorage及localStorage空间比较大，大约5M 
4.三者的数据共享都遵循同源原则，sessionStorage还限制必须是同一个页面

> 什么是同源
> 在了解跨域这个概念之前首先要知道的是何为同源策略。所谓的同源是一种安全机制，为了预防某些恶意行为（例如 Cookie 窃取等），浏览器限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。而满足同源要具备三方面：协议相同、域名相同、端口相同。

5.前端给后端发送请求时，自动携带cookie, session 及 local都不携带 

6.cookie一般存储登录验证信息或者token，localStorage常用于存储不易变动的数据，减轻服务器压力，sessionStorage可以用来监测用户是否是刷新进入页面，如音乐播放器恢复进度条功能

浏览器缓存
F5刷新机制，ctrl+F5和F5刷新区别
js数据类型，区别，判断数据类型的方式

**JS数据类型一共有8种**

- **一类是基本数据类型，包含7种，分别是Number 、String、Boolean、BigInt、Symbol、Null、Undefined。**

- **另一类是引用数据类型Object，普通对象，数组，正则，日期，Math数学函数都属于Object。**

es6的一些语法
箭头函数与普通函数区别
深浅拷贝区别，实现
react和vue区别
vue中v-model如何实现
常用git命令
实习和在学校做项目有什么区别
反问 



**一面（30min）**

原型链，Object.prototype在浏览器中输出什么

useState同步异步问题

受控组件和非受控组件，各自缺陷

常用的hooks

函数组件和类式组件不同，偏向

垂直水平居中，说了6种好像？

然后其他的印象不深，过了两三个周了

反问主要是介绍业务和讨论前端安全相关（XSS,CSRF,中间人攻击那些）

**二面（30min****）**

介绍项目

项目最难点，怎么解决

个人优势，最怕这个，听到就胃疼

React框架特点（从虚拟DOM开始一路讲到了Redux的单向数据流）

hooks生命周期

函数式编程

**绿盟秋招前端一面：**

面试小哥非常nice，算是我秋招第一次面试，紧张到可视化库echarts名字都忘了，面试小哥哥还给我提醒，遇到不会的问题也会引导我，不管过没过，这个公司给我的面试体验是非常好的！

1、自我介绍；

2、项目职责、输出；

3、Vue2.0、3.0区别；

4、Vue2双向绑定实现原理；

5、Object.defineProperty()缺陷，为什么Vue 3.0使用Proxy；

6、Vue data为什么通过函数返回对象形式进行赋值；

7、多个组件想使用一个组件内部的生命周期的一些数据，要怎么实现；

8、Vue中computed与watch；

9、Vuex数据流；

10、JS原型和原型链；

11、变量提升var let const，var属于赋值提升还是声明提升；

12、事件委托、事件冒泡；

13、节点事件的整个过程是怎样的；

14、说一下TS；

15、css父元素中子元素水平垂直居中说出三种方式，不知道元素大小时怎么处理；

16、css动画，让一个元素无限旋转要如何设置，需要设置什么属性；

17、可视化库；

18、为什么选择前端，前端工作有什么目标，未来规划；

19、对我们公司有什么问题；

**绿盟前端一面二面**

一面

1.为什么选择vue，vue和其他各有什么好处
2.h5特性
3.web worker
4.js的阻塞问题
5.url输入到页面显示
6.缓存
7.cookie和session区别
8.缓存存在哪里/磁盘
9.重排和重绘
10.如何减少重排重绘
11.去重方式
12.filter和includes源码
13.diff算法

二面

1.实习难点

2.url输入之后的网络过程

3.用到的协议

4.闭包

**绿盟前端一面**

- 实习做了什么项目
- 实习收获
- 项目从需求调研到上线流程
- ES6和TS的区别
- ​    vue2与vue3的区别    
- ​    vue2、vue3响应式    
- ​    垃圾回收    
- ​    var let    
- ​    普通函数和箭头函数作用域的区别    
- ​    有一个很大的数组怎么找到前十个数字（时间复杂度要比O(n2)小）   

### 字节

**前端实习一面**

自我介绍

实习相关问题:

服务治理的概念

微前端和传统b端项目的区别

微前端的优点

qiankun框架实现的原理

下面是八股时间

string为什么有length属性

js单线程怎么实现的异步

css手写麻将的五条

flex-grow默认是左右撑开剩余空间，怎么使用flex- grow上下撑开空间

手写sleep方法

嘴撕vue响应式原理源码

算法给定一个数组找到重复元素想加和的最大值

udp为什么比tcp快

拥塞控制

门限的值跟什么有关

### 蔚来

**蔚来前端日常实习面经**

1. 自我介绍和项目介绍

2. 什么是跨域？

3. 解决跨域的方法有哪些？

4. CORS 的原理

5. JSONP 的原理

6. JSONP 的回调函数在命名的时候有什么讲究？为什么？

7. 如何判断一个变量是否为字符串？

8. `tpyeof`、`instanceof` 和 `toString` 的区别？

9. 算法题：[二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

10. JWT 的原理

11. JWT 和 Cookie 的对比

12. bcrypt 有什么作用？

13. 输出题

    ```
    console.log(name);
    const name = 'zhangsan';
    ```

14. 输出题

    ```
    const p1 = { name: 'zhangsan' };
    const p2 = { name: 'lisi' };
    const obj = {};
    obj[p1] = 'xxx';
    obj[p2] = 'yyy';
    console.log(obj[p1]);
    ```

15. 反问

### 恒生

**恒生前端暑期实习面经**

1. 自我介绍和项目介绍
2. 除了懒加载，还有哪些图片性能优化方式？
3. 精灵图的优缺点？
4. 字体图标的优缺点？
5. 字体图标可以实现任意图形吗？
6. 说一下对Promise的理解
7. 为什么Promise的状态一旦变化就无法改变？
8. 有什么办法可以让老版本的浏览器可以跑ES6语法？
9. 说一下Babel的原理
10. Babel可以解析所有的新语法吗？
11. TCP和UDP的区别？
12. 说一下对HTTP的理解
13. 说一下HTTP的缓存机制
14. 反问

### 奇安信

奇安信前端春招面经（一面挂）
一面：

自我介绍和项目介绍
代码题：

```js
const input = [
 {
     value: 110000,
     label: '北京市',
     parent: null,
     children: [
         110001,
         110002
     ]
 },
 {
     value: 110001,
     label: '东城区',
     parent: 110000,
     children: []
 },
 {
     value: 110002,
     label: '西城区',
     parent: 110000,
     children: []
 },
 {
     value: 130000,
     label: '河北省',
     parent: null,
     children: [
         130100
     ]
 },
 {
     value: 130100,
     label: '石家庄市',
     parent: 130000,
     children: [
         130102,
         130104
     ]
 },
 {
     value: 130102,
     label: '长安区',
     parent: 130100,
     children: []
 },
 {
     value: 130104,
     label: '桥西区',
     parent: 130100,
     children: []
 },
];
const output = [
 {
     value: 110000,
     label: '北京市',
     parent: null,
     children: [
         {
             value: 110001,
             label: '东城区',
             parent: 110000,
             children: []
         },
         {
             value: 110002,
             label: '西城区',
             parent: 110000,
             children: []
         }
     ]
 },
 {
     value: 130000,
     label: '河北省',
     parent: null,
     children: [
         {
             value: 130100,
             label: '石家庄市',
             parent: 130000,
             children: [
                 {
                     value: 130102,
                     label: '长安区',
                     parent: 130100,
                     children: []
                 },
                 {
                     value: 130104,
                     label: '桥西区',
                     parent: 130100,
                     children: []
                 }
             ]
         },
     ]
 },
];
```

map和forEach的区别？
说一下对事件循环的理解
异步流程控制的方法有哪些？
Promise有哪些状态？是否可变？
Map和Set的区别？
箭头函数和普通函数的区别？
防抖和节流的区别？
实现一个节流函数
Position有哪些属性？定位原则分别是什么？
浏览器本地存储方式有哪些？
localStorage和sessionStorage的区别？
刷新后sessionStorage还存在吗？
说一下对跨域的理解？
进程和线程的区别？
链表和数组的区别？适用场景分别有哪些？
说说对LRU算法的理解
Vue组件间的通信方式有哪些？
Vue的data选项为什么是一个函数？
说一下对虚拟DOM的理解
说一下对Webpack的理解
loader和plugin的区别？
说说对ECharts的理解
JWT和Cookie-Session的区别？
未来的职业规划
反问

### 平安

平安前端日常实习面经

1. 自我介绍和项目介绍

2. 说一下Vue的生命周期，每个钩子背后会发生什么？

3. 虚拟DOM和真实DOM如何交互？

4. Vue父子组件之间如何传值？

5. 说以下JS对象的内存模型

6. `new` 一个对象之后发生了什么？属性和对象在哪一步被确定？

7. `this`指向有哪几种情况？

8. Webpack的打包流程？

9. Webpack打包编译的过程中碰到过什么问题？

10. 如何配置代理以支持跨域？

11. 介绍一下JWT

12. Cookie和Session的区别？

13. GET和POST的区别？

14. POST请求的详细流程？

15. 算法题：一次高考，有3000万考生，已知1000万个考生的成绩，想知道他们分别是第几名，应该怎么做？

16. 为什么会学习前端？

17. 会用TensorFlow吗？

18. 了解量化模型吗？

19. Vue组件懒加载的原理？

20. 说一下对WebWorker理解和使用场景

21. 说一下浏览器的线程模型

22. 为什么说JS是一门单线程语言？

23. 反问

    

### 货拉拉

货拉拉前端日常实习面经

一面：

1. 自我介绍和项目介绍
2. 精灵图的原理？
3. 精灵图有哪些优缺点？
4. HTTP/2.0有哪些新特性？
5. 头部压缩用的什么算法？
6. HPACK算法的原理？
7. 多路复用解决了什么问题？
8. 说一下强缓存和协商缓存
9. 说说对打包工具的理解
10. loader和plugin的区别？
11. 组件延迟加载的原理？
12. ESM和CommonJS的区别？
13. Vue组件通信的方式有哪些？
14. 兄弟组件之间如何通信？
15. Vue3和Vue2的区别？
16. 哪些情况下Vue2的无法检测数据变化？如何解决？
17. 生命周期钩子有哪些？
18. 哪些钩子中可以获取到DOM节点？
19. nextTick有哪些使用场景？
20. 计算属性和侦听器的区别？
21. JS的数据类型有哪些？
22. 判断数据类型的方法有哪些？
23. 浅拷贝和深拷贝的区别？
24. 实现深拷贝
25. 说说对this的理解
26. 什么是原型链？
27. 原型链的终点是什么？（null）
28. 什么是外边距塌陷？如何解决？
29. BFC还有哪些功能？
30. 算法题：[有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)
31. 算法题：[两数之和](https://leetcode-cn.com/problems/two-sum/)
32. 反问

二面：

1. 自我介绍和项目介绍
2. 为什么想做前端？
3. 说一下职业规划
4. 说一下Vue生命周期，每个步骤发生了什么，越详细越好
5. Vue组件通信的方式有哪些？
6. 在实际项目中，组件通信有哪些注意点？
7. 计算属性和侦听器的区别？
8. v-if和v-for的优先级？为什么不建议在同一元素上使用？
9. 说一下事件循环
10. Vue源码中有哪些用到了事件循环的地方？
11. 智力题：有一个7升的杯子和一个4升的杯子，如何盛出5升水？
12. 算法题：[二分查找](https://leetcode-cn.com/problems/binary-search/)
13. 反问
### 0.项目



### 1.说一说html语义化

1.提高了代码的可读性 有利于阅读和团队代码管理

2.有利于SEO（搜索引擎优化）：爬虫是依赖标签来确定关键字权重的，可帮助爬虫抓去更多有效信息

3.优化代码结构：使页面在没有css的情况下也能呈现很好的内容结构

### 2.说一说盒模型

css盒模型本质是一个盒子，盒子包裹着html内容，包含content padding border margin。

有两种盒模型：W3C标准盒模型和IE怪异盒模型。标准盒模型的width/height不包含padding和border。怪异盒模型的width/height包含padding和border。

默认使用标准盒模型，也可以通过控制box-sizing属性决定盒模型：border-box代表怪异盒模型、content-box代表标准盒模型

### 3.说一说浮动

浮动的定义：
使元素脱离文档流，按照指定的方向（左或右发生移动），直到它的外边缘碰到包含框或另一个浮动框的边框为止。
浮动的效果：
文本环绕
块级元素横排显示
内联元素设置宽
浮动元素脱离文档流，可能造成父元素高度塌陷的问题，如何解决？
1.给父级添加高度 
2.给父级添加overflow：hidden （开启bfc）
3.在父元素的最后创建一个空白div,添加clear：both 属性（对其进行清除浮动，这样可以通过这个空白的div来撑开父元素的高度）
4.添加一个after伪类 

```css
.clearfix:after{
/*添加一个内容*/
content: "";
/*转换为一个块元素*/
display: block;
/*清除两侧的浮动*/
clear: both;
}
```



```
什么是高度塌陷？什么是高度塌陷？什么是高度塌陷？
* 在文档流中，父元素的高度默认是被子元素撑开的，
* 也就是子元素多高，父元素就多高。
* 但是当为子元素设置浮动以后，子元素会完全脱离文档流，
* 此时将会导致子元素无法撑起父元素的高度，导致父元素的高度塌陷。
* 由于父元素的高度塌陷了，则父元素下的所有元素都会向上移动，这样将会导致页面布局混乱。
* 所以在开发中一定要避免出现高度塌陷的问题,
* 我们可以将父元素的高度写死，以避免塌陷的问题出现，
* 但是一旦高度写死，父元素的高度将不能自动适应子元素的高度，所以这种方案是不推荐使用的。
```



### 4.说一说JS数据类型有哪些,区别是什么？

> - `JavaScript` 属于 **动态语言**(在运行过程中确认数据类型)，**弱类型语言**（支持隐式类型转换）。

JS数据类型一共有8种
分为两类：
一类是基本数据类型，包含7种，分别是Number 、String、Boolean、BigInt、Symbol、Null、Undefined。
另一类是引用数据类型Object，普通对象，数组，正则，日期，Math数学函数都属于Object。

> 什么是值类型和引用类型？
>
> **基本的值类型有:** `undefined`，`Boolean`，`Number`，`String`，`Symbol`。
>
> **引用类型有：** `Object`。
>
> **特殊的引用类型：**`null`，指针指向空地址。
>
> **特殊的引用类型：**`function`，不用于储存数据，所以没有复制，拷贝函数一说。
>
> **区别：**
>
> 1.存储位置
>
> 值类型的变量会保存在 **栈内存** 中，如果在一个函数中声明一个值类型的变量，那么这个变量当函数执行结束之后会 **自动销毁**。
>
> 引用类型的变量名会保存在 **栈内存** 中，但是变量值会存储在 **堆内存** 中，引用类型的变量不会自动销毁，当没有引用变量引用它时，系统的 **垃圾回收机制** 会回收它。
>
> 2.赋值方式
>
> 值类型的变量直接赋值就是深赋值，修改 `b` 的值不会影响 `a`。
>
> 引用类型的变量直接赋值实际上是传递引用，只是浅赋值,修改值会影响所有引用该地址的变量。
>
> 3.添加属性和方法
>
> 值类型无法添加属性和方法。
>
> 引用类型可以添加属性和方法。

数据分成两大类的本质区别：在内存中的存储方式不同。 基本数据类型是直接存储在栈中的简单数据段，占据空间小，属于被频繁使用的数据。 引用数据类型是存储在堆内存中，占据空间大。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址，当解释器寻找引用值时，会检索其在栈中的地址，取得地址后从堆中获得实体。

Symbol是ES6新出的一种数据类型，这种数据类型的特点就是没有重复的数据，由于Symbol()创建数据具有唯一性，需要使用Object.getOwnPropertySymbols(obj)获得这个obj对象中key类型是Symbol的key值。 
BigInt也是ES6新出的一种数据类型，这种数据类型的特点就是数据涵盖的范围大，能够解决超出普通数据类型范围报错的问题。

> 什么是虚值和真值？分别有哪些？
>
> 简单的来说 **虚值** 就是 **在转换为布尔值时** 变为 **false** 的值，变为 **true** 的值则为 **真值** 。
>
> 如何检查值是否虚值？使用 **Boolean 函数**或者 **!!** 运算符。
>
> 虚值(`Falsy`)
>
> - 长度为 **0** 的字符串
> - 数字 **0**
> - `false`
> - `undefined`
> - `null`
> - `NaN`
>
> 真值(`Truthy`)
>
> - 空数组
> - 空对象
> - 其他



### 5.说一说你对闭包的理解？

闭包是指有权访问另一个函数作用域中的变量的函数。

闭包形成的原理：作用域链，当前作用域可以访问上级作用域中的变量
闭包中变量存储的位置：闭包中的变量存储的位置是堆内存。假如闭包中的变量存储在栈内存中，那么栈的回收 会把处于栈顶的变量自动回收。所以闭包中的变量如果处于栈中那么变量被销毁后，闭包中的变量就没有了。所以闭包引用的变量是出于堆内存中的。
闭包解决的问题：能够让函数作用域中的变量在函数执行结束之后不被销毁，同时也能在函数外部可以访问函数内部的局部变量。 
闭包带来的问题：由于垃圾回收器不会将闭包中变量销毁，于是就造成了内存泄露 
闭包的应用，能够模仿块级作用域，能够实现柯里化，在构造函数中定义特权方法、Vue中数据响应式Observer中使用闭包等。

>柯里化：把 接受多个参数 的函数变换成 接受单一参数 的函数
>
>function unCurried(x, y) {
>  return x + y;
>}
>
>function curried(x) {
>  return function(y) {
>    return x + y;
>  }
>}
>
>curried(1)(2)

### 6.说一说promise是什么与使用方法？

1.promise是异步编程的一种解决方案，解决了回调地狱的问题，让代码看起来更加优雅。就像一个容器，保存着某个未来才会结束的事件的结果。

2.promise存在三种状态pending，fulfilled，rejected。 Promise通过new Promise()将构造函数实例化，使用new构建一个Promise，Promise的构造函数接收一个函数作为参数，并且传入两个参数，resolve 和 reject，分别表示异步操作执行成功和失败后的回调函数。promise的实例对象可以通过.then()查看成功消息，.catch()查看失败消息。then和catch最后也是返回promise对象，所以可以链式调用。

3.Promise.all()：返回一个新的promise对象，该promise对象在参数对象里所有的promise对象都成功的时候才会触发成功， Promise.any()：接收一个Promise对象的集合，当其中的一个 promise 成功，就返回那个成功的promise的值。
Promise.race()：当参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象。

### 7.说一说跨域是什么？如何解决跨域问题？

跨域就是违反了浏览器的同源策略造成的，当前页面中的某个接口请求的地址和当前页面的地址如果协议、域名、端口其中有一项不同，就说该接口跨域了。比如web 端地址为 localhost:8000 服务端地址为 localhost:8080,就跨域了

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/1717441c9498fb98~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)

> 同源策略（同域名、同端口、同协议）
>
> 补充：在默认情况下 http 可以省略端口 80， https 省略 443。

跨域的解决方案：https://juejin.cn/post/7075261878997352462

**1.JSONP （全称 JSON with Padding）**

由于同源策略的限制，浏览器只允许请求当前源（域名、协议、端口）的资源，而 HTML 的 script 元素是一个例外。利用script 的 src属性加载资源时不受同源策略的影响的这一特性，并且script会将引用的外部文件的文本内容当做js代码来进行解析

**2.后端可以设置CORS允许跨域实现；**

虽然浏览器出于安全考虑做了“跨域”访问的限制，但开发时不可避免会有这样不同源资源访问的需求，因此 W3C 就制定了 CORS( 跨域资源共享) 的机制。`CORS`需要浏览器和服务器同时支持，整个 `CORS`通信过程，都是浏览器自动完成不需要用户参与，对于开发者来说，`CORS`的代码和正常的 `ajax` 没有什么差别，浏览器一旦发现跨域请求，就会添加一些附加的头信息，

服务器需要在 Response Header 上添加 Access-Control-xxx-yyy 的字段，浏览器识别到了，才能放行该请求。比如，最常见的就是加 Access-Control-Allow-Origin 这个返回头，值设置为需要放行的域名。

在 CORS 中会有 `简单请求` 和 `复杂请求`的概念。

> 凡是同时满足以下两种情况的就是简单请求，反之则非简单请求，浏览器对这两种请求的处理不一样
>
> - 请求方法是以下方三种方法之一
>   - HEAD
>   - GET
>   - POST
> - HTTP的头信息不超出以下几种字段
>   - Accept
>   - Accept-Language
>   - Content-Language
>   - Last-Event-ID
>   - Content-Type：只限于三个值 `application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`

对于简单请求来说，浏览器之间发送`CORS`请求，具体来说就是在头信息中，增加一个`origin`字段，来看一下例子

```http
GET /cors? HTTP/1.1
Host: localhost:2333
Connection: keep-alive
Origin: http://localhost:2332
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36
```

上面的头信息中，`Origin`字段用来说名本次请求来自哪个源,服务器根据这个值,决定是否同意这次请求。

如果`Origin`指定的源不在允许范围之内,服务器就会返回一个正常的`HTTP`回应,然后浏览器发现头信息中没有包含`Access-Control-Allow-Origin` 字段,就知道出错啦,然后抛出错误,反之则会出现这个字段(实例如下)

```js
Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Credentials: true
Access-Control-Expose-Headers: FooBar
Content-Type: text/html; charset=utf-8
```

- Access-Control-Allow-Origin 这个字段是必须的,表示接受那些域名的请求(*为所有)
- Access-Control-Allow-Credentials 该字段可选, 表示是否可以发送cookie
- Access-Control-Expose-Headers 该字段可选,`XHMHttpRequest`对象的方法只能够拿到六种字段: `Cache-Control`、`Content-Language`、`Content-Type`、`Expires`、`Last-Modified`、`Pragma` ,如果想拿到其他的需要使用该字段指定。

如果你想要连带`Cookie`一起发送,是需要服务端和客户端配合的

```js
// 服务端
Access-Control-Allow-Credentials: true
// 客户端
var xhr = new XMLHttpRequest();
xhr.withCredentials = true;
// 但是如果省略withCredentials属性的设置,有的浏览器还是会发送cookie的
xhr.withCredentials = false;
```

非简单请求则是不满足上边的两种情况之一,比如请求的方式为 `PUT`,或者请求头包含其他的字段
非简单请求的`CORS`请求是会在正式通信之前进行一次预检请求.浏览器先询问服务器,当前网页所在的域名是否可以请求您的服务器,以及可以使用那些`HTTP`动词和头信息,只有得到正确的答复,才会进行正式的请求

```js
// 前端代码
var url = 'http://localhost:2333/cors';
var xhr = new XMLHttpRequest();
xhr.open('PUT', url, true);
xhr.setRequestHeader('X-Custom-Header', 'value');
xhr.send();
```

由于上面的代码使用的是` PUT` 方法,并且发送了一个自定义头信息.所以是一个非简单请求,当浏览器发现这是一个非简单请求的时候,会自动发出预检请求,看看服务器可不可以接收这种请求,下面是`"预检"`的 `HTTP` 头信息

```http
OPTIONS /cors HTTP/1.1
Origin: localhost:2333
Access-Control-Request-Method: PUT // 表示使用的什么HTTP请求方法
Access-Control-Request-Headers: X-Custom-Header // 表示浏览器发送的自定义字段
Host: localhost:2332
Accept-Language: zh-CN,zh;q=0.9
Connection: keep-alive
User-Agent: Mozilla/5.0...
```

`"预检"`使用的请求方法是 `OPTIONS` , 表示这个请求使用来询问的,

预检请求后的回应，服务器收到`"预检"`请求以后，检查了`Origin`、`Access-Control-Request-Method`和`Access-Control-Request-Headers`字段以后，确认允许跨源请求，就可以做出回应。

预检的响应头:

```http
HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:15:39 GMT
Server: Apache/2.0.61 (Unix)
Access-Control-Allow-Origin: http://localhost:2332 // 表示http://localhost:2332可以访问数据
Access-Control-Allow-Methods: GET, POST, PUT      
Access-Control-Allow-Headers: X-Custom-Header    
Content-Type: text/html; charset=utf-8
Content-Encoding: gzip
Content-Length: 0
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Content-Type: text/plain
```

如果浏览器否定了`"预检"`请求,会返回一个正常的`HTTP`回应,但是没有任何`CORS`的头相关信息,这是浏览器就认定,服务器不允许此次访问,从而抛出错误

预检之后的请求
当预检请求通过之后发出正经的`HTTP`请求,还有一个就是一旦通过了预检请求就会,请求的时候就会跟简单请求,会有一个`Origin`头信息字段。

通过预检之后的,浏览器发出发请求

```http
PUT /cors HTTP/1.1
Origin: http://api.bob.com // 通过预检之后的请求,会自动带上Origin字段
Host: api.alice.com
X-Custom-Header: value
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
```

**关于 CORS 的 cookie 问题**

想要传递 `cookie` 需要满足 3 个条件

1.web 请求设置`withCredentials`

这里默认情况下在跨域请求，浏览器是不带 cookie 的。但是我们可以通过设置 `withCredentials` 来进行传递 `cookie`.

```js
// 原生 xml 的设置方式
var xhr = new XMLHttpRequest();
xhr.withCredentials = true;
// axios 设置方式
axios.defaults.withCredentials = true;
```

2.`Access-Control-Allow-Credentials` 为 `true`

3.`Access-Control-Allow-Origin`为非 `*`

这里请求的方式，在 `chrome` 中是能看到返回值的，但是只要不满足以上其一，浏览器会报错，获取不到返回值。

**3.代理**

### 8.说一说BFC

什么是bfc？https://juejin.cn/post/6950082193632788493
根据W3C的标准，在页面中元素都一个隐含的属性叫做Block Formatting Context简称BFC，该属性可以设置打开或者关闭，默认是关闭的。当元素开启BFC，它就变成一个独立的容器，内部的元素和外部元素互不影响

如何开启元素的BFC
- 1.设置元素浮动
  使用这种方式开启，虽然可以撑开父元素，但是会导致父元素的宽度丢失。而且使用这种方式也会导致下边的元素上移，不能解决问题

- 2.设置元素绝对定位

- 3.设置元素为inline-block
  可以解决问题，但是会导致宽度丢失，不推荐使用这种方式

- 4.将元素的overflow设置为一个非visible的值    

推荐方式：将overflow设置为hidden是副作用最小的开启BFC的方式。

这里简单列举几个触发BFC使用的CSS属性
overflow: hidden
display: inline-block
position: absolute
position: fixed
display: table-cell
display: flex

### 9.说一说Vuex是什么，每个属性是干嘛的，如何使用 ？

Vuex是为Vue开发的管理状态模式，集中存储管理所有组件的状态。属性分别由state、getters、mutations、actions、module。 

（1）state用来定义所要存储的数据，通过$store.state调用数据 

（2）getters可以认为是store的计算属性，通过$store.getters调用属性 

（3）mutations用来存放改变state数据的同步方法，每个方法接收的参数都是state，用$store.commit来调用mutations中的同步方法 

（4）actions用来存放异步方法，接收的参数是context（mutations中的方法），通过$store.dispatch调用actions中的方法 （5）module将store分割成模块，每个模块有自己的state、getters、mutations、actions、甚至嵌套子模块，从上至下进行同步分割 前四个属性除了用$store的方法调用，还能通过import { mapState/mapGetters/... } from 'vuex'引入，再用...mapState/mapGetter/...(['属性/方法名'])的形式映射进来调用

### 10.说一说JavaScript有几种方法判断变量的类型？

1、**typeof** 用来判断基本数据类型，对于引用数据类型function 返回function，其他都返回Object.

```js
  let a
  const b = null
  const c = 100
  const d = 'warbler'
  const e = true
  const f = Symbol('f')
  const foo = () => {}
  const arr = []
  const obj = {}
  console.log(typeof a) //=> undefined
  console.log(typeof b) //=> object
  console.log(typeof c) //=> number
  console.log(typeof d) //=> string
  console.log(typeof e) //=> boolean
  console.log(typeof f) //=> symbol
  console.log(typeof foo) //=> function
  console.log(typeof arr) //=> object
  console.log(typeof obj) //=> object
  console.log(typeof Infinity) //=> number
  console.log(typeof NaN) //=> number
```

2、**instanceof** 主要用于区分引用数据类型，检测方法是检测的类型在当前实例的原型链上，用其检测出来的结果都是true,不太适合检测简单数据类型的检测，检测过程繁琐且对简单数据类型中的undefined null symbol检测不出来。

```js
  const foo = () => { }
  const arr = []
  const obj = {}
  const data = new Date()
  const number = new Number(3)
  console.log(foo instanceof Function) //=> true
  console.log(arr instanceof Array) //=> true
  console.log(obj instanceof Object) //=> true
  console.log(data instanceof Object) //=> true
  console.log(number instanceof Object) //=> true
  console.log(null instanceof Object) //=> false
  console.log(undefined instanceof Object) //=> false
```

3、**constructor**:用于检测引用数据类型。这种方法不会把原型链上的其他类也加入进来，避免了原型链的干扰。 除了 `undefined` 和 `null` 之外，其他类型都可以通过 `constructor` 属性来判断类型。

```js
const reg = /^[a-zA-Z]{5,20}$/
const foo = () => { }
const arr = []
const obj = {}
const date = new Date();
const error = new Error();
console.log(c.constructor) //[Function: Number]
console.log(d.constructor) //[Function: String]
console.log(e.constructor) //[Function: Boolean]
console.log(f.constructor) //[Function: Symbol]
console.log(reg.constructor) //[Function: RegExp]
console.log(foo.constructor) //[Function: Function]
console.log(arr.constructor) //[Function: Array]
console.log(obj.constructor) //[Function: Object]
console.log(date.constructor) //[Function: Date]
console.log(error.constructor) //[Function: Error]{ stackTraceLimit: 10 }
```

4、**Object.prototype.toString.call()**:适用于所有类型的检测，检测方法是Object.prototype.toString.call(数据)返回的是该数据类型的字符串。最精准的就是这个方法

### 11.说一说样式优先级的规则是什么？

important>内联样式>id选择器>类选择器=伪类选择器=属性选择器>标签选择器=伪元素选择器>通配符选择器>继承样式>浏览器默认样式

### 12.（***）说一说JS实现异步的方法？

> javascript语言的执行环境是"单线程"(single thread)，就是指一次只能完成一件任务。如果有多个任务，就必须排队，等前面一个任务完成，再执行后面一个任务，以此类推。
>  这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。

什么是异步？

"调用"在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在"调用"发出后，"被调用者"通过状态、通知来通知调用者，或通过回调函数处理这个调用。异步调用发出后，不影响后面代码的执行。

https://juejin.cn/post/7082753409060716574

**Generator** 

函数是 ES6 提供的一种异步编程解决方案。`Generator` 函数是一个状态机，封装了多个内部状态。执行 `Generator` 函数会返回一个遍历器对象，可以依次遍历 `Generator` 函数内部的每一个状态。只有调用`next`方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。`yield`表达式就是暂停标志。

```js
function *foo() {
    yield 'a';
    yield 'b';
    yield 'c';
}

let str = '';
for (const val of foo()) {
    str = str + val;
}

console.log(str);//abc
```

```js
function* generator() {
  yield 1;
  yield 2;
  yield 3;
}

const gen = generator(); // "Generator { }"

console.log(gen.next().value); // 1
console.log(gen.next().value); // 2
console.log(gen.next().value); // 3
```

```js
function* detanxGenerator() {
    yield 'detanx';
    return 'ending';
}

const dg = detanxGenerator();
console.log(dg.next() )// { value: 'detanx', done: false }
console.log(dg.next() )// { value: 'ending', done: true }
console.log(dg.next() )// { value: undefined, done: true }
```

`Generator` 函数就是遍历器生成函数，可以把 `Generator` 赋值给对象的`Symbol.iterator`属性，从而使得该对象具有 `Iterator` 接口。任意一个对象的`Symbol.iterator`方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。

```js
var myIterable = {}
myIterable[Symbol.iterator] = function* () {
    yield 1;
    yield 2;
    yield 3;
};
//Generator 函数执行后，返回一个遍历器对象。该对象本身也具有Symbol.iterator属性，执行后返回自身。
[...myIterable] // [1, 2, 3]
```

**async/await**

https://juejin.cn/post/7007031572238958629

------

**简略版：**

**回调函数**是异步操作的最基本方法，比如AJAX回调，回调函数的优点：简单，容易理解和实现，缺点：不利于代码的阅读和维护。而且每个任务只能指定一个回调函数，不能使用try catch 捕获错误。

**promise**不仅能捕获错误，而且很好的解决了地狱回调问题，缺点是无法取消promise，错误需要通过回调函数捕获。

**Generator** 函数是 ES6 提供的一种异步编程解决方案。`Generator` 函数是一个状态机，封装了多个内部状态。执行 `Generator` 函数会返回一个遍历器对象，可以依次遍历 `Generator` 函数内部的每一个状态。

**async/await**是基于Promise实现的，async/await使得异步代码看起来像同步代码，所以优点是，使用方法清晰明了，缺点是await将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 await会导致性能上的降低，代码没有依赖性的话，完全可以使用 Promise.all 的方式。(https://juejin.cn/post/7106481255096516638)



### 



### 13.说一说Vue2.0 双向绑定的原理与缺陷？

Vue响应式指的是：组件的data发生变化，立刻触发视图的更新

vue的双向绑定是采用数据劫持和发布者订阅者模式的方式来实现响应式，通过object.defineProperty来劫持数据的getter，setter,在数据变化时发送消息给订阅者，订阅者收到消息后进行相应的处理。

Object.defineProperty的缺点：

1.无法监听数组变化（在Vue2.x中，通过重写Array原型上的方法解决了这个问题）
2.不能监听对象的新增属性和删除属性

### 14.说一说数组去重都有哪些方法？

1.ES6的set去重（*但是Set去重有一个弊端，他无法去重引用类型的数据。比如对象数组。*）
2.双重循环去重
3.filter配合indexOf去重

```js
const handleRemoveRepeat = (arr) => arr.filter((item,index) => arr.indexOf(item) === index);
```

### 15.说一说null 和 undefined 的区别，如何让一个属性变为null

null表示一个值被定义了，但是是空值，但是undefined表示未被定义。null和undefined在if判断中都会被解析为false，但是在用Number运算时，null的结果为0，undefined的结果为NaN，让属性变为null就需要先定义，再赋空值。

### 16.说一说es6中箭头函数？

1.写法简洁 
2.无自己的this，继承上一个作用域的this（全局或上一个函数） 
3.箭头函数的this永远不会变，call、apply、bind也无法改变 
4.arguments的特殊性（window下保存，this指向上一个函数则arguments表示上一个函数的参数） 
5.箭头函数没有原型prototype
6.箭头函数不能当成一个构造函数(没有自己的this，this的指向不会变，没有原型)

> 我们知道new内部实现其实是分为以下四步：
>
> - 新建一个空对象
>
> - 为该对象添加原型属性`__proto__`，将该属性链接至构造函数的原型对象prototype
>
> - 构造函数绑定新对象的this
>
> - 返回新对象
>

7.箭头函数没有自己的arguments。 箭头函数处于全局作用域中，则没有arguments，箭头函数处于普通函数的函数作用域中，arguments则是上层普通函数的arguments。但可以用可以使用rest参数代替（...)

箭头函数不适用场景:
1.对象方法，且方法中使用了this

```js
var name = '南玖'
var person = {
    name: 'nanjiu',
    say: function() {
        console.log('say:',this.name)
    },
    say2: () => {
        console.log('say2:',this.name)
    }
}

person.say() // say: nanjiu
person.say2() //say2: 南玖

```
person.say2()方法是一个箭头函数，调用person.say2()时，使得this指向全局对象，因此不会得到预期结果。这是因为对象不构成单独的作用域，导致say2()箭头函数定义时的作用域就是全局作用域。而say()定义的是一个普通函数，它内部的this就指向调用它的那个对象，所以使用普通函数符合预期。
2.当函数需要动态this时

### 17.说一说call apply bind的作用和区别？

首先，call apply bind三个方法都可以用来**改变函数的this指向**，具体区别如下：
1、fn.call (newThis,params) call函数的第一个参数是this的新指向，后面依次传入**函数fn要用到的参数**。会**立即**执行fn函数。
2、fn.apply (newThis,paramsArr) apply函数的第一个参数是this的新指向,第二个参数是**fn要用到的参数数组**，会**立即**执行fn函数。
3、fn.bind (newThis,params) bind函数的第一个参数是this的新指向，后面的参数可以直接传递，也可以按数组的形式传入。  **不会立即**执行fn函数，且只能改变一次fn函数的指向，后续再用bind更改无效。返回的是已经更改this指向的新fn

------
**简略版**：1.call apply改变this，直接调用，bind改变this,返回函数 2.call:参数是参数们，apply参数是数组

### 18.说一说this指向（普通函数、箭头函数）？

在全局环境中调用普通函数，严格模式下this指向undefined，非严格模式下this指向全局变量window；
通过一个对象来调用函数内部的方法，this指向该对象；
new关键字搭建好的新对象，构造函数里面的this指向新对象本身。

箭头函数没有this，一般是继承外部普通函数的this指向

```js
//全局中调用普通函数
var doSth = function(){
    console.log(this);
}
doSth();//非严格模式下输出全局变量window，严格模式下输出undefined
```

```js
//对象调用函数内部的方法
var doSth = function(){
    console.log(this.name);
}
var student = {
    name: '若川',
    doSth: doSth,
    other: {
        name: 'other',
        doSth: doSth,
    }
}
student.doSth(); // '若川'
```

```js
function Student(name){
    this.name = name;
    console.log(this); 
}
var result = new Student('若川');//输出 Student { name: '若川' }
```

------

**简略版**：普通函数中的this指向函数调用者，箭头函数中的this指向所在执行上下文中的this

### 19.（*）说一说CSS尺寸设置的单位

px：绝对像素
rem：相对于根元素像素
em：相对于父元素像素（如果父元素没有设置字体大小，em 会继续向上查找父元素的父元素，直到找到设置了字体大小的元素为止。如果找不到设置了字体大小的元素，则会相对于浏览器默认字体大小进行计算。）
vw：视口宽度。1vw 相当于视口宽度的 1%。
vh：视口高度

### 20.（***）说几个未知宽高元素水平垂直居中方法

（以下方案均适用于行内元素、行内块元素、块元素）

仅居中元素定宽高适用

- absolute + 负margin

- absolute + calc

- absolute + margin:auto

  

居中元素不定宽高

- absolute + transform
- flex
- grid
  

**1、absolute + top left50%+负margin**

```html
<body>
<div class="wrapper">
    <div class="inner"></div>
</div>
</body>
<style>
    .wrapper {
        width: 300px;
        height: 300px;
        border: 1px solid #ccc;

        position: relative;//外层设置定位
    }
    .inner{
        width: 100px;
        height: 100px;
        background-color: pink;

        position: absolute;//内层设置绝对定位
        top: 50%;//相对于父元素往下偏移50%
        left: 50%;//相对于父元素往右偏移50%
        margin-left: -50px;//上移
        margin-top: -50px;//左移
    }

</style>
```

**2、absolute + calc**

上一个方法的改编版

```html
<body>
<div class="wrapper">
    <div class="inner"></div>
</div>
</body>
<style>
    .wrapper {
        width: 300px;
        height: 300px;
        border: 1px solid #ccc;

        position: relative;
    }
    .inner{
        width: 100px;
        height: 100px;
        background-color: pink;

        position: absolute;
        top: calc(50% - 50px);
        left: calc(50% - 50px);
    }

</style>
```

**3.absolute +各个方向偏移设0 +margin:auto**

通过设置各个方向的偏移都是0，此时再将margin设为auto，就可以在各个方向上居中了

> `top`的效果取决于元素的`position`属性：
>
> - 当`position`设置为`absolute`或`fixed`时，`top`属性指定了定位元素上外边距边界与其包含块上边界之间的偏移。
> - 当`position`设置为`relative`时，`top`属性指定了元素的上边界离开其正常位置的偏移。
> - 当`position`设置为`sticky`时，如果元素在 viewport 里面，`top`属性的效果和 position 为`relative`等同；如果元素在 viewport 外面，`top`属性的效果和 position 为`fixed`等同。
> - 当`position`设置为`static`时，`top`属性无效。

```vue
<body>
<div class="wrapper">
    <div class="inner"></div>
</div>
</body>
<style>
    .wrapper {
        width: 300px;
        height: 300px;
        border: 1px solid #ccc;

        position: relative;//外层设置定位
    }
    .inner{
        width: 100px;
        height: 100px;
        background-color: pink;

        position: absolute;//内层设置绝对定位
        top: 0;//设置各个方向的偏移都是0
        left: 0;
        right: 0;
        bottom: 0;
        margin: auto;//将margin设为auto
    }

</style>
```



**4、absolute定位+transform **

```html
<body>
<div class="wrapper">
  <img src="https://p3-passport.byteimg.com/img/user-avatar/44193963b7d6dde4fca72c6facebe465~100x100.awebp">
</div>
</body>
<style>
  .wrapper {
    width: 300px;
    height: 300px;
    border: 1px solid #ccc;

    position: relative;//外层设置定位
  }

  .wrapper > img {
    position: absolute;//内层设置绝对定位
    left: 50%;//相对于父元素往右偏移50%
    top: 50%;//相对于父元素往下偏移50%
    transform: translate(-50%, -50%);
  }

</style>
```
**5、设置父元素为grid布局**

```html
<body>
<div class="wrapper">
  <p>horizontal and vertical</p>
</div>
</body>
<style>
  .wrapper {
    width: 300px;
    height: 300px;
    border: 1px solid #ccc;
      
    display: flex;//设置父元素为flex布局
    justify-content: center;//设置主轴的排列方式
    align-items: center;//设置交叉轴的排列方式
  }

</style>
```

**6、设置父元素为grid布局**

```html
<body>
<div class="wrapper">
  <p>horizontal and vertical</p>
</div>
</body>
<style>
  .wrapper {
    width: 300px;
    height: 300px;
    border: 1px solid #ccc;
      
    display: grid;//设置父元素为grid布局
    justify-content: center;//设置主轴的排列方式
    align-items: center;//设置交叉轴的排列方式
  }

</style>
```



> 相对定位relative相对定位是元素在移动的时候，是相对于它原来的位置来说的。
>
> 绝对定位absolute是元素在移动的时候，是相对于它祖先元素（父，爷，曾爷）来说的。(如果没有祖先元素或者祖先元素没有定位，则以浏览器(body)为准定位)

补充：

行内元素水平居中：给父元素设置**`text-align:center`**

### 21.说一说JS变量提升？

变量提升是指，在ES6以前我们在定义变量并且赋值时，JavaScript 引擎把首先会将变量和函数的声明提升到代码开头进行声明,并赋值undefined。这导致我们可以未声明变量的情况下提前使用该变量，并且不会报错。

```js
console.log(a)//undefined
var a=4
console.log(a)//4
```

在es6出来以后，let 和 const声明的变量必须先声明才能使用，否则会报错，并且let 和 const会有暂时性死区（在初始化之前访问let和const创建的变量会报错）的概念

### 22.说一说 HashRouter 和 HistoryRouter的区别和原理？
history和hash都是利用浏览器的2种特性实现前端路由，history是利用浏览历史记录栈的API实现，hash是监听location hash值变化事件来实现 
1.history的url没有#号，hash有#号 
2.history需要后端配合，如果后端不配合刷新页面会出现404;hash不需要后端配合hash（可以理解为只在前端自生自灭）
3.相同的url,history会触发添加到浏览器历史记录栈中，hash不会触发

hashRouter原理：通过window.onhashchange获取url中hash值.当井号 # 后面的路径发生变化时，浏览器并不会重新发起请求，而是会触发 onhashchange 事件。
historyRouter原理：通过history.pushState,使用它做页面跳转不会触发页面刷新，使用window.onpopstate监听浏览器的前进和后退

### 23.说一说map 和 forEach 的区别？

forEach和map都不改变原数组，但是能改变原数组的对象中的属性；
map会返回一个新的数组和原数组长度一样的数组，而forEach没有返回值，只是起到遍历作用
map的处理速度比forEach快，更推荐使用map

### 24.(***)说一说事件循环Event loop，宏任务与微任务？
**Event Loop(事件循环)** https://www.javascripttutorial.net/javascript-event-loop/

![event\_loop.png](https://v1.yequalsx.com/api/images/event_loop.png)

（1）所有同步任务都在主线程上执行，形成一个执行栈（call stack）。 
（2）主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。 
（3）一但"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。 
（4）主线程不断重复上面的第三步。

![img](https://files.codingninjas.in/article_images/microtask-and-macrotask-in-javascript-1-1653228810.jpg)

宏任务有：script（整体代码）/setTimout/setInterval/setImmediate(node 独有)/requestAnimationFrame(浏览器独有)/IO/UI render（浏览器独有）

微任务有：process.nextTick(node 独有)/Promise.then()/Object.observe/MutationObserver

> setTimeout的回调不一定在指定时间后能执行。而是在指定时间后，将回调函数放入宏任务的队列中。

> 每一次的循环操作被称为**tick**。

> `new Promise(..)`中的代码，也是同步代码，会立即执行。只有`then`之后的代码，才是异步执行的代码，是一个微任务。

------

**简略版：**

js是单线程的，主线程在执行时会不断循环往复的从同步任务队列中读取任务，执行任务，当同步任务队列执行完毕后再从异步任务队列中依次执行。

异步任务分为宏任务和微任务。完成当下的宏任务后，会立刻执行所有在此期间入队的微任务。这种设计是为了给紧急任务一个插队的机会，否则新入队的任务永远被放在队尾。区分了微任务和宏任务后，本轮循环中的微任务实际上就是在插队，这样微任务中所做的状态修改，在下一轮事件循环中也能得到同步。

宏任务有：scrip(JS 整体代码)、setTimeout、setInterval、setImmediate、I/O、UI 交互

微任务有：Promise(重点关注)、process.nextTick(Node.js)、MutaionObserver

### 25.说一说Vue3.0 实现数据双向绑定的方法 ？

在Vue2.0的基础上将Object.definedproperty换成了功能更强大的proxy，原理相同。在vue实例初始化的时候（vm._init()执行的时候）调用Observe类的实例方法observe，传入数据（若是对象则发生递归），将其中每个数据进行一遍数据劫持（get实现依赖收集，set实现事件派发（这里的模式为发布订阅模式））。

相对vue2.0解决的问题：解决无法监听新增属性或删除属性的响应式问题、解决无法监听数组长度和index变化问题。

### 26.说一下Diff算法？

![截屏2021-08-07 下午10.59.31.png](C:\Users\Jasmine\Desktop\面试\img\121.awebp)

> `虚拟DOM`是一个`对象`，一个什么样的对象呢？**一个用来表示真实DOM的对象**

> 例如 如果只有一个li标签修改了文本，其他都是不变的，所以没必要所有的节点都要更新，只更新这个li标签就行，Diff算法就是查出这个li标签的算法。

**Diff算法是一种对比算法**。对比旧虚拟DOM和新虚拟DOM，对比出是哪个虚拟节点更改了，找出这个虚拟节点，并只更新这个虚拟节点所对应的真实节点，

Diff算法的原理：
1.同层对比
新旧虚拟DOM对比的时候，Diff算法比较只会在同层级进行, 不会跨层级比较。 所以Diff算法是:深度优先算法。 时间复杂度:O(n)

<img src="C:\Users\Jasmine\Desktop\面试\img\232.awebp" alt="截屏2021-08-08 上午11.32.47.png" style="zoom:50%;" />

2.Diff对比流程
当数据改变时，会触发setter，并且通过Dep.notify去通知所有订阅者，订阅者们就会调用patch方法，给真实DOM打补丁，更新相应的视图。

![截屏2021-08-08 上午11.49.38.png](C:\Users\Jasmine\Desktop\面试\img\32.awebp)

3.patch方法：对比当前同层的虚拟节点是否为同一种类型的标签(同一类型的标准，下面会讲)
是：继续执行patchVnode方法进行深层比对
否：没必要比对了，直接整个节点替换成新虚拟节点

### 27.实现两栏布局和三栏布局？

**两栏布局**实现效果是将页面分割成左右宽度不登的两列,宽度较小的列设置为固定高度,剩余宽度由另一列撑满。

实现：flex布局 左边固定宽度，右边自适应

```xml
<body>
<div class="box">
  <div class="left">left</div>
  <div class="right">right</div>
</div>
</body>
<style>
  .wrapper {
    display: flex;//将外层设置为flex布局
  }

  .left {
    width: 100px;//固定宽度
    height: 300px;
    background-color: pink;
  }

  .right {
    height: 300px;
    background-color: orange;

    flex: 1;//元素充分利用剩余空间，同时不会侵占其他元素应有的宽度
  }
</style>
```

**三栏布局**

实现：flex布局 两边固定宽度，中间自适应

```xml
<div class="wrap">
    <div class="left">左侧</div>
    <div class="middle">中间</div>
    <div class="right">右侧</div>
</div>
<style type="text/css">
    .wrap {
        display: flex;//将外层设置为flex布局
    }

    .left,
    .right,
    .middle {
        height: 100px;
    }

    .left {
        width: 200px;//固定宽度
        background: pink;
    }

    .right {
        width: 120px;//固定宽度
        background: pink;
    }

    .middle {
        background: orange;
        flex: 1;//元素充分利用剩余空间，同时不会侵占其他元素应有的宽度
    }
</style>
```

### 28.说一下浏览器垃圾回收机制？
垃圾回收也就是定期找出那些不再用到的变量，然后释放其内存
垃圾回收机制分为栈垃圾回收和堆垃圾回收。
对于栈回收机制，当一个函数执行完成之后，JS会向下移动引擎来销毁该函数保存在栈中的执行上下文，遵循先进先出机制
对于堆空间中的数据，则需要依靠垃圾回收器进行回收。可以使用标记清除算法以及引用计数算法。
标记清除法：1.给内存所有对象打上标记，假设所有都是垃圾（全0），从一组根对象开始遍历，把不是垃圾的变为1，清除垃圾节点，销毁内存，把所有对象重新变0.但是清除后的内存空间不是连续的（内存碎片），存在分配问题。
引用计数法：对象是否需要=对象是否被其他对象引用，假设声明对象并使用引用赋值时引用次数为1，let a = new Object()，如果又被另一个值引用，再加1，如果引用变量被修改，减一，为0时，垃圾回收器回收空间，相较于标记清楚法，不需要循环遍历，能立即回收，但是维护计数器也会产生内存开销。

### 29.说一说 vue 的 keep-alive ？

使用`<keep-alive>`标签对需要缓存的组件进行包裹，默认情况下被`<keep-alive>`标签包裹的组件都会进行缓存

1.效果方面：能在内存保持其中的组件状态，放置重复渲染DOM，减少加载时间，从而提高性能。2.使用方面：有三个属性：include：指明要缓存的组件的名称，只有匹配的组件才会被保存。exclude：只有匹配的组件才不会被保存。max：最多能保存的组件数。3.结合Router使用：可以在相应组件下规定mate属性，并将keep-alive设置为true。4.源码实现方面：可以结合Vue组件实例加载顺序讲解，VNode->实例化->_updata->真实Node，在实例化的时候会判断该组件是否被keep-alive保存过，是的话则直接拿其中的DOM进行渲染。

### 30.CSRF攻击是什么？

跨域请求伪造。通过伪造受害者的请求并自动携带cookie给目标网站实行恶意操作

假设受害者用户A登录了目标网站某宝，且浏览器上存有某宝设置的鉴权cookie；攻击者B制作了钓鱼网站并在里面嵌入了发送伪造请求给某宝的恶意代码，B通过社会工程学诱导A点击了钓鱼网站；A的浏览器向某宝发送了B伪造的请求并自动携带上鉴权cookie，某宝服务器鉴权通过，造成A账户金额损失。

 防范CSRF攻击的方式： 1.给鉴权cookie设置sameSite=strict属性（使得 Cookie 在跨站请求时不会被发送），防止cookie自动携带至第三方请求上。 2.使用token进行鉴权，并将token存储在sessionStorage中。

### 31.XSS攻击是什么？

xss指跨站脚本攻击，是攻击者通过向被攻击网站注入恶意代码实现攻击，当被攻击者登陆这些网站时就会执行恶意代码，读取cookie、session以及其他敏感信息

 防范XSS攻击的方式：1.就是对输入框的内容进行过滤或使用转义符进行转码。2.使用CSP，就是`白名单`，告诉浏览器哪些外部资源可以加载执行。3.对一些敏感信息进行保护，在`Cookie`信息中添加`httpOnly`，告诉浏览器在保存Cookie，且不要对客户端脚本开放访问权限，然后就不能通过document.cookie获取cookie了

### 32.说一说js继承的方法和优缺点？

1、**原型链继承** （不推荐）
子类型的原型为父类型的一个实例对象。

优点：写法简单、容易理解。缺点：①无法向父类构造函数传参②父类的所有属性被共享，只要一个实例修改了属性，其他所有的子类实例都会被影响
2、**借用构造函数继承**（不推荐）
在子类型构造函数中通用call()调用父类型构造函数

优点：①父类的所有属性被共享；②在子类实例对象创建时，可以向父类传参；缺点：①无法实现函数复用，每个子类都有父类实例函数的副本，影响性能 ②只是子类的实例，不是父类的实例
3、**组合继承**(推荐)
组合 原型链继承 和 借用构造函数继承。
通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用。

 --- 融合原型链和借用构造函数的优点，是js中最常用的继承方式；缺点：调用了两次父类构造函数，一是创建子类原型对象时，二是子类构造函数内部。

4、**寄生组合继承**（推荐）
结合借用构造函数传递参数和寄生模式实现继承
通过借用构造函数继承属性,通过原型链的混成形式继承方法
使用寄生式继承来继承超类型的原型,然后在将结果指定给子类型的原型
--- 优点：高效率只调用一次父类构造函数，并且避免了子类原型对象上不必要、多余的属性，同时，还能将原型链保持不变，因此能使用instanceof 和 isPrototypeOf。缺点：代码复杂
5**.ES6中class 的继承**(最佳)
ES6中引入了class关键字，class可以通过extends关键字实现继承，还可以通过static关键字定义类的静态方法
ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。

代码实现


```js
//原型链继承
 //父类型
       function Person(name, age) {
           this.name = name,
           this.age = age,
           this.play = [1, 2, 3]
           this.setName = function () { }
       }
       Person.prototype.setAge = function () { }
       //子类型
       function Student(price) {
           this.price = price
           this.setScore = function () { }
       }
       Student.prototype = new Person() // 子类型的原型为父类型的一个实例对象
       var s1 = new Student(15000)
       var s2 = new Student(14000)


```

```js
// 借用构造函数继承
  function Person(name, age) {
    this.name = name,
    this.age = age,
    this.setName = function () {}
  }
  Person.prototype.setAge = function () {}
  function Student(name, age, price) {
    Person.call(this, name, age)
    this.price = price
  }
  var s1 = new Student('Tom', 20, 15000)


```

```js
//组合继承
        function Person(name, age) {
            this.name = name,
            this.age = age,
            this.setAge = function () { }
        }
        Person.prototype.setAge = function () {
            console.log("111")
        }
        function Student(name, age, price) {
            Person.call(this,name,age)
            this.price = price
            this.setScore = function () { }
        }
        Student.prototype = new Person()
        Student.prototype.constructor = Student//组合继承也是需要修复构造函数指向的
        Student.prototype.sayHello = function () { }
        var s1 = new Student('Tom', 20, 15000)
        var s2 = new Student('Jack', 22, 14000)
        console.log(s1)
        console.log(s1.constructor) //Student
        console.log(p1.constructor) //Person

```

```js
//ES6中class 的继承
       class Person {
            //调用类的构造方法
            constructor(name, age) {
                this.name = name
                this.age = age
            }
            //定义一般的方法
            showName() {
                console.log("调用父类的方法")
                console.log(this.name, this.age);
            }
        }
        let p1 = new  Person('kobe', 39)
        console.log(p1)
        //定义一个子类
        class Student extends Person {
            constructor(name, age, salary) {
                super(name, age)//通过super调用父类的构造方法
                this.salary = salary
            }
            showName() {//在子类自身定义方法
                console.log("调用子类的方法")
                console.log(this.name, this.age, this.salary);
            }
        }
        let s1 = new Student('wade', 38, 1000000000)
        console.log(s1)
        s1.showName()
```

### 33.说一说defer和async区别？

```html
<script src="script.js"></script>
<script  src="script.js" async></script>
<script  src="script.js" defer></script>
```

![img](C:\Users\Jasmine\Desktop\面试\img\mage)

前提：html文件都是按顺序执行的

`<script>` : 当HTML解析过程中遇到script标签时，浏览器中断HTML解析，随即下载script文件，完成后立即执行script，执行完成后再继续HTML解析

`<script async>` : 当HTML解析过程中遇到script标签时，不会中断HTML解析，同时并行下载script文件，下载完成后中断HTML解析并执行script，执行完成后再继续HTML解析（script的执行顺序不一定按照script标签的出现顺序，而是取决于script下载完成的顺序）

`<script defer>`（更合理） : 当HTML解析过程中遇到script标签时，不会中断HTML解析，同时并行下载script文件，直到HTML解析完成再执行script（script的执行顺序与script标签出现顺序一致）

### 34.说一下浏览器如何渲染页面的？

1、HTML被HTML解析器解析成DOM树。
2、CSS被CSS解析器解析成CSS规则树。
3、浏览器会将CSS规则树附着在DOM树上，并结合两者生成渲染树Render Tree。
4、生成布局（flow），浏览器通过解析计算出每一个渲染树节点的位置和大小，在屏幕上画出渲染树的所有节点。 
5、将布局绘制（paint）在屏幕上，显示出整个页面

------

简略版：
1.解析HTML，生成DOM树
2.解析CSS，生成CSSOM树
3.两棵树结合，生成Render树
4.计算布局，绘制页面的所有节点
5.绘制布局

### 35.（***）说一说computed和watch的区别？

computed是计算属性，watch是监听一个值的变化，然后执行对应的回调。

- computed一般用于计算得出数据，并将数据缓存在内存当中，computed计算结果一般由他的依赖项所决定，只有当依赖项发生改变，computed才会重新计算，提升性能，在computed中只能进行同步操作。

- watch更多是监听数据变化后会引发什么样的动作，在watch中可以进行异步操作

### 36.Vue 中 $nextTick 作用与原理

> vue 采用的**异步更新策略**，当监听到数据发生变化的时候不会立即去更新DOM，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。 所以数据变化了，DOM却不会立即的更新，而是在下一个Tick中更新dom。
>
>  这种做法带来的好处就是可以将多次数据更新合并成一次，减少操作DOM的次数，
>  如果不采用这种方法，假设数据改变100次就要去更新100次DOM，而频繁的DOM更新是很耗性能的；

$nextTick 方法主要用来等待视图更新后再执行某些代码。在 Vue 中，当组件的数据更新时，视图会被重新渲染，但这个过程是异步的。这意味着，在数据更新后立即操作 DOM 可能会导致问题，因为视图可能还没有完全更新。

$nextTick 方法可以解决这个问题，它可以等待视图更新后再执行回调函数中的代码。这样就可以确保操作的 DOM 元素是最新的，避免了许多常见的问题。

这个方法在很多场景下都会用到，例如：
\- 在组件挂载后操作 DOM 元素
\- 在数据更新后执行一些操作
\- 在组件的事件回调中操作 DOM 元素
\- 在一个组件中更新另一个组件的数据后执行一些操作

原理是 $nextTick 方法会将回调函数放入 Vue 的异步队列queue，在下次运行 vue 的更新循环时，会从 queue 中检查并运行所有的回调函数。因此 $nextTick 方法是一种异步处理办法，是可以保证异步回调函数在 DOM 更新完成之后才能执行的机制。

$nextTick 方法接受一个回调函数作为参数，在下一次 DOM 更新循环结束之后立即执行。这使得我们可以确保更新后的 DOM 已经更新并且操作 DOM 是安全的。

------

简略版：vue中数据更新的时候，页面不会立刻更新，而是等同一个事件循环的数据都变化后，才统一更新页面，换句话说，它是异步的，如果要在数据修改的时候拿到更新后的DOM，就需要从nexttick中获取，nexttick本质是返回promise

### 37.谈一谈token

https://juejin.cn/post/6844903664163749901

- 首次登录时，后端服务器判断用户账号密码正确之后，根据用户id、用户名、定义好的秘钥、过期时间生成 token ，返回给前端；
- 前端拿到后端返回的 token ,存储在 localStorage 和 Vuex 里；
- 前端每次路由跳转，判断 localStorage 有无 token ，没有则跳转到登录页，有则请求获取用户信息，改变登录状态；
- 每次请求接口，在 Axios 请求头里携带 token;
- 后端接口判断请求头有无 token，没有或者 token 过期，返回401；
- 前端得到 401 状态码，重定向到登录页面。



### 37.说一下token 能放在cookie中吗？

![批注 2022-06-20 232618.png](C:\Users\Jasmine\Desktop\面试\img\126f7awebp)

可以，token是令牌，是用来判断用户是否登录的，客户端输入用户名和密码，服务器收到请求，去验证用户名和密码，验证成功后，服务端签发一个token发送给客户端，客户端可以把它保存在cookie和localStorage应用下次验证登录。`token` 是否过期，应该由后端来判断，不该前端来判断，所以`token`存储在`cookie`中只要不设置`cookie`的过期时间就ok了。

但最好不要放cookie里，容易产生CSRF问题

### 38.（***）说一下浏览器输入URL发生了什么？

输入地址，浏览器查找域名的 IP 地址。 浏览器向 该 IP 地址的web 服务器发送一个 HTTP 请求，在发送请求之前浏览器和服务器建立TCP的三次握手，判断是否是HTTP缓存，如果是强制缓存且在有效期内，不再向服务器发请求，如果是HTTP协商缓存向后端发送请求且和后端服务器对比，在有效期内，服务器返回304，直接从浏览器获取数据，如果不在有效期内服务器返回200，返回新数据。 请求发送出去服务器返回重定向，浏览器再按照重定向的地址重新发送请求。 如果请求的参数有问题，服务器端返回404，如果服务器端挂了返回500。 如果有数据一切正常，当浏览器拿到服务器的数据之后，开始渲染页面同时获取HTML页面中图片、音频、视频、CSS、JS，在这期间获取到JS文件之后，会直接执行JS代码，阻塞浏览器渲染，因为渲染引擎和JS引擎互斥，不能同时工作，所以通常把Script标签放在body标签的底部。 渲染过程就是先将HTML转换成dom树，再将CSS样式转换成stylesheet，根据dom树和stylesheet创建布局树，对布局树进行分层，为每个图层生成绘制列表，再将图层分成图块，紧接着光栅化将图块转换成位图，最后合成绘制生成页面。

https://juejin.cn/post/6997345616078569508

**简洁版**

①url判断。判断输入的是搜索内容还是url。

②查找本地缓存。如果能在本地找到缓存直接返回页面，如果没有缓存需要发送网络请求页面。 

③DNS解析：将域名转换为IP地址。 

④通过三次握手建立TCP连接。 

⑤合成请求头信息，发送http请求。 

⑥服务器响应返回结果。 

⑦通过四次挥手释放TCP连接。 

⑧浏览器渲染。

⑨js引擎解析。

### 39.（***）说一说组件通信的方式？

简略版：

**1、父子组件通信：**

**props：使用 props 将数据从父组件传递到子组件。**

**$emit：子组件通过派发事件的方式给父组件数据。**

**$refs：父组件可以通过 ref 主动获取子组件的属性或者调用子组件的方法**

**2、兄弟组件通信：**

**EventBus: 使用 EventBus 的 $on、$emit 方法通过创建一个自定义事件来进行通信**

**3、祖先和子孙组件通信常用provide和inject；**

**4、复杂通信常用vuex，pinia**

1. `props`父组件向子组件传送数据

   子组件接收到数据之后，不能直接修改父组件的数据。

   ```vue
   Parent.vue 传送:
   <template>
       <child :msg="msg"></child>
   </template>
   
   
    Child.vue 接收:
   export default {
     // 写法一 用数组接收
     props:['msg'],
     // 写法二 用对象接收，可以限定接收的数据类型、设置默认值、验证等
     props:{
         msg:{
             type:String,
             default:'这是默认数据'
         }
     },
     mounted(){
         console.log(this.msg)
     },
   }
   ```

   

2. `.sync`子组件可以修改父组件内容

   `.sync`可以帮我们实现父组件向子组件传递的数据的双向绑定，所以子组件接收到数据后可以直接修改，并且会同时修改父组件的数据

   ```vue
   Parent.vue:
   <template>
       <child :page.sync="page"></child>
   </template>
   <script>
   export default {
       data(){
           return {
               page:1
           }
       }
   }
   
    Child.vue:
   export default {
       props:["page"],
       computed(){
           // 当我们在子组件里修改 currentPage 时，父组件的 page 也会随之改变
           currentPage {
               get(){
                   return this.page
               },
               set(newVal){
                   this.$emit("update:page", newVal)
               }
           }
       }
   }
   </script>
   ```

3. `ref`

   `ref` 如果在普通的DOM元素上，引用指向的就是该DOM元素;

   如果在子组件上，引用的指向就是子组件实例;

   父组件可以通过 ref 主动获取子组件的属性或者调用子组件的方法

   ```vue
   // Child.vue
   export default {
       data(){
           return {
               name:"oldCode"
           }
       },
       methods:{
           someMethod(msg){
               console.log(msg)
           }
       }
   }
   
   // Parent.vue
   <template>
       <child ref="child"></child>
   </template>
   <script>
   export default {
       mounted(){
           const child = this.$refs.child
           console.log(child.name) 
           child.someMethod("调用了子组件的方法")
       }
   }
   </script>
   ```

   

4. `$emit / v-on`

   子组件通过派发事件的方式给父组件数据，或者触发父组件更新等操作

   ```vue
   // Child.vue 派发
   export default {
     data(){
         return { msg: "这是发给父组件的信息" }
     },
     methods: {
         handleClick(){
             this.$emit("sendMsg",this.msg)
         }
     },
   }
   // Parent.vue 响应
   <template>
       <child v-on:sendMsg="getChildMsg"></child>
       // 或 简写
       <child @sendMsg="getChildMsg"></child>
   </template>
   
   export default {
       methods:{
           getChildMsg(msg){
               console.log(msg) // 这是父组件接收到的消息
           }
       }
   }
   ```

5.`$attrs / $listeners`
   多层嵌套组件传递数据时，如果只是传递数据，而不做中间处理的话就可以用这个，比如父组件向孙子组件传递数据时

   `$attrs`：包含父作用域里除 class 和 style 除外的非 props 属性集合。通过 this.$attrs 获取父作用域中所有符合条件的属性集合，然后还要继续传给子组件内部的其他组件，就可以通过 v-bind="$attrs"
   `$listeners`：包含父作用域里 .native 除外的监听事件集合。如果还要继续传给子组件内部的其他组件，就可以通过 v-on="$linteners"使用方式是相同的

   ```vue
   Parent.vue:
   <template>
       <child :name="name" title="1111" ></child>
   </template
   export default{
       data(){
           return {
               name:"oldCode"
           }
       }
   }
   
   Child.vue:
   <template>
       // 继续传给孙子组件
       <sun-child v-bind="$attrs"></sun-child>
   </template>
   export default{
       props:["name"], // 这里可以接收，也可以不接收
       mounted(){
           // 如果props接收了name 就是 { title:1111 }，否则就是{ name:"oldCode", title:1111 }
           console.log(this.$attrs)
       }
   }
   ```
6.`provide / inject`

 `provide / inject` 是依赖注入，在一些插件或组件库里被常用
`provide`：可以让我们指定想要提供给后代组件的数据或方法
`inject`：在任何后代组件中接收想要添加在这个组件上的数据或方法，不管组件嵌套多深都可以直接拿来用
要注意的是 provide 和 inject 传递的数据不是响应式的，也就是说用 inject 接收来数据后，provide 里的数据改变了，后代组件中的数据不会改变，除非传入的就是一个可监听的对象 所以建议还是传递一些常量或者方法

```js
// 父组件
export default{
    // 方法一 不能获取 methods 中的方法
    provide:{
        name:"oldCode",
        age: this.data中的属性
    },
    // 方法二 不能获取 data 中的属性
    provide(){
        return {
            name:"oldCode",
            someMethod:this.someMethod // methods 中的方法
        }
    },
    methods:{
        someMethod(){
            console.log("这是注入的方法")
        }
    }
}

// 后代组件
export default{
    inject:["name","someMethod"],
    mounted(){
        console.log(this.name)
        this.someMethod()
    }
}
```
7.EventBus

`EventBus` 是中央事件总线，不管是父子组件，兄弟组件，跨层级组件等都可以使用它完成通信操作

```vue
// 在需要向外部发送自定义事件的组件内
<template>
    <button @click="handlerClick">按钮</button>
</template>
import Bus from "./Bus.js"
export default{
    methods:{
        handlerClick(){
            // 自定义事件名 sendMsg
            Bus.$emit("sendMsg", "这是要向外部发送的数据")
        }
    }
}

// 在需要接收外部事件的组件内
import Bus from "./Bus.js"
export default{
    mounted(){
        // 监听事件的触发
        Bus.$on("sendMsg", data => {
            console.log("这是接收到的数据：", data)
        })
    },
    beforeDestroy(){
        // 取消监听
        Bus.$off("sendMsg")
    }
}
```




### 40.说一说 v-if 和 v-show区别？

v-if：是否渲染，耗费的性能大。 v-show：是否显示，相当于是否设置display:none。

 v-if: 适合使用在切换不频繁，且元素内容很多，渲染一次性能消耗很大的元素上。v-show: 适合使用在切换频繁显示/隐藏的元素上。

### 41.说一说伪数组和数组的区别？

1. 伪数组的特点：类型是object、不能使用数组方法、可以获取长度、可以使用for in遍历
2. 伪数组可以装换为数组的方法：a. Array.prototype.slice.call() b.Array.from() c. [...伪数组] 
3. 有哪些是伪数组：函数的参数arguments，Map和Set的keys()、values()和entires()



### 42.说一说cookie、sessionStorage、localStorage 区别？

共同点：
1.都是浏览器存储
2.都存储在浏览器本地 
区别：
1.cookie由服务器写入， sessionStorage以及localStorage都是由前端写入 
2.cookie的生命周期由服务器端写入时就设置好的，localStorage是写入就一直存在，除非手动清除，sessionStorage是由页面关闭时自动清除 
3.cookie存储空间大小约4kb， sessionStorage及localStorage空间比较大，大约5M 
4.三者的数据共享都遵循同源原则，sessionStorage还限制必须是同一个页面

> 什么是同源
> 在了解跨域这个概念之前首先要知道的是何为同源策略。所谓的同源是一种安全机制，为了预防某些恶意行为（例如 Cookie 窃取等），浏览器限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。而满足同源要具备三方面：协议相同、域名相同、端口相同。

5.前端给后端发送请求时，自动携带cookie, session 及 local都不携带 

6.cookie一般存储登录验证信息或者token，localStorage常用于存储不易变动的数据，减轻服务器压力，sessionStorage可以用来监测用户是否是刷新进入页面，如音乐播放器恢复进度条功能

### 42.sessionStorage、localStorage 区别？

Local Storage --本地缓存： 通常情况下，存在本地缓存当中的数据，只要不是人为手动的去本地缓存中清除掉，是会一直存在于你的浏览器当中的，时效性是永久的；

Session Storage -- 会话缓存： 当我们关闭当前页面（结束会话），那我们存储在会话缓存中的数据就会被清除，时效性仅仅是当前会话进行时。

### 43.说一说如何实现可过期的localstorage数据？

localStorage一般用于长久保存浏览器的数据，保存的数据没有过期时间，直到手动删除。所以要如何实现可过期的localStorage缓存呢？目前有两种方法。1惰性删除，2.定时删除。

**惰性删除**是指某个键值过期后，该键值不会被马上删除，而是等到下次被使用的时候，才会被检查到过期，此时才能得到删除。

实现方法： 在获取数据的时候，我们可以对比存储的时间和当前的时间，判断有没有过期，如果过期了则清除localStorage。

**定时删除**是我们每隔一段时间执行一次删除操作

实现方法：获取所有设置过期时间的key判断是否过期，过期就存储到数组中，遍历数组，每隔1S（固定时间）删除5个（固定个数），直到把数组中的key从localstorage中全部删除。

### 44.说一说axios的拦截器原理及应用？

axios拦截器分为响应和请求拦截器:

请求拦截器 在请求发送前进行必要操作处理，例如添加统一cookie、请求体加验证、设置请求头等，相当于是对每个接口里相同操作的一个封装； 

响应拦截器 同理，响应拦截器也是如此功能，只是在请求得到响应之后，对响应体的一些处理，通常是数据统一处理等，也常来判断登录失效等。

### 45.说一说创建ajax过程？

> Ajax的工作原理相当于在用户和服务器之间加了一个中间层(AJAX引擎)，使用户操作与服务器响应异步化。客户端发送请求，请求交给xhr，xhr把请求提交给服务器，服务器进行业务处理，服务器响应数据交给xhr对象，xhr对象接收数据，由javascript把数据写到页面上，如下图所示：

![AJAX工作原理图](C:\Users\Jasmine\Desktop\面试\img\7adb89a0df3f.awebp)

（1）创建异步对象，即 XMLHttpRequest 对象。 

```js
 let xhr = new XMLHttpRequest();
```

（2）注册回调函数：注册 onreadystatechange 事件，状态改变时就会调用。如果要在数据完整请求回来的时候才调用，我们需要手动写一些判断的逻辑。 

```js
xhr.onreadystatechange = function callback() {
  // 判断异步对象的状态
  if(xhr.readyState == 4) {
    // 判断交互是否成功
    if(xhr.status == 200) {
      // 获取服务器响应的数据
      var res = xhr.responseText
      // 解析数据
      res = JSON.parse(res)
    }
  }
}
```

（3）使用open方法与服务器建立连接。open(method, url, async)。参数解释：请求的方法、请求的 url、是否异步。第三个参数如果不写，则默认为 true。 

```js
// get 方式
xhr.open("get", "test.php", true)

// post 方式发送数据 需要设置请求头
xhr.open("post", "test.php", true)
xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded")

```

（4）发送请求：send()。 

```js
// get 不需要传递参数
xhr.send(null)

// post 需要传递参数
xhr.send("name=jay&age=18")
```

（5）服务端响应，获取返回的数据。

### 46.说一下fetch 请求方式？

> Fetch 和 Axios/Ajax 的关系
>
**Axios是对XMLHttpRequest的封装，而Fetch是一种新的获取资源的接口方式，并不是对XMLHttpRequest的封装。**

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/515d70fb207e49b79e9edaa8b2d871c5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

fetch是一种HTTP数据请求的方式，是XHR的一种替代方案。Fetch函数就是原生js，没有使用XMLHttpRequest对象。给`fetch()` 提供一个参数指明资源路径，会返回一个包含响应结果的promise。

### 47.说一下有什么方法可以保持前后端实时通信？

前后端一般通过HTTP协议进行交互，但HTTP协议是基于“问答模式”的，即客户端发起询问，服务端才会响应。但对于一些实时的场景，比如股票趋势图、直播...等，服务端更新数据的速度很快，如果每次都要客户端询问，这样传输数据的效率十分低下，所以得通过其它交互模式支持实时通信。

实现实时通信有以下几种方式： 

1.短轮询：客户端设置定时器，每隔几秒就向服务端发送请求，通过频繁地请求到达实时的效果。这种方式要求服务器的响应速度很快。 

2.长轮询：客户端和服务端保持一条长连接，一旦服务端有新的数据，不等客户端请求就会主动发送给对方。这种方式要求服务器有高并发能力。

3.iframe流：在页面中插入一个隐藏的iframe，利用其src属性在服务器和客户端之间创建一条长连接，服务器向iframe传输数据（通常是HTML，内有负责插入信息的javascript），来实时更新页面。

4.WebSocket：一种全双工通信协议，客户端和服务端处于相同的地位。通过客户端与服务端建立的HTTP连接进行切换，客户端会发送一个带update:websocket字段的HTTP请求请求协议切换，服务端会回复带101状态码的响应表示协议切换成功。接着它们使用websocket进行通信，一旦有新的数据服务端可以直接发送给客户端。 

5.SSE（Server-Sent Event）：服务端与客户端建立的一个单向通道，只能由服务端传输特定形式的数据给服务端，这里并不是建立一个长连接。

短轮询适用于：小型应用，实时性不高。 长轮询适用于：一些早期的对及时性有一些要求的应用：web IM 聊天。 iframe适用于：客服通信等。 WebSocket适用于：微信、网络互动游戏等。 SSE适用于：金融股票数据、看板等

### 48.说一下重绘、重排区别如何避免？

重排：页面DOM元素的布局/位置发生变化，需要重新排列元素位置。

重绘：页面DOM元素的样式发生变化，需要重新绘制元素图层。

触发重排的方法有：

1. 初始化页面
2. 改变文字大小
3. 浏览器计算offsetHeight/width，resize
4. 设置css伪类 5. style属性。 

避免重排的方法有
1.尽量用class类的方式统一修改样式 
2.脱离文档流 
3.transform的方式调整位置 而不是 top、left、margin等，触发GPU加速 
4.减少使用table布局 
5.使用visibility：hidden ，隐藏元素而不是 display：none 更改文档流

https://juejin.cn/post/6854573209791135757

### 49.说一说 Vue 列表为什么加 key？

Vue列表加key的目的是为diff算法添加标识，因为diff算法判断新旧VDOM是否相同的依据是节点的tag和key。如果tag和key相同则会进一步进行比较，使得尽可能多的节点进行复用。此外，key绑定的值一般是一个唯一的值，比如id。如果绑定数组的索引index，则起不到优化diff算法的作用，因为一旦数组内元素进行增删，后续节点的绑定的key也会发生变化，导致diff进行多余的更新操作。

### 50.路由传参的方式和区别？

https://juejin.cn/post/6844903967080595464



### 50.说一说vue-router 实现懒加载的方法？

懒加载的核心思想是按需加载，也叫做异步加载：只有请求到该组件的时候，才会对该组件进行网络请求并加载。懒加载有利于解决页面首次请求资源过多，导致白屏时间长的问题。 

vue-router的懒加载即通过箭头函数的写法导入组件如 `const Home= ()=> import('../路径')；`

### 51.（***）图片性能优化方式？

https://juejin.cn/post/6965761736083243044

1.webpack 压缩

工程化的项目可以在 webpack 里面配置 image-webpack-loader 进行图片压缩

2.使用雪碧图

可以有效的较少请求个数

3.图片懒加载

图片懒加载的原理就是暂时不设置图片的 src 属性，而是将图片的 url 隐藏起来，比如先写在 data-src 里面，等当前图片是否到了可视区域再将图片真实的 url 放进 src 属性里面，从而实现图片的延迟加载。

4.图片预加载

图片预加载，是指在一些需要展示大量图片的网站，将图片提前加载到本地缓存中，从而提升用户体验。

常用的方式有两种，一种是隐藏在 css 的 background 的 url 属性里面，一种是通过 javascript 的 Image 对象设置实例对象的 src 属性实现图片的预加载。

5.使用 CDN 图片 可达到分流的效果，减少服务器压力。

### 51.说一说前端性能优化手段？

前端性能优化从两个方面入手，使浏览器获取页面资源更快和使浏览器渲染页面更快

**使浏览器获取页面资源更快**：

1. 让传输的数据包更小（压缩文件/图片）：图片压缩和文件压缩 
2. 减少网络请求的次数：雪碧图/精灵图、节流防抖 
3.  减少渲染的次数：缓存（HTTP缓存、本地缓存、Vue的keep-alive缓存等）

**使浏览器渲染页面更快**：

1. 提前渲染：ssr服务器端渲染 
2. 避免渲染阻塞：CSS放在HTML的head中 JS放在HTML的body底部 
3. 避免无用渲染：懒加载 
4. 减少渲染次数：对dom查询进行缓存、将dom操作合并、使用减少重排的标签

### 52.（***）深拷贝和浅拷贝区别 

浅拷贝和深拷贝：浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。

浅拷贝数组很简单直接`  let arr2 = arr1;`

数组深拷贝方法：
- 使用数组遍历赋值
  
  ```js
   var arr1 = [1,2,3];
    var arr2 = [];
    arr1.forEach(function(value,index){
      arr2[index] = value;
    }) 
    console.log(arr2);
  ```
  
- 使用slice/map/concat返回新数组

  ```js
    var arr1 = [1,2,3];
    var arr2 = arr1.slice(0);
    console.log(arr2); //[1,2,3]
  ```

  ```js
    var arr1 = [2,3,4];
    var arr2 = arr1.map(function(value){
      return value;  
    })
    console.log(arr2);  //[2,3,4]
  ```

  ```js
    var arr1 = [3,4,5];
    var arr2 = arr1.concat();
    console.log(arr2);   //[3,4,5]
  ```
- ES6扩展运算符

  ```js
  let arr = [1,2,3,4,5];
  let arr2=[...arr]
  ```

  

### 52.事件扩展符用过吗(...)，什么场景下？

对象中的扩展运算符(...)用于取出参数对象中的所有可遍历的属性，浅拷贝到当前的对象中

1.数组去重`[...new Set(arr)] `2.数组拷贝`[...arr] `3.伪数组转真数组` [...伪数组]`

### 53.（***）说一说vue的生命周期和钩子函数？

每个组件都可能会经历从创建、挂载、更新、卸载等一系列的过程，称为**生命周期**。Vue 为生命周期中的每个状态都设置了钩子函数(监听函数) 。每当 Vue 实例处于不同的生命周期时，对应的函数就会被触发调用。

`vue` 生命周期函数有哪些

`Vue` 的生命周期钩子核心实现是利用发布订阅模式先把用户传入的的生命周期钩子订阅好（内部采用数组的方式存储）然后在创建组件实例的过程中会一次执行对应的钩子方法（发布）。

- `beforeCreate`：是 `new Vue()` 之后触发的第一个钩子，在数据观测、 event、watcher 事件配置之前被调用。在当前阶段 `data`、`methods`、`computed` 以及 `watch` 上的数据和方法都不能被访问。

  > Event 和 Watcher 是 Vue.js 中的两种重要的机制。
  >
  > Event 是 Vue.js 的事件系统，它允许组件之间通信。在 Vue 中，父组件可以使用 $emit 方法触发事件，子组件可以使用 $on 方法监听事件。
  >
  > Watcher 是 Vue.js 中的观察者，它用于监听和响应 Vue 实例上的数据变化。当组件中的数据发生变化时，Watcher 会被触发并执行相应的回调函数。
  >
  > Event 和 Watcher 是 Vue.js 组件之间通信和响应数据变化的两个重要机制，它们可以帮助开发者实现组件之间的交互和数据的响应式更新。

- `created`：在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发 `updated` 函数。可以做一些初始数据的获取，在当前阶段无法与 `Dom` 进行交互，如果非要想，可以通过 `vm.$nextTick` 来访问 `Dom`。

- `beforeMount`：发生在挂载之前，在这之前 `template` 模板已导入渲染函数编译。而当前阶段虚拟 `Dom` 已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发 `updated`。

- `mounted`：在挂载完成后发生，在当前阶段，真实的 `Dom` 挂载完毕，数据完成双向绑定，可以访问到 `Dom` 节点，使用 `$refs` 属性对 `Dom` 进行操作。

- `beforeUpdate`：发生在更新之前，也就是响应式数据发生更新，虚拟 `dom` 重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染。

- `updated`：发生在更新完成之后，当前阶段组件 `Dom` 已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。

- `beforeDestroy`：发生在实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。

- `destroyed`：发生在实例销毁之后，这个时候只剩下了 `dom` 空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。

Vue3的改动：

被替换

- beforeCreate -> setup()
- created -> setup()

重命名

- beforeMount -> onBeforeMount
- mounted -> onMounted
- beforeUpdate -> onBeforeUpdate
- updated -> onUpdated
- beforeDestroy -> onBeforeUnmount
- destroyed -> onUnmounted
- errorCaptured -> onErrorCaptured

新增的

新增的以下2个方便调试 debug 的回调钩子：

- onRenderTracked
- onRenderTriggered

### 53.路由守卫

导航守卫就是路由跳转过程中的一些钩子函数，用于在路由跳转之前或之后进行特定的操作。路由守卫可以用来实现身份验证、权限控制等功能。

https://juejin.cn/post/6844903924760051725

https://juejin.cn/post/6944244998397231134

**（1）全局守卫：**是指路由实例上直接操作的钩子函数，特点是所有路由配置的组件都会触发，直白点就是触发路由就会触发这些钩子函数

- beforeEach（to，from， next）
- beforeResolve（to，from， next）
- afterEach（to，from）

**（2）路由守卫：** 是指在单个路由配置的时候也可以设置的钩子函数

- beforeEnter（to，from， next）

**（3）组件守卫：**是指在组件内执行的钩子函数，类似于组件内的生命周期，相当于为配置路由的组件添加的生命周期钩子函数。

- beforeRouteEnter（to，from， next）
- beforeRouteUpdate（to，from， next）
- beforeRouteLeave（to，from， next）

### 54.CSS display属性

CSS display 属性**设置元素是否被视为块或者内联元素**以及**用于子元素的布局**，例如流式布局、网格布局或弹性布局。

```css
display: none;//此元素不会被显示。

display: inline;//默认。此元素会被显示为内联元素，元素前后没有换行符。
display: block;//此元素将显示为块级元素，此元素前后会带有换行符。
display: inline-block;//行内块元素。

display: flex;//设置子元素的布局为弹性盒模型。
display: grid;//设置子元素的布局为网格布局。
```

### 55.块元素和行内元素、行内块元素的区别

**1.块级元素**

**（1）常见的块元素有哪些？**

常见的块元素有`<h1>~<h6>、<p>、<div>、<ul>、<ol>、<li>`等，其中 `<div>` 标签是最典型的块元素。

**（2）块级元素有什么特点？**

- 自己独占一行
- 高度，宽度、外边距以及内边距都可以控制。
- 宽度默认是容器（父级宽度）的 `100%`
- 是一个容器及盒子，里面可以放行内或者块级元素

**（3）注意问题：**

 只有文字才能组成段落，因此 `p` 标签里面不能放块级元素，特别是 `p` 标签不能放 `div`。同理还有这些标签`h1,h2,h3,h4,h5,h6,dt` ，他们都是文字类块级标签，里面不能放其他块级元素。

**2.行内元素**

**（1）常见行内元素有哪些？**

常见的行内元素有 `<a>、<strong>、<b>、<em>、<i>、<del>、<s>、<ins>、<u>、<span>` 等，其中 `<span>` 标签最典型的行内元素，也称内联元素。

**（2）行内元素有哪些特点？**

- 相邻行内元素在一行上，一行可以显示多个
- 高、宽直接设置是无效的
- 只可以设置水平方向的外边距
- 默认宽度就是它本身内容的宽度
- 行内元素只能容纳文本或则其他行内元素

**（3）注意问题：**

链接里面不能再放链接。

特殊情况 `a` 里面可以放块级元素，但是给 `a` 转换一下块级模式最安全。

**3.行内块元素**

**（1）常见行内块元素有哪些？**

在行内元素中有几个特殊的标签 `<img />、<input />、<td>`，可以对它们设置宽高和对齐属性，有些资料可能会称它们为行内块元素。

**（2）行内块元素有什么特点？**

- 和相邻行内元素（行内块）在一行上,但是之间会有空白缝隙，一行可以显示多个。
- 默认宽度就是它本身内容的宽度。
- 高度，行高、外边距以及内边距都可以控制。

```css
display:inline;//块转行内
display:block;//行内转块
display: inline-block;//块、行内元素转换为行内块
```

### 56.`js` 原型和原型链

引用类型的四个规则：

1、引用类型，都具有对象特性，即可自由扩展属性。

```js
const obj = {}
const arr = []
const fn = function () {}

obj.a = 1
arr.a = 1
fn.a = 1

console.log(obj.a) // 1
console.log(arr.a) // 1
console.log(fn.a) // 1
```

2、引用类型，都有一个隐式原型 `__proto__` 属性，属性值是一个普通的对象。

```
const obj = {};
const arr = [];
const fn = function() {}

console.log('obj.__proto__', obj.__proto__);
console.log('arr.__proto__', arr.__proto__);
console.log('fn.__proto__', fn.__proto__);
```

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8640c1029037485ca324b2cf61bdf928~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

3、引用类型，隐式原型 `__proto__` 的属性值指向它的构造函数的显式原型 `prototype` 属性值。

```js
const obj = {};
const arr = [];
const fn = function() {}

obj.__proto__ == Object.prototype // true
arr.__proto__ === Array.prototype // true
fn.__proto__ == Function.prototype // true
```

4、当你试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么它会去它的隐式原型 `__proto__`（也就是它的构造函数的显式原型 `prototype`）中寻找。

```js
const obj = { a:1 }
obj.toString
// ƒ toString() { [native code] }
```

**原型链**

该对象的`__proto__`=构造函数的`prototype`

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c631b657ca62427a8bdef1a2c145346a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

```js
function Person(name) {
    this.name = name
    return this // 其实这行可以不写，默认返回 this 对象
}

let nick = new Person("nick")
nick.toString//按理说， nick 是 Person 构造函数生成的实例，而 Person 的 prototype 并没有 toString 方法，那么为什么， nick 能获取到 toString 方法？
```

这里就引出 `原型链` 的概念了， `nick` 实例先从自身出发检讨自己，发现并没有 `toString` 方法。找不到，就往上走，找 `Person` 构造函数的 `prototype` 属性，还是没找到。构造函数的 `prototype` 也是一个对象嘛，那对象的构造函数是 `Object` ，所以就找到了 `Object.prototype` 下的 `toString` 方法。

**检测方法**

object ` instanceof ` constructor

`instanceof` 运算符用来检测 `constructor.prototype` 是否存在于参数 `object` 的原型链上。

> 补充几个问题
>
> `Person.prototype.constructor` 是什么？Person
>
> 函数有没有 `__ proto __` 属性？有,`Function.prototype`。函数都是由 `Function` 原生构造函数创建的，所以函数的 `__proto__` 属性指向 `Function` 的 `prototype` 属性。

### 57.手写Promise

https://juejin.cn/post/6994594642280857630

https://juejin.cn/post/7016856020395753509

https://juejin.cn/post/6844903912592375821

### 58.前端怎样对用户的数据进行加密传输?

> 如果我们想要尽可能保证用户的信息安全，我们需要做以下的工作
> \- 使用https请求
> \- 利用RSA加密密码并传输数据
> \- 用BCrypt或者PBKDF2单向加密，并存储

RSA和MD5算法.

### 59.`let,const,var` 有什么区别

**（1）块级作用域：** 块作用域由 `{ }`包括，`let` 和 `const` 具有块级作用域，`var` 不存在块级作用域(用 var*声明的变量，不是函数作用域就是全局作用域)。块级作用域解决了 `ES5` 中的两个问题：

- 内层变量可能覆盖外层变量
- 用来计数的循环变量泄露为全局变量

**（2）变量提升：** `var` 存在变量提升，`let` 和 `const` 不存在变量提升，即在变量只能在声明之后使用，否在会报错。

**（3）给全局添加属性：** 浏览器的全局对象是 `window`，`Node` 的全局对象是 `global`。`var` 声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是 `let` 和 `const` 不会。

**（4）重复声明：** `var` 声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。`const` 和 `let` 不允许重复声明变量。

**（5）暂时性死区：** 在使用 `let`、`const` 命令声明变量之前，该变量都是不可用的。这在语法上，称为**暂时性死区**。使用 `var` 声明的变量不存在暂时性死区。

**（6）初始值设置：** 在变量声明时，`var` 和 `let` 可以不用设置初始值。而 `const` 声明变量必须设置初始值。

**（7）指针指向：** `let` 和 `const` 都是 `ES6` 新增的用于创建变量的语法。 `let` 创建的变量是可以更改指针指向（可以重新赋值）。但 `const` 声明的变量是不允许改变指针的指向。

### 60.什么是虚拟 `dom`

`Virtual DOM` 是 `DOM` 节点在 `JavaScript` 中的一种抽象数据结构，之所以需要虚拟 `DOM`，是因为浏览器中操作 `DOM` 的代价比较昂贵，频繁操作 `DOM` 会产生性能问题。

虚拟 `DOM` 的作用是在每一次响应式数据发生变化引起页面重渲染时，`Vue` 对比更新前后的虚拟 `DOM`，匹配找出尽可能少的需要更新的真实 `DOM`，从而达到提升性能的目的。

虚拟 `DOM` 的实现原理主要包括以下 **3** 部分：

- 用 `JavaScript` 对象模拟真实 `DOM` 树，对真实 `DOM` 进行抽象；
- `diff` 算法 — 比较两棵虚拟 `DOM` 树的差异；
- `pach` 算法 — 将两个虚拟 `DOM` 对象的差异应用到真正的 `DOM` 树。

### 61.`vue` 有哪些内置指令

![640.webp](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9905a8c13994556bd06c00a89f3eca5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?)

> 如何让 `CSS` 只在当前组件中起作用?
>
> 在组件中的 `style` 标签中加上 `scoped`

### 62.如何解决 `vue` 初始化页面闪动问题

使用 `vue` 开发时，在 `vue` 初始化之前，我们写的代码在还没有解析的情况下会看到类似于 `{{message}}` 的字样，虽然一般情况下这个时间很短暂，但是我们还是有必要让解决这个问题的。

```html
<div class="#app" v-cloak>
    <p>{{value.name}}</p>
</div>
```

```css
[v-cloak] {
    display: none;
}
```

### 63.什么是 `SPA`，有什么优点和缺点

`SPA` 仅在 `Web` 页面初始化时加载相应的 `HTML`、`JavaScript` 和 `CSS`。一旦页面加载完成，`SPA` 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 `HTML` 内容的变换，`UI` 与用户的交互，避免页面的重新加载。

**优点：**

- 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；
- 有利于前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；

**缺点：**

- 初次加载耗时多：为实现单页 `Web` 应用功能及显示效果，需要在加载页面的时候将 `JavaScript`、`CSS` 统一加载，部分页面按需加载；
- 不利于 `SEO`：由于所有的内容都在一个页面中动态替换显示，所以在 `SEO` 上其有着天然的弱势。

### 64.首屏渲染优化方案有哪些

> ![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90836777035c4fbb8b07432003ab75d5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?)
>
> 其中，**首屏优化**就属于加载时优化

常见的几种SPA首屏优化方式

- 减小入口文件体积

  - 路由懒加载： Vue：箭头函数+import

  - 静态资源引入CDN

    > CDN的全称是内容分发网络。使用户可就近取得所需内容.

- 静态资源本地缓存

- UI框架按需加载

  常见诸如Element-UI、Antd 快速使用中都有**按需使用**的文档

- 图片资源的压缩

  对于所有的图片资源，我们可以进行适当的压缩

  对页面上使用到的`icon`，可以使用在线字体图标，或者雪碧图，将众多小图标合并到同一张图上，用以减轻`http`请求压力。

- 组件重复打包

  假设`A.js`文件是一个常用的库，现在有多个路由使用了`A.js`文件，这就造成了重复下载

  解决方案：在`webpack`的`config`文件中，修改`CommonsChunkPlugin`的配置

  ```makefile
  minChunks: 3
  ```

  `minChunks`为3表示会把使用3次及以上的包抽离出来，放进公共依赖文件，避免了重复加载组件

- 开启GZip压缩

  拆完包之后，我们再用`gzip`做一下压缩 安装`compression-webpack-plugin`

  ```css
  cnmp i compression-webpack-plugin -D
  复制代码
  ```

  在`vue.congig.js`中引入并修改`webpack`配置

  ```javascript
  const CompressionPlugin = require('compression-webpack-plugin')
  
  configureWebpack: (config) => {
          if (process.env.NODE_ENV === 'production') {
              // 为生产环境修改配置...
              config.mode = 'production'
              return {
                  plugins: [new CompressionPlugin({
                      test: /.js$|.html$|.css/, //匹配文件名
                      threshold: 10240, //对超过10k的数据进行压缩
                      deleteOriginalAssets: false //是否删除原文件
                  })]
              }
          }
  复制代码
  ```

  在服务器我们也要做相应的配置 如果发送请求的浏览器支持`gzip`，就发送给它`gzip`格式的文件 我的服务器是用`express`框架搭建的 只要安装一下`compression`就能使用

  ```php
  const compression = require('compression')
  app.use(compression())  // 在其他中间件使用之前调用
  ```

- 使用SSR

  SSR（Server side ），也就是服务端渲染，组件或页面通过服务器生成html字符串，再发送到浏览器

  从头搭建一个服务端渲染是很复杂的，`vue`应用建议使用`Nuxt.js`实现服务端渲染，`React`建议`Next.js`

### 65.`git` 常用命令了解哪些

### 66.如何做权限认证

在路由守卫中根据 `url` 地址结合 `token` 做权限认证。

https://juejin.cn/post/7081517906026037284

### 67.(***)谈谈你对 `webpack` 的看法

`webpack`是一个打包工具

**webpack的作用？**

- 模块打包。可以将不同模块的文件打包整合在一起，并且保证它们之间的引用正确，执行有序。

- 编译兼容。在前端的“上古时期”，手写一堆浏览器兼容代码一直是令前端工程师头皮发麻的事情，而在今天这个问题被大大的弱化了，通过`webpack`的`Loader`机制，不仅仅可以帮助我们对代码做`polyfill`，还可以编译转换诸如`.less, .vue, .jsx`这类在浏览器无法识别的格式文件，让我们在开发的时候可以使用新特性和新语法做开发，提高开发效率。

  > Loader:Webpack 本身只能处理 JavaScript 模块，如果要处理其他类型的文件(CSS、图像或 txt 文件)，就需要使用 loader 进行转换。

- 能力扩展。通过`webpack`的`Plugin`机制，我们在实现模块化打包和编译兼容的基础上，可以进一步实现诸如按需加载，代码压缩等一系列功能，帮助我们进一步提高自动化程度，工程效率以及打包输出的质量。



**webpack 的构建流程是什么？**

`初始化参数`：解析webpack配置参数，合并shell传入和webpack.config.js文件配置的参数,形成最后的配置结果；

`开始编译`：上一步得到的参数初始化compiler对象，注册所有配置的插件，插件 监听webpack构建生命周期的事件节点，做出相应的反应，执行对象的run方法开始执行编译；

`确定入口`：从配置的entry入口，开始解析文件构建AST语法树，找出依赖，递归下去；

`编译模块`：递归中根据文件类型和loader配置，调用所有配置的loader对文件进行转换，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；

`完成模块编译并输出`：递归完事后，得到每个文件结果，包含每个模块以及他们之间的依赖关系，根据entry或分包配置生成代码块chunk;

`输出完成`：输出所有的chunk到文件系统；

实战：https://www.valentinog.com/blog/webpack/

**webpack 的热更新原理?**

其实是自己`开启了express应用`，添加了对webpack编译的监听，添加了和浏览器的websocket长连接，当文件变化触发webpack进行编译并完成后，`会通过sokcet消息告诉浏览器准备刷新`。而为了减少刷新的代价，就是`不用刷新网页`，而是`刷新某个模块`，webpack-dev-server可以支持热更新，通过生成 文件的hash值来比对需要更新的模块，浏览器再进行热替换

## webpack有哪些常⻅的Loader

- `file-loader`：把⽂件输出到⼀个⽂件夹中，在代码中通过相对 URL 去引⽤输出的⽂件
- `url-loader`：和 file-loader 类似，但是能在⽂件很⼩的情况下以 base64 的⽅式把⽂件内容注⼊到代码中去
- `source-map-loader`：加载额外的 Source Map ⽂件，以⽅便断点调试
- `image-loader`：加载并且压缩图⽚⽂件
- `babel-loader`：把 ES6 转换成 ES5
- `css-loader`：加载 CSS，⽀持模块化、压缩、⽂件导⼊等特性
- `style-loader`：把 CSS 代码注⼊到 JavaScript 中，通过 DOM 操作去加载 CSS。
- `eslint-loader`：通过 ESLint 检查 JavaScript 代码

## webpack 常见的plugin有哪些

- `ProvidePlugin`：自动加载模块，代替require和import
- `html-webpack-plugin`可以根据模板自动生成html代码，并自动引用css和js文件
- `extract-text-webpack-plugin` 将js文件中引用的样式单独抽离成css文件
- `DefinePlugin` 编译时配置全局变量，这对开发模式和发布模式的构建允许不同的行为非常有用。
- `HotModuleReplacementPlugin` 热更新
- `optimize-css-assets-webpack-plugin` 不同组件中重复的css可以快速去重
- `webpack-bundle-analyzer` 一个webpack的bundle文件分析工具，将bundle文件以可交互缩放的treemap的形式展示。
- `compression-webpack-plugin` 生产环境可采用gzip压缩JS和CSS
- `happypack`：通过多进程模型，来加速代码构建
- `clean-wenpack-plugin` 清理每次打包下没有使用的文件
- `speed-measure-webpack-plugin`:可以看至U每个Loader和Plugin执行耗时（整个扌丁包耗时、每个Plugin和 Loader 耗时）
- `webpack-bundle-analyzer`:可视化Webpack输出文件的体积（业务组件、依赖第三方模块

**如何⽤webpack来优化前端性能？**

⽤webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运⾏快速⾼效。

- `压缩代码`：删除多余的代码、注释、简化代码的写法等等⽅式。可以利⽤webpack的 UglifyJsPlugin 和 ParallelUglifyPlugin 来压缩JS⽂件， 利⽤ cssnano （css-loader?minimize）来压缩css
- `利⽤CDN加速`: 在构建过程中，将引⽤的静态资源路径修改为CDN上对应的路径。可以利⽤webpack对于 output 参数和各loader的 publicPath 参数来修改资源路径
- `Tree Shaking`: 将代码中永远不会⾛到的⽚段删除掉。可以通过在启动webpack时追加参数 --optimize-minimize 来实现
- `Code Splitting`: 将代码按路由维度或者组件分块(chunk),这样做到按需加载,同时可以充分利⽤浏览器缓存
- `提取公共第三⽅库`: SplitChunksPlugin插件来进⾏公共模块抽取,利⽤浏览器缓存可以⻓期缓存这些⽆需频繁变动的公共代码

**你知道sourceMap是什么吗？**

`sourceMap`是一项将编译、打包、压缩后的代码映射回源代码的技术，由于打包压缩后的代码并没有阅读性可言，一旦在开发中报错或者遇到问题，直接在混淆代码中`debug`问题会带来非常糟糕的体验，`sourceMap`可以帮助我们快速定位到源代码的位置，提高我们的开发效率。`sourceMap`其实并不是`Webpack`特有的功能，而是`Webpack`支持`sourceMap`，像`JQuery`也支持`souceMap`。

既然是一种源码的映射，那必然就需要有一份映射的文件，来标记混淆代码里对应的源码的位置，通常这份映射文件以`.map`结尾，里边的数据结构大概长这样：

```js
{
  "version" : 3,                          // Source Map版本
  "file": "out.js",                       // 输出文件（可选）
  "sourceRoot": "",                       // 源文件根目录（可选）
  "sources": ["foo.js", "bar.js"],        // 源文件列表
  "sourcesContent": [null, null],         // 源内容列表（可选，和源文件列表顺序一致）
  "names": ["src", "maps", "are", "fun"], // mappings使用的符号名称列表
  "mappings": "A,AAAB;;ABCDE;"            // 带有编码映射数据的字符串
}
```
