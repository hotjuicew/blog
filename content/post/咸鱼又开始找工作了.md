---
title: "又开始找工作了"
date: 2023-05-31T17:36:11+08:00
categories: ['面试']
draft: true
---

不努力是不会有回报的。嗯！

## JS篇
### 1.数组去重有哪些方法？
a.`const newArr=[...new Set(arr)]`
b.`const newArr=filter((value,index,arr)=>return value.indexOf(value)===index)`
c.`const newArr = arr.reduce((unique, item) => {
  return unique.includes(item) ? unique : [...unique, item];
}, []);`
### 2.深拷贝和浅拷贝的区别？数组深拷贝方法？对象深拷贝方法？
对于引用数据类型来说，比如普通对象、数组、正则，浅拷贝就是拷贝指向它的那个指针，这两个变量共用一块内存空间。深拷贝是重新开辟一块内存，复制对象本身。
数组深拷贝方法：a重新创建一个数组然后遍历赋值 b使用展开运算符 [...originalArray] c使用slice()方法 let newArr=arr.slice()
对象深拷贝方法：a 手动实现递归深拷贝函数 b 使用json序列化和反序列化const newObj=JSON.parse(JSON.stringify(obj)) 缺点是无法复制函数、正则表达式、循环引用 c 引入lodash库 _.deepClone(obj)方法
### 2.js数据类型有哪些
基本数据类型：Number，String，Boolean,  Null, Undefined,    BigInt,Symbol
引用数据类型：对象（包括普通对象、数组、函数、正则等）
### 3.获取js变量类型的方法？
a typeof缺点是如果该变量是对象，只能返回Object，不能区分具体类型。例外的是Function会返回Function
b instance of 是判断是否是特定的数据类型的，返回true or false
c Object.prototype.toString.call()可以返回具体的类型
### 4.说一说promise？
Promise 是 JavaScript 中处理异步操作的一种方式。它是一种代表异步操作最终完成或失败的对象。Promise 对象有三个状态：Pending、Fulfilled和Rejected。通过.then()方法指定成功时的处理函数，通过.catch()方法指定失败时的处理函数。使用 Promise 可以更好地处理异步代码，避免回调地狱。
### 5.说一说promise.all和promise.race、Promise.allSettled？
都是接收一个由多个Promise对象组成的数组，并返回一个新的Promise对象。这个新的Promise对象

Promise.all 等待所有 Promise 完成，所有的Promise对象都变为resolved状态时才会被resolved，否则只要有一个Promise对象变为rejected状态，它就会被提前终止并返回一个rejected的Promise对象。
Promise.race 只要参数的Promise实例有一个率先改变状态，则状态改变，返回最先解决或拒绝的 Promise 的结果。
Promise.allSettled 等待所有 Promise 完成，并返回一个包含每个 Promise 结果的数组，无论它们是被解决还是被拒绝。与Promise.all不同的是，Promise.allSettled不会提前终止，即使其中某个Promise对象被rejected，它也会等待所有的Promise对象都完成后才返回结果。
### 6.说一说原型和原型链？instanceof原理？
原型是js每个对象都具有的属性，用于共享属性和方法。每个对象都有一个_proto_属性，指向它的原型对象。（每个构造函数都有一个prototype属性，指向它示例对象的原型对象。）
由于每个对象都有自己的原型，它的原型也有原型，这样就形成了一条原型链。当我们访问一个对象的属性或方法时，js会先查找对象本身是否有该属性或方法，如果没有，它会继续在原型链上向上查找，直到找到或者到达原型链的顶端（即Object.prototype）
A instanceof B是检测对象A是不是B的实例。检测是基于原型链查找的，是找B的prototype有没有在A的原型链上
### 7.箭头函数有哪些特点？
a 语法简洁 b 如果只有一个表达式的话，会隐式返回，不需手动写return c 箭头函数没有自己的this、arguments、super，而是继承了其外部作用域。这意味着箭头函数内部的this值是由函数定义位置上的外部作用域决定的，而不是在运行时确定的。也无法显式绑定this。
d 由于没有自己的this值，不能使用new来创建对象示例->无法作为构造函数
### 8.扩展运算符用过吗，什么场景下？
扩展运算符可以取出参数对象中的所以可遍历属性，浅拷贝进当前对象中。
可以用于数组去重（结合Set）、数组拷贝、伪数组转真数组。
### 9.new操作符都做了哪些事？
a 创建一个空对象
b 设置该对象的原型对象。将新对象的 _Proto_指向构造函数的 prototype 属性
c 将新创建的对象作为this的上下文
d 如果构造函数没有显式返回一个对象，则 new 操作符会隐式返回新创建的对象。
### 10.说一说js事件循环？
js的任务分为同步任务和异步任务。遇到同步任务就放到执行栈上去执行，遇到异步任务就把它丢给异步模块处理，处理好了的异步任务就会进行任务队列中等待。等到执行栈上的同步任务全部处理完了之后，就进入执行炸中执行。其中，异步任务又分为宏任务和微任务，宏任务包括script标签、setTimeOut、setInterval，微任务包括promise和process.nextTick。对于异步任务来说，事件循环的每个轮次中，首先执行所有的微任务，按照它们被添加到任务队列的顺序依次执行。然后再执行宏任务，如果在执行宏任务的过程中有新的微任务生成，它们会被立即执行，确保微任务优先于下一个宏任务执行。

总结起来，JavaScript 事件循环是一种处理同步和异步任务的机制。同步任务按顺序执行，而异步任务被放入事件循环中，按照微任务优先于宏任务的顺序执行。这种机制确保了js可以处理并发的异步操作。
### 11.promise.all方法的使用场景？数组中必须每一项都是promise对象吗？不是promise对象会如何处理？
使用场景：并行执行多个异步操作，等待它们全部完成后进行下一步处理。如果数组中有非Promise对象的项，它们将被自动包装为已解决（resolved）的Promise对象。
### 12.说一说this的指向？
（1）全局上下文：在全局作用域中，this指向全局对象（浏览器中是window对象，Node.js环境中是global对象）。
（2）函数上下文：
a在函数作为对象的方法调用时，this指向调用该方法的对象。
b直接通过函数名来调用时，this指向全局对象（在严格模式下是undefined）。
c用作构造函数，通过new关键字创建了一个新的对象实例
d使用call、apply或bind方法时，可以显式地指定this的值。
（3）箭头函数上下文：箭头函数的this指向其定义时的上下文，而不是调用时的上下文。它捕获了函数定义时所在的作用域的this值。
### 13.说一说call、apply、bind的作用和区别？
都可以显式改变this的指向。
call、apply会立即执行改变了this指向后的函数并返回指向结果。而bind是返回一个新的函数，不会立即执行。
call和apply的区别是，call的第二个参数及以后是一个个的参数，apply的第二个参数是一个数组
### 14.let、const、var的区别是什么？什么是块级作用域？
var的作用域是函数作用域，没有块的概念，可以跨块访问，不能跨函数访问。有变量提升。可以重复声明，后面的声明会覆盖前面的声明。
let、const的作用域是块级作用域，没有变量提升，不能重复声明。
let是声明变量，可以重新赋值。const是声明常量，不能重新赋值。
块级作用域是指变量在块（一对花括号{}）内部定义，并且在该块的外部不可访问。
变量提升：js在解析代码的时候，将变量和函数声明提前至作用域顶部
### 15.说一说js的内存泄露和垃圾回收？
程序中已经释放的堆内存未释放，造成系统资源的浪费。js是一种自动垃圾回收语言，js引擎在运行时会自动回收不再使用的内存。通常使用"标记-清除"算法，该算法会遍历对象的引用关系，并标记所有可达的对象。然后，它会清除未被标记的对象，并回收它们所占用的内存空间。
### 16.es6新增了哪些东西？
（1）块级作用域与let、const关键字：引入了块级作用域，通过使用let和const关键字声明变量和常量，使得变量的作用域更加清晰并且可以避免变量提升的问题。
（2）箭头函数：提供了更简洁的函数定义语法，箭头函数具有词法作用域和更方便的this绑定。
（3）解构赋值：可以从数组或对象中提取值并赋给变量，使得数据的提取更加便捷。
（4）模板字面量：通过使用反引号（`）创建字符串模板，可以方便地插入变量和执行表达式。
（5）默认参数：函数参数可以设置默认值，简化了函数的调用和定义。
（6）扩展运算符：使用三个点（...）可以将数组或对象展开，使得在函数调用、数组和对象字面量中的使用更加灵活。
（7）类和模块：引入了类的概念，通过class关键字可以更方便地定义对象的结构和行为。同时，也引入了模块的概念，通过import和export可以更好地组织和管理代码。
（8）Promise和异步操作：引入了Promise对象，提供了一种更便捷的处理异步操作的方式，避免了回调地狱的问题
（9）迭代器和生成器：通过迭代器和生成器可以更容易地实现迭代和异步编程模型
（10）新的数据类型和方法：引入了Symbol作为一种新的数据类型，提供了更多的内置方法，如Array.from()、Array.of()、Object.assign()等，方便了开发者的日常工作。
（11）引入了两种数据结构Map和Set。Map是一种键值对的集合，其中每个键都是唯一的，通过键可以获取对应的值。Set是一种存储唯一值的集合，每个值只会出现一次，可以用于去重或存储一组互不重复的值。
### 17.说一说防抖和节流？
防抖和节流都是用于控制事件的触发频率的。
防抖的原理是在事件触发后等待一段时间，如果在等待时间内再次触发该事件，则重新计时。只有在等待时间结束后，事件没有再次触发，才会执行相应的处理函数。
怎么实现：使用setTimeout函数设置一个等待时间，在等待时间内再次触发函数调用时，会先清除之前的定时器。用闭包来保存定时器的状态。
应用：实时搜索框
节流的原理是规定一个时间间隔，在这个时间间隔内，只能触发一次函数调用。如果在时间间隔内多次触发函数调用，只有第一次会执行，其余的触发会被忽略。
实现：使用时间戳来控制函数的执行时间，当两次函数调用时，之间的时间间隔大于设定的时间间隔时，才执行被节流的函数，并且更新时间戳为now
应用：频繁点击按钮
### 18.说一说js的导入导出模块方式？
模块是一种封装和复用代码的方式。主要有两种方式。
CommonJS使用require和module.exports来导入和导出模块
es6使用import和export来导入导出模块
### 19.ajax、axios、fetch的区别？
ajax是一种计数统称，主要利用XHR实现异步通信，它很重要的特性之一就是让页面实现局部刷新。
axios基于promise的http库，提供简洁的API和拦截器，易于使用
fetch是原生的http请求api，基于promise，简洁易用。但在老的浏览器中需使用polyfill。
### 20.数组常用方法
push、pop、shift、unshift、splice、sort、concat、join
21.map()和foreach的区别？
map()方法接收一个处理数组元素的回调函数，会返回一个新数组。
foreach也是接收一个回调函数，但它没有返回值，只是遍历一遍数组，也不会改变原数组。

## 网络篇
### 1.说一说http请求的方法有哪些？
GET：向服务器请求资源，可以在请求中传递参数，但参数会附加在 URL 中。
POST：向服务器创建新的资源。POST 请求的数据会包含在请求体中，而不是附加在URL上。
PUT：向服务器更新资源，通常用于替换整个资源。PUT 请求的数据会包含在请求体中，并用于完全替换指定的资源。
PATCH：用于向服务器部分更新资源，通常用于更新资源的一部分。PATCH 请求的数据会包含在请求体中，但只包含需要更新的字段。
DELETE：用于从服务器删除资源。DELETE 请求用于删除指定的资源。
HEAD：类似于 GET 请求，但只返回响应头信息，不返回响应体。通常用于获取资源的元数据，如内容类型、大小等。
### 2.浏览器本地储存的方式？
浏览器本地存储的方式有以下三种：
Cookies：Cookies 是浏览器中最古老和最常见的本地存储方式。它们是由服务器发送到浏览器，并存储在用户的计算机上的小型文本文件。Cookies 可以用于存储有限量的数据，Cookies在后续的请求中会被自动发送给服务器。但是 Cookies 的大小有限制，并且会随着每个请求的传输，对网络性能产生一定的影响。
Web Storage（Web 存储）：Web Storage 提供了一种在浏览器中存储键值对数据的机制，分为 sessionStorage 和 localStorage 两种。sessionStorage 用于在浏览器窗口关闭前存储数据，而localStorage则是一直保持数据，直到被手动清除。Web Storage 是基于域名的，每个域名有独立的存储空间，并且可以存储更大量的数据（一般是 5MB 或更多）。
IndexedDB：IndexedDB 是一个功能强大的客户端数据库，可在浏览器中存储结构化数据。它支持事务操作和索引，可以存储大量数据，并提供灵活的查询功能。
### 3.说一说http状态码？
http状态码表示http请求的处理结果。
2xx 成功：
200 OK：请求成功，服务器成功处理了请求并返回相应的内容。
201 Created：请求成功并且服务器创建了新的资源。
204 No Content：请求成功，但服务器没有返回任何内容。

3xx 重定向：
301 Moved Permanently：资源的 URL 已永久移动到新位置。
302 Found：资源的 URL 暂时移动到新位置。
304 Not Modified：客户端缓存的资源是最新的，无需重新获取。

4xx 客户端错误：
400 Bad Request：请求存在语法错误，服务器无法理解。
401 Unauthorized：请求需要用户身份验证。
404 Not Found：请求的资源不存在。

5xx 服务器错误：
500 Internal Server Error：服务器在处理请求时发生了错误。
503 Service Unavailable：服务器暂时无法处理请求，通常是由于过载或维护等原因。

### 4.url输入浏览器发生了什么？
（1）解析url。浏览器检查是否合法，确定协议域名端口路径等信息，
（2）DNS解析。浏览器根据域名解析DNS查询，以获取目标服务器的ip地址。
具体流程：
    2.1浏览器首先查找自身的DNS缓存，如果找到了对应的IP地址，就直接使用缓存结果。
    2.2如果浏览器的DNS缓存中没有对应的IP地址，浏览器发送域名查询请求到本地DNS解析器（isp或路由器）。本地DNS解析器检查自己的缓存，如果找到了对应的IP地址，就返回结果给浏览器。
    2.3如果缓存中没有对应的IP地址，本地DNS解析器会向根域名服务器发送请求。根域名服务器返回顶级域名服务器的IP地址。
    2.4本地DNS解析器向顶级域名服务器发送请求。顶级域名服务器返回权威域名服务器的IP地址。
    2.5本地DNS解析器向权威域名服务器发送请求。权威域名服务器将域名的IP地址返回给本地DNS解析器。本地DNS解析器把ip地址缓存起来，再将IP地址返回给浏览器。
（3）浏览器检查http缓存。在实际发起请求前，浏览器会检查http缓存，如果浏览器在缓存中找到了有效资源，直接使用缓存内容并跳过后续请求步骤。
（4）建立连接。浏览器与目标服务器建立TCP连接。如果使用HTTPS协议，还需要进行SSL/TLS握手过程，以建立加密的安全通道。
（5）发送请求。浏览器通过建立的连接向服务器发送HTTP请求。请求包括请求方法（如GET、POST）、请求头部（如User-Agent、Accept）、请求体（对于POST请求）等信息。
（6）接收响应。服务器接收到请求后，处理请求并返回HTTP响应。响应包括状态行（包含状态码和状态消息）、响应头部（如Last-Modified、ETag、Cache-Control、Expires）和响应体（包含实际的响应内容）。
 (7)解析响应。浏览器解析响应内容，渲染页面。浏览器会构建dom树、解析css、生成渲染树并绘制页面。
 解析URL：浏览器接收到响应后，会对响应进行解析。它会解析响应内容，并根据内容构建DOM树（文档对象模型）、解析CSS样式信息，生成渲染树，并最终将页面进行绘制显示给用户。
### 5.介绍xss、csrf攻击？
XSS（跨站脚本攻击）是通过在受信任的网页中注入恶意脚本来攻击用户浏览器，以窃取信息或执行恶意操作。
为了防止XSS，应验证和过滤用户输入，确保插入到网页中的内容是安全的。
CSRF（跨站请求伪造）攻击利用用户在登录状态下的身份认证，自动携带cookie来执行未经授权的操作，通过诱使用户访问恶意网页或点击恶意链接来实施攻击。
为了防止CSRF，可以使用CSRF令牌进行身份验证；服务器端给cookie设置sameSite=strict，使得Cookie在跨站请求时不会被发送
### 6.TCP三次握手过程？
（1）客户端向服务器发送一个SYN包，包含随机数x
（2）服务器收到客户端发送的SYN包后，向客户端发送一个SYN-ACK包，包含确认嘛x+1和随机数y
（3）客户端收到服务器的SYN-ACK包后，向服务器发送一个ACK包，包含确认码y+1
### 7.TCP四次挥手过程？
（1）客户端向服务器发送一个FIN包，表述客户端不再发送数据
（2）服务器收到客户端发送的FIN包之后，向客户端发送一个ACK包。
（3）服务器再向客户端发送一个FIN包，表示服务器已经不再发送数据
（4）客户端收到服务器FIN包后，向服务器发送一个ACK包
### 8.说一说网络的模型
有OSI模型和tcp/ip模型
OSI7层模型：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层
tcp/ip模型：
物理层。 蓝牙、wifi、光纤、网线接头
数据链路层。以太网协议、p2p协议
网络层。ip、icmp、arp
传输层。tcp/udp
应用层。http、smtp、ftp、 dns

### 9.说一说tcp和udp的区别
（1）TCP是一种面向连接的协议，通信双方在传输数据之前需要先建立连接，通过三次握手建立可靠的通信通道。UDP是一种无连接的协议，通信双方可以直接发送数据包，无需建立连接。
（2）TCP提供可靠的数据传输。它使用序列号、确认应答和重传机制来确保数据的完整性和可靠性。如果发生丢包或错误，TCP会自动重传数据，保证数据的正确到达。UDP不提供可靠性保证，数据包的发送和接收没有任何确认或重传机制，因此可能会出现丢包或乱序的情况。
（3）TCP保证数据的有序传输，即数据包按照发送的顺序在接收端重新组装。UDP不保证数据包的顺序，接收端接收到的数据包可能以任意顺序到达。
（4）TCP具有拥塞控制机制，它会根据网络的拥塞情况动态调整数据的传输速率，以避免网络拥塞。UDP没有拥塞控制机制，数据包会以恒定的速率发送，无法适应网络拥塞的变化。
（5）TCP的头部相对较大，包含序列号、确认号、窗口大小等信息，用于实现可靠性和顺序性。UDP的头部相对较小，只包含源端口和目标端口等基本信息，因此具有较小的开销。
（6）TCP适用于对数据完整性和可靠性要求较高的应用，如文件传输、电子邮件、网页浏览等。UDP适用于对实时性要求较高的应用，如实时视频、音频通话、在线游戏等，因为UDP具有较低的延迟和较少的开销。

## 框架篇
### 1.介绍一下vue组件通信方法？
（1）Props / $emit：父组件通过Props将数据传递给子组件，子组件可以接收并使用这些数据。子组件可以通过$emit方法触发自定义事件，将数据发送给父组件。这种单向数据流的方式适用于父子组件之间的通信。
（2）$emit / $on：在非父子组件之间进行通信时，可以使用$emit方法触发自定义事件，并在需要接收数据的组件上使用$on监听事件，从而实现组件之间的通信。
（3）$refs：通过在子组件上使用ref属性，父组件可以通过$refs来访问子组件的实例。这样父组件就可以直接调用子组件的方法或访问子组件的数据。
（4）Event Bus：创建一个全局的事件总线，可以使用Vue实例作为中央事件总线，通过$emit触发事件，$on监听事件。任何组件都可以订阅或发布事件，从而实现组件之间的通信。
（5）Vuex：Vuex是Vue的官方状态管理库，适用于中大型应用程序。它通过创建一个全局的状态管理器，将状态集中管理，并提供了一些特定的方法来改变状态，以实现组件之间的通信。
（6）Provide / Inject：通过父组件使用provide来提供数据，然后子组件使用inject来注入这些数据。这种方式可以在祖先组件和后代组件之间建立一种依赖关系，实现跨层级的通信。
项目中有什么印象深刻的问题？
### 2.watch和computed的区别？
watch用于监视数据变化并执行相应操作，适用于异步或复杂逻辑。computed是计算属性，是基于Vue的响应式系统来实现的，基于依赖数据自动更新，适用于同步计算和简单逻辑。
### 3.Vue生命周期，各个周期做了什么？
生命周期是每个组件从创建到销毁的过程中所经历的各个阶段。Vue 组件的生命周期由一系列的生命周期钩子函数组成，这些钩子函数允许开发者在组件的不同阶段执行自定义的逻辑。下面是 Vue 组件的生命周期及其各个阶段的功能：
（1）beforeCreate（创建前）：
此时组件实例尚未创建，无法访问组件中的数据和方法。
（2）created（创建完成）：
可以访问到组件中的数据和方法，但还未挂载到 DOM 上。
（3）beforeMount（挂载前）：
可以进行一些准备工作，但无法访问到组件中的 DOM 元素。
（4）mounted（组件挂载到DOM完成）：
可以访问到组件中的 DOM 元素，执行 DOM 相关的操作，如添加事件监听器、操作 DOM 等。
（5）beforeUpdate（更新前）：
此时组件尚未重新渲染，可以在这里进行状态的保存或准备工作。
（6）updated（更新完成）：
组件已重新渲染，并且 DOM 也已更新。
（7）beforeDestroy（销毁前）：
可以进行一些清理工作，如清除定时器、取消订阅等。
（8）destroyed（销毁完成）：
组件实例已经被销毁，无法访问组件中的数据和方法。
需要注意的是，在 Vue 3 中，Vue 2.x 版本中的 beforeCreate 和 created 钩子函数被合并为一个新的钩子函数 setup，用于设置组件的状态和响应式数据。同时，destroyed 钩子函数被重命名为 unmounted。
### 4.说一说Vue的Object.defineProperty()和proxy的区别？
Vue 2.x 使用 Object.defineProperty()，而 Vue 3.x 使用 Proxy 来实现数据的响应式。Object.defineProperty() 是一个较旧的方法，用于实现对象的属性监测，而 Proxy 是一个更现代、更强大的特性，用于创建对象的代理并拦截操作。
Object.defineProperty() 是 JavaScript 原生提供的一个方法，用于在一个对象上定义一个新的属性或修改现有属性的特性。Vue.js 在 Vue 2.x 版本中使用 Object.definePropert()来实现数据响应式。它通过定义对象的 get 和 set 方法来拦截对属性的访问和修改，从而实现对属性的监测和响应。Object.defineProperty() 有一些限制，例如只能监测对象的属性，不能监测数组的变化，需要深度递归监听对象的每个属性等。
Proxy 是 ES6 引入的一个新特性，它可以用于创建一个代理对象，用于拦截对目标对象的操作。Proxy 提供了丰富的拦截操作方法，如 get、set、deleteProperty、has 等，可以拦截更多类型的操作。Proxy 可以直接监听整个对象以及对象的动态新增和删除，而无需递归监听。Proxy 的性能比 Object.defineProperty() 更好，并且提供了更多的功能和灵活性。
### 5.vue data为什么通过函数返回对象形式进行赋值？
为了确保每个组件实例都有独立的数据对象，而不是共享同一个数据对象。
当一个组件被创建时，data 函数会被调用，返回一个对象，该对象就成为了该组件实例的数据对象。由于每个组件实例都会调用一次 data 函数，因此每个组件实例都会有一个独立的数据对象，互不干扰。
### 6.说一说vue的keepalive？
当 <keep-alive> 包裹一个动态组件时，它会缓存这个组件的实例，而不是销毁它。这意味着当组件切换时，原来的组件实例会保留在内存中，而不是被销毁，以便在下次需要时直接复用，而不
用重新创建和初始化。
### 7.说一说v-if和v-show的区别？
v-if:条件满足时渲染元素，不满足则销毁；执行过程中会创建和销毁DOM节点，适用于条件不经常改变的情况。
v-show：相当于display:none，不会销毁dom节点，适用于频繁切换显示状态的场景。
### 8.说一说vue中的$nextTick？
$nextTick方法接受一个回调函数作为参数，该回调函数会在DOM更新完成后被调用。这个方法可以用于在更新DOM后执行一些操作，例如操作DOM元素、获取更新后的DOM状态或执行其他需要依赖DOM更新后的操作。可以使用这个方法确保再你访问该元素之前，dom已经被更新。

## 浏览器
1.说一说http缓存？
HTTP缓存是一种机制，它允许浏览器或代理服务器在本地保存Web资源的副本，并在下一次请求相同资源时，直接从本地缓存中获取数据，而无需再次向服务器发送请求。
HTTP缓存可以分为两种类型：强缓存和协商缓存。
强缓存（Strong Caching）：在强缓存中，浏览器首先检查缓存中的响应头部信息，如Cache-Control（相对较新。可设置max-age/no cache）和Expires字段。如果没过期，则直接从缓存中获取资源，而无需向服务器发起请求。
协商缓存（Conditional Caching）：如果强缓存未命中，浏览器会向服务器发送请求，并带上缓存相关的头部信息，如If-Modified-Since和If-None-Match。服务器根据这些头部信息来判断资源是否有更新。如果资源未被修改，则服务器返回一个特殊的响应状态码（如304 Not Modified），告诉浏览器可以使用缓存的副本，从而避免了传输完整的资源数据。
通过合理设置缓存策略，可以减少网络传输量、加快页面加载速度，提高用户体验，并减轻服务器的负载。常用的缓存控制字段包括Cache-Control，用于定义缓存的行为和有效期，以及ETag和Last-Modified，用于进行协商缓存判断。通过使用这些机制，可以在满足资源更新需求的同时，最大程度地利用本地缓存，提高Web应用的性能和效率。
2.强缓存触发时会有disk cache和memory cache两种，见过吗？
强缓存是可以被储存在两个地方，磁盘和内存。
磁盘缓存是将缓存数据储存在客户端磁盘上，它可以持久化缓存，即使浏览器关闭也可以使用。内存缓存是将缓存数据存储在客户端内存中，它的优势在于访问速度更快，但是如果内存不足或浏览器关闭，将会丢失，需要重新从服务器获取。。
3.说一下对跨域的理解？
跨域是指浏览器在执行网络请求时，收到同源策略限制，无法直接访问不同源（协议、域名、端口其中之一不同）的资源。