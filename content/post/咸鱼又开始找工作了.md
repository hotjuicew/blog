---
title: "咸鱼又开始找工作了"
date: 2023-05-31T17:36:11+08:00
categories: []
tags: []
---

不努力是不会有回报的。嗯！

## JS篇
1.数组去重有哪些方法？
a.`const newArr=[...new Set(arr)]`
b.`const newArr=filter((value,index,arr)=>return value.indexOf(value)===index)`
c.`const newArr = arr.reduce((unique, item) => {
  return unique.includes(item) ? unique : [...unique, item];
}, []);`
2.深拷贝和浅拷贝的区别？数组深拷贝方法？对象深拷贝方法？
对于引用数据类型来说，比如普通对象、数组、正则，浅拷贝就是拷贝指向它的那个指针，这两个变量共用一块内存空间。深拷贝是重新开辟一块内存，复制对象本身。
数组深拷贝方法：a重新创建一个数组然后遍历赋值 b使用展开运算符 [...originalArray] c使用slice()方法 let newArr=arr.slice()
对象深拷贝方法：a 手动实现递归深拷贝函数 b 使用json序列化和反序列化const newObj=JSON.parse(JSON.stringify(obj)) 缺点是无法复制函数、正则表达式、循环引用 c 引入lodash库 _.deepClone(obj)方法
2.js数据类型有哪些
基本数据类型：Number，String，Boolean,  Null, Undefined,    BigInt,Symbol
引用数据类型：对象（包括普通对象、数组、函数、正则等）
3.获取js变量类型的方法？
a typeof缺点是如果该变量是对象，只能返回Object，不能区分具体类型。例外的是Function会返回Function
b instance of 是判断是否是特定的数据类型的，返回true or false
c Object.prototype.toString.call()可以返回具体的类型
4.说一说promise？
Promise 是 JavaScript 中处理异步操作的一种方式。它是一种代表异步操作最终完成或失败的对象。Promise 对象有三个状态：Pending、Fulfilled和Rejected。通过.then()方法指定成功时的处理函数，通过.catch()方法指定失败时的处理函数。使用 Promise 可以更好地处理异步代码，避免回调地狱。
5.说一说promise.all和promise.race、Promise.allSettled？
都是接收一个由多个Promise对象组成的数组，并返回一个新的Promise对象。这个新的Promise对象

Promise.all 等待所有 Promise 完成，所有的Promise对象都变为resolved状态时才会被resolved，否则只要有一个Promise对象变为rejected状态，它就会被提前终止并返回一个rejected的Promise对象。
Promise.race 只要参数的Promise实例有一个率先改变状态，则状态改变，返回最先解决或拒绝的 Promise 的结果。
Promise.allSettled 等待所有 Promise 完成，并返回一个包含每个 Promise 结果的数组，无论它们是被解决还是被拒绝。与Promise.all不同的是，Promise.allSettled不会提前终止，即使其中某个Promise对象被rejected，它也会等待所有的Promise对象都完成后才返回结果。
6.说一说原型和原型链？instanceof原理？
原型是js每个对象都具有的属性，用于共享属性和方法。每个对象都有一个_proto_属性，指向它的原型对象。（每个构造函数都有一个prototype属性，指向它示例对象的原型对象。）
由于每个对象都有自己的原型，它的原型也有原型，这样就形成了一条原型链。当我们访问一个对象的属性或方法时，js会先查找对象本身是否有该属性或方法，如果没有，它会继续在原型链上向上查找，直到找到或者到达原型链的顶端（即Object.prototype）
A instanceof B是检测对象A是不是B的实例。检测是基于原型链查找的，是找B的prototype有没有在A的原型链上
7.箭头函数有哪些特点？
a 语法简洁 b 如果只有一个表达式的话，会隐式返回，不需手动写return c 箭头函数没有自己的this、arguments、super，而是继承了其外部作用域。这意味着箭头函数内部的this值是由函数定义位置上的外部作用域决定的，而不是在运行时确定的。也无法显式绑定this。
d 由于没有自己的this值，不能使用new来创建对象示例->无法作为构造函数
8.扩展运算符用过吗，什么场景下？
扩展运算符可以取出参数对象中的所以可遍历属性，浅拷贝进当前对象中。
可以用于数组去重（结合Set）、数组拷贝、伪数组转真数组。
9.new操作符都做了哪些事？
a 创建一个空对象
b 设置该对象的原型对象。将新对象的 _Proto_指向构造函数的 prototype 属性
c 将新创建的对象作为this的上下文
d 如果构造函数没有显式返回一个对象，则 new 操作符会隐式返回新创建的对象。
10.说一说js事件循环？
js的任务分为同步任务和异步任务。遇到同步任务就放到执行栈上去执行，遇到异步任务就把它丢给异步模块处理，处理好了的异步任务就会进行任务队列中等待。等到执行栈上的同步任务全部处理完了之后，就进入执行炸中执行。其中，异步任务又分为宏任务和微任务，宏任务包括script标签、setTimeOut、setInterval，微任务包括promise和process.nextTick。对于异步任务来说，事件循环的每个轮次中，首先执行所有的微任务，按照它们被添加到任务队列的顺序依次执行。然后再执行宏任务，如果在执行宏任务的过程中有新的微任务生成，它们会被立即执行，确保微任务优先于下一个宏任务执行。

总结起来，JavaScript 事件循环是一种处理同步和异步任务的机制。同步任务按顺序执行，而异步任务被放入事件循环中，按照微任务优先于宏任务的顺序执行。这种机制确保了js可以处理并发的异步操作。
11.promise.all方法的使用场景？数组中必须每一项都是promise对象吗？不是promise对象会如何处理？
使用场景：并行执行多个异步操作，等待它们全部完成后进行下一步处理。如果数组中有非Promise对象的项，它们将被自动包装为已解决（resolved）的Promise对象。
12.说一说this的指向？
（1）全局上下文：在全局作用域中，this指向全局对象（浏览器中是window对象，Node.js环境中是global对象）。
（2）函数上下文：
a在函数作为对象的方法调用时，this指向调用该方法的对象。
b直接通过函数名来调用时，this指向全局对象（在严格模式下是undefined）。
c用作构造函数，通过new关键字创建了一个新的对象实例
d使用call、apply或bind方法时，可以显式地指定this的值。
（3）箭头函数上下文：箭头函数的this指向其定义时的上下文，而不是调用时的上下文。它捕获了函数定义时所在的作用域的this值。
13.说一说call、apply、bind的作用和区别？
都可以显式改变this的指向。
call、apply会立即执行改变了this指向后的函数并返回指向结果。而bind是返回一个新的函数，不会立即执行。
call和apply的区别是，call的第二个参数及以后是一个个的参数，apply的第二个参数是一个数组
14.let、const、var的区别是什么？什么是块级作用域？
var的作用域是函数作用域，没有块的概念，可以跨块访问，不能跨函数访问。有变量提升。可以重复声明，后面的声明会覆盖前面的声明。
let、const的作用域是块级作用域，没有变量提升，不能重复声明。
let是声明变量，可以重新赋值。const是声明常量，不能重新赋值。
块级作用域是指变量在块（一对花括号{}）内部定义，并且在该块的外部不可访问。
变量提升：js在解析代码的时候，将变量和函数声明提前至作用域顶部
15.说一说js的内存泄露和垃圾回收？
程序中已经释放的堆内存未释放，造成系统资源的浪费。js是一种自动垃圾回收语言，js引擎在运行时会自动回收不再使用的内存。通常使用"标记-清除"算法，该算法会遍历对象的引用关系，并标记所有可达的对象。然后，它会清除未被标记的对象，并回收它们所占用的内存空间。
16.es6新增了哪些东西？
（1）块级作用域与let、const关键字：引入了块级作用域，通过使用let和const关键字声明变量和常量，使得变量的作用域更加清晰并且可以避免变量提升的问题。
（2）箭头函数：提供了更简洁的函数定义语法，箭头函数具有词法作用域和更方便的this绑定。
（3）解构赋值：可以从数组或对象中提取值并赋给变量，使得数据的提取更加便捷。
（4）模板字面量：通过使用反引号（`）创建字符串模板，可以方便地插入变量和执行表达式。
（5）默认参数：函数参数可以设置默认值，简化了函数的调用和定义。
（6）扩展运算符：使用三个点（...）可以将数组或对象展开，使得在函数调用、数组和对象字面量中的使用更加灵活。
（7）类和模块：引入了类的概念，通过class关键字可以更方便地定义对象的结构和行为。同时，也引入了模块的概念，通过import和export可以更好地组织和管理代码。
（8）Promise和异步操作：引入了Promise对象，提供了一种更便捷的处理异步操作的方式，避免了回调地狱的问题
（9）迭代器和生成器：通过迭代器和生成器可以更容易地实现迭代和异步编程模型
（10）新的数据类型和方法：引入了Symbol作为一种新的数据类型，提供了更多的内置方法，如Array.from()、Array.of()、Object.assign()等，方便了开发者的日常工作。
（11）引入了两种数据结构Map和Set。Map是一种键值对的集合，其中每个键都是唯一的，通过键可以获取对应的值。Set是一种存储唯一值的集合，每个值只会出现一次，可以用于去重或存储一组互不重复的值。
17.说一说防抖和节流？
防抖和节流都是用于控制事件的触发频率的。
防抖的原理是在事件触发后等待一段时间，如果在等待时间内再次触发该事件，则重新计时。只有在等待时间结束后，事件没有再次触发，才会执行相应的处理函数。
怎么实现：使用setTimeout函数设置一个等待时间，在等待时间内再次触发函数调用时，会先清除之前的定时器。用闭包来保存定时器的状态。
应用：实时搜索框
节流的原理是规定一个时间间隔，在这个时间间隔内，只能触发一次函数调用。如果在时间间隔内多次触发函数调用，只有第一次会执行，其余的触发会被忽略。
实现：使用时间戳来控制函数的执行时间，当两次函数调用时，之间的时间间隔大于设定的时间间隔时，才执行被节流的函数，并且更新时间戳为now
应用：频繁点击按钮
18.说一说js的导入导出模块方式？
模块是一种封装和复用代码的方式。主要有两种方式。
CommonJS使用require和module.exports来导入和导出模块
es6使用import和export来导入导出模块
19.ajax、axios、fetch的区别？
ajax是一种计数统称，主要利用XHR实现异步通信，它很重要的特性之一就是让页面实现局部刷新。
axios基于promise的http库，提供简洁的API和拦截器，易于使用
fetch是原生的http请求api，基于promise，简洁易用。但在老的浏览器中需使用polyfill。
20.数组常用方法
push、pop、shift、unshift、splice、sort、concat、join
21.map()和foreach的区别？
map()方法接收一个处理数组元素的回调函数，会返回一个新数组。
foreach也是接收一个回调函数，但它没有返回值，只是遍历一遍数组，也不会改变原数组。

## 网络篇
1.说一说http请求的方法有哪些？
GET：向服务器请求资源，可以在请求中传递参数，但参数会附加在 URL 中。
POST：向服务器创建新的资源。POST 请求的数据会包含在请求体中，而不是附加在URL上。
PUT：向服务器更新资源，通常用于替换整个资源。PUT 请求的数据会包含在请求体中，并用于完全替换指定的资源。
PATCH：用于向服务器部分更新资源，通常用于更新资源的一部分。PATCH 请求的数据会包含在请求体中，但只包含需要更新的字段。
DELETE：用于从服务器删除资源。DELETE 请求用于删除指定的资源。
HEAD：类似于 GET 请求，但只返回响应头信息，不返回响应体。通常用于获取资源的元数据，如内容类型、大小等。
2.浏览器本地储存的方式？
浏览器本地存储的方式有以下三种：
Cookies：Cookies 是浏览器中最古老和最常见的本地存储方式。它们是由服务器发送到浏览器，并存储在用户的计算机上的小型文本文件。Cookies 可以用于存储有限量的数据，Cookies在后续的请求中会被自动发送给服务器。但是 Cookies 的大小有限制，并且会随着每个请求的传输，对网络性能产生一定的影响。
Web Storage（Web 存储）：Web Storage 提供了一种在浏览器中存储键值对数据的机制，分为 sessionStorage 和 localStorage 两种。sessionStorage 用于在浏览器窗口关闭前存储数据，而localStorage则是一直保持数据，直到被手动清除。Web Storage 是基于域名的，每个域名有独立的存储空间，并且可以存储更大量的数据（一般是 5MB 或更多）。
IndexedDB：IndexedDB 是一个功能强大的客户端数据库，可在浏览器中存储结构化数据。它支持事务操作和索引，可以存储大量数据，并提供灵活的查询功能。
3.说一说http状态码？
http状态码表示http请求的处理结果。
2xx 成功：
200 OK：请求成功，服务器成功处理了请求并返回相应的内容。
201 Created：请求成功并且服务器创建了新的资源。
204 No Content：请求成功，但服务器没有返回任何内容。

3xx 重定向：
301 Moved Permanently：资源的 URL 已永久移动到新位置。
302 Found：资源的 URL 暂时移动到新位置。
304 Not Modified：客户端缓存的资源是最新的，无需重新获取。

4xx 客户端错误：
400 Bad Request：请求存在语法错误，服务器无法理解。
401 Unauthorized：请求需要用户身份验证。
404 Not Found：请求的资源不存在。

5xx 服务器错误：
500 Internal Server Error：服务器在处理请求时发生了错误。
503 Service Unavailable：服务器暂时无法处理请求，通常是由于过载或维护等原因。

4.url输入浏览器发生了什么？
（1）解析url。浏览器检查是否合法，确定协议域名端口路径等信息，
（2）DNS解析。浏览器根据域名解析DNS查询，以获取目标服务器的ip地址。
具体流程：
    2.1浏览器首先查找自身的DNS缓存，如果找到了对应的IP地址，就直接使用缓存结果。
    2.2如果浏览器的DNS缓存中没有对应的IP地址，浏览器发送域名查询请求到本地DNS解析器（isp或路由器）。本地DNS解析器检查自己的缓存，如果找到了对应的IP地址，就返回结果给浏览器。
    2.3如果缓存中没有对应的IP地址，本地DNS解析器会向根域名服务器发送请求。根域名服务器返回顶级域名服务器的IP地址。
    2.4本地DNS解析器向顶级域名服务器发送请求。顶级域名服务器返回权威域名服务器的IP地址。
    2.5本地DNS解析器向权威域名服务器发送请求。权威域名服务器将域名的IP地址返回给本地DNS解析器。本地DNS解析器把ip地址缓存起来，再将IP地址返回给浏览器。
（3）浏览器检查http缓存。在实际发起请求前，浏览器会检查http缓存，如果浏览器在缓存中找到了有效资源，直接使用缓存内容并跳过后续请求步骤。
（4）建立连接。浏览器与目标服务器建立TCP连接。如果使用HTTPS协议，还需要进行SSL/TLS握手过程，以建立加密的安全通道。
（5）发送请求。浏览器通过建立的连接向服务器发送HTTP请求。请求包括请求方法（如GET、POST）、请求头部（如User-Agent、Accept）、请求体（对于POST请求）等信息。
（6）接收响应。服务器接收到请求后，处理请求并返回HTTP响应。响应包括状态行（包含状态码和状态消息）、响应头部（如Last-Modified、ETag、Cache-Control、Expires）和响应体（包含实际的响应内容）。
 (7)解析响应。浏览器解析响应内容，渲染页面。浏览器会构建dom树、解析css、生成渲染树并绘制页面。
 解析URL：浏览器接收到响应后，会对响应进行解析。它会解析响应内容，并根据内容构建DOM树（文档对象模型）、解析CSS样式信息，生成渲染树，并最终将页面进行绘制显示给用户。
5.介绍xss、csrf攻击？
XSS（跨站脚本攻击）是通过在受信任的网页中注入恶意脚本来攻击用户浏览器，以窃取信息或执行恶意操作。
为了防止XSS，应验证和过滤用户输入，确保插入到网页中的内容是安全的。
CSRF（跨站请求伪造）攻击利用用户在登录状态下的身份认证，自动携带cookie来执行未经授权的操作，通过诱使用户访问恶意网页或点击恶意链接来实施攻击。
为了防止CSRF，可以使用CSRF令牌进行身份验证；服务器端给cookie设置sameSite=strict，使得Cookie在跨站请求时不会被发送
6.TCP三次握手过程？
（1）客户端向服务器发送一个SYN包，包含随机数x
（2）服务器收到客户端发送的SYN包后，向客户端发送一个SYN-ACK包，包含确认嘛x+1和随机数y
（3）客户端收到服务器的SYN-ACK包后，向服务器发送一个ACK包，包含确认码y+1
7.TCP四次挥手过程？
（1）客户端向服务器发送一个FIN包，表述客户端不再发送数据
（2）服务器收到客户端发送的FIN包之后，向客户端发送一个ACK包。
（3）服务器再向客户端发送一个FIN包，表示服务器已经不再发送数据
（4）客户端收到服务器FIN包后，向服务器发送一个ACK包
8.说一说网络的模型
有OSI模型和tcp/ip模型

