---
title: "又开始找工作了"
date: 2021-05-31T17:36:11+08:00
categories: ['面试']
---

## 个人篇
### 自我介绍 
面试官你好，我叫xxx。我是杭州电子科技大学一名应届毕业生，专业是计算机科学与技术（第二学士学位），第一个学位是会计学。我对前端开发领域比较感兴趣，希望作为我的未来发展方向。我熟悉前端三件套，熟悉Vue框架，并且热爱探索新的技术和工具。此外，我还具备一定的后端技能，了解Python、Java等后端语言，会使用数据库，并了解docker容器技术。实习过程使我更熟悉Git版本管理，也锻炼了我的团队合作能力和沟通能力。以上是我的自我介绍，谢谢。

**为什么会计转计算机？**

1.大学后期发现感兴趣，喜欢尝试新的技术和解决问题，所以想要将其作为自己的职业方向。
2.相比与财务处理，利用自己的技术技能来构建具有实际意义的应用程序和网站，实现更直观和有趣的用户体验。
3.我校it氛围浓厚的学校

**为什么选择前端，前端工作有什么目标，未来规划？**
为什么选择前端:直观、有成果，美观页面，成就感
未来规划: 1年内工作技术栈;后续全栈，并在前端和后端方面都有所涉猎，也可以说明自己希望在前端领域取得更高的成就，并在前端领域有更大的影响力。
### 之前公司的项目
是一个景区管理系统，是给景区和景区内部的各个公司使用的。比如说以景区的身份登录，就可以看到组织架构(杭州文旅片区、安徽文旅片区这种，还可以看他们的业务餐饮、组合、客房、门票这些)，有预定、产品、订单、档案、会员、账务、渠道、会员等。还可以以景区内部集团下的公司登录，我做了产品类别、渠道订单、租户管理、角色管理等。

**你主要做了什么？**
做了一些bug列表的修复和页面和模块的开发，比如说
- 产品类别模块：我负责设计和实现了景区内部产品分类的功能模块。通过该模块，景区可以按照不同的产品类型对其进行分类和管理，以便更好地组织和展示各类产品信息。，实现了产品的添加、编辑、删除和查询等功能。
- 渠道订单模块：我参与了渠道订单模块的开发工作。该模块主要用于管理景区从各个渠道接收的订单信息。我负责与后端团队协作，设计并实现了订单管理的前端界面，包括订单列表的展示、订单状态的更新以及订单详细信息的查看等功能。
- 租户管理模块：我承担了租户管理模块的设计和实现。该模块用于管理景区内部不同的租户，包括商户、合作伙伴等。实现了租户的创建、编辑和权限管理等功能。
- 角色管理模块：我参与了角色管理模块的开发。该模块用于管理系统内不同角色的权限和访问控制。我负责实现了角色管理的前端界面，包括角色的创建、编辑和权限分配等功能。
**你有什么印象深刻的bug？**
一般的bug有样式上的，还有网络请求的时间节点，比如说点击了某处再请求，不要一起请求。还有一些用户提示的细节，比如说要实现用户在对表单做了更改之后，他再再选择关闭页面，需要有一个提示。
**追问：你是怎么实现的？**
哦我是利用watch来实现的，具体监听的value是整个表单对象（深度监听）
### 介绍一个印象比较深刻的项目或者功能需求
- 在这个项目中，我负责开发租户管理页面，实现了新增、编辑、删除和查询租户的功能。在实现这些功能时，我遇到了一个比较有挑战性的需求，就是在新增租户时需要上传一些附件，如租户证件照片等，这些附件需要在提交表单前进行预览和验证。但是发现element ui对上传组件的校验是不会自动触发的。只有在点保存时，手动调用表单的validate方法才会触发绑定在upload组件上的rules。那如何解决在fileList有改变时自动触发校验呢？我个人想了一个比较简单省事的方法，在upload的on-change钩子函数中，手动填充校验错误信息。**

- 我在实现i18n时学习了如何在Nuxt.js中配置国际化，例如路由。我学习了如何在Nuxt.js应用程序中使用vue-i18n进行国际化，并且了解了如何配置路由来支持多语言。这个过程中，我了解了如何定义不同语言的路由路径，以便在应用程序中使用不同的语言进行导航。
#### 请说说你对响应式设计的理解，以及如何在移动端进行自适应布局？

   响应式设计是一种基于不同设备屏幕大小和分辨率进行自适应的设计方法。在移动端进行自适应布局可以采用以下方法：

   - 使用百分比或者vw/vh作为布局单位，而不是固定的像素值。
   - 使用CSS媒体查询（@media）来针对不同的屏幕大小和分辨率设置不同的样式。
   - 使用流式布局来适应不同的屏幕大小，例如Flex布局和Grid布局。
   - 使用第三方CSS框架来进行移动端适配，例如Bootstrap和Ant Design Mobile等。

### 3.你认为前端性能优化的方法有哪些？请举例说明。
- 图像优化 服务器那边可以压缩图片大小。使用懒加载技术，延迟加载图像直到它们进入视口。
  （图片懒加载：暂时不设置图片的src属性，而是将图片的url隐藏起来，比如先写在data-src里面，等到了可视区域再将图片真实的url放进 src 属性里面）
- 减少HTTP请求，例如合并CSS和JavaScript文件，使用雪碧图来减少图片请求等。使用字体图标或矢量图形替代图像，减少图像请求。
- 压缩文件大小，例如使用压缩算法来减少HTML、CSS和JavaScript文件的大小。
- 使用[浏览器缓存](https://add1.dev/post/%E5%92%B8%E9%B1%BC%E5%8F%88%E5%BC%80%E5%A7%8B%E6%89%BE%E5%B7%A5%E4%BD%9C%E4%BA%86#1%E8%AF%B4%E4%B8%80%E8%AF%B4http%E7%BC%93%E5%AD%98)，例如设置合适的Expires头信息，使用Etag等。
- 减少不必要的 DOM 操作，尽量减少重绘和重排。
  (重排：页面DOM元素的布局/位置发生变化，需要重新排列元素位置。重绘：页面DOM元素的样式发生变化，需要重新绘制元素图层。)
使用节流和防抖技术来优化事件处理程序。
- 使用CDN来加速静态资源的加载，例如使用Google、Cloudflare、阿里云等CDN服务。

## git
### 常用git命令
git init 创建仓库 git clone 克隆到本地
git status 查看仓库状态
git checkout -b创建分支并切换到该分支
git add 将添加的文件放到暂存区
git commit 提交到本地仓库 git reset HEAD~撤销本次提交，并将更改保留
git pull 拉去最新代码并合并到当前分支，使得本地仓库和远程仓库保持同步
git fetch: 获取远程仓库的最新更改，但不进行合并。
git merge: 将指定分支的更改合并到当前分支。

git push将本地仓库改动提交到远程
git reset回滚版本 git revert 反做

### 如何将两个提交合并成一个？
（只能针对于没有push到远程仓库的提交）
首先，使用以下命令查看提交历史，确定要合并的两个提交的哈希值：
git log

然后 git rebase -i <commit1>
其中，<commit1>是第一个要合并的提交的哈希值。这将打开一个交互式界面，列出了从该提交以来的所有提交。

在交互式界面中，找到第二个要合并的提交，将其前面的命令由 "pick" 改为 "squash" 或 "s"。这将将该提交合并到前一个提交中。

## 网络篇
### 1.说一说http请求的方法有哪些？
- GET：向服务器请求资源，可以在请求中传递参数，但参数会附加在 URL 中。
- POST：向服务器创建新的资源。POST 请求的数据会包含在请求体中，而不是附加在URL上。
- PUT：向服务器更新资源，通常用于替换整个资源。PUT 请求的数据会包含在请求体中，并用于完全替换指定的资源。
- PATCH：用于向服务器部分更新资源，通常用于更新资源的一部分。PATCH 请求的数据会包含在请求体中，但只包含需要更新的字段。
- DELETE：用于从服务器删除资源。DELETE 请求用于删除指定的资源。
- HEAD：类似于 GET 请求，但只返回响应头信息，不返回响应体。通常用于获取资源的元数据，如内容类型、大小等。
### 2.浏览器本地储存的方式？
浏览器本地存储的方式有以下三种：
- Cookies：Cookies 是浏览器中最古老和最常见的本地存储方式。它们是由服务器发送到浏览器，并存储在用户的计算机上的小型文本文件。Cookies 可以用于存储有限量的数据，Cookies在后续的请求中会被自动发送给服务器。但是 Cookies 的大小有限制，并且会随着每个请求的传输，对网络性能产生一定的影响。
- Web Storage（Web 存储）：Web Storage 提供了一种在浏览器中存储键值对数据的机制，分为 sessionStorage 和 localStorage 两种。sessionStorage 用于在浏览器窗口关闭前存储数据，而localStorage则是一直保持数据，直到被手动清除。Web Storage 是基于域名的，每个域名有独立的存储空间，并且可以存储更大量的数据（一般是 5MB 或更多）。
- IndexedDB：IndexedDB 是一个功能强大的客户端数据库，可在浏览器中存储结构化数据。它支持事务操作和索引，可以存储大量数据，并提供灵活的查询功能。
### 3.说一说http状态码？
http状态码表示http请求的处理结果。
- 2xx 成功：
200 OK：请求成功，服务器成功处理了请求并返回相应的内容。
201 Created：请求成功并且服务器创建了新的资源。
204 No Content：请求成功，但服务器没有返回任何内容。

- 3xx 重定向：
301 Moved Permanently：资源的 URL 已永久移动到新位置。
302 Found：资源的 URL 暂时移动到新位置。
304 Not Modified：客户端缓存的资源是最新的，无需重新获取。

- 4xx 客户端错误：
400 Bad Request：请求存在语法错误，服务器无法理解。
401 Unauthorized：请求需要用户身份验证。
404 Not Found：请求的资源不存在。

- 5xx 服务器错误：
500 Internal Server Error：服务器在处理请求时发生了错误。
503 Service Unavailable：服务器暂时无法处理请求，通常是由于过载或维护等原因。

### 4.url输入浏览器发生了什么？
- （1）解析url。浏览器检查是否合法，确定协议域名端口路径等信息，
- （2）DNS解析。浏览器根据域名解析DNS查询，以获取目标服务器的ip地址。
    具体流程：
    2.1浏览器首先查找自身的DNS缓存，如果找到了对应的IP地址，就直接使用缓存结果。
    2.2如果浏览器的DNS缓存中没有对应的IP地址，浏览器发送域名查询请求到本地DNS解析器（isp或路由器）。本地DNS解析器检查自己的缓存，如果找到了对应的IP地址，就返回结果给浏览器。
    2.3如果缓存中没有对应的IP地址，本地DNS解析器会向根域名服务器发送请求。根域名服务器返回顶级域名服务器的IP地址。
    2.4本地DNS解析器向顶级域名服务器发送请求。顶级域名服务器返回权威域名服务器的IP地址。
    2.5本地DNS解析器向权威域名服务器发送请求。权威域名服务器将域名的IP地址返回给本地DNS解析器。本地DNS解析器把ip地址缓存起来，再将IP地址返回给浏览器。
- （3）浏览器检查http缓存。在实际发起请求前，浏览器会检查http缓存，如果浏览器在缓存中找到了有效资源，直接使用缓存内容并跳过后续请求步骤。
- （4）建立连接。浏览器与目标服务器建立TCP连接。如果使用HTTPS协议，还需要进行SSL/TLS握手过程，以建立加密的安全通道。
- （5）发送请求。浏览器通过建立的连接向服务器发送HTTP请求。请求包括请求方法（如GET、POST）、请求头部（如User-Agent、Accept）、请求体（对于POST请求）等信息。
- （6）接收响应。服务器接收到请求后，处理请求并返回HTTP响应。响应包括状态行（包含状态码和状态消息）、响应头部（如Last-Modified、ETag、Cache-Control、Expires）和响应体（包含实际的响应内容）。
 - (7)解析响应。浏览器解析响应内容，渲染页面。浏览器会构建dom树、解析css、生成渲染树并绘制页面。

### 5.介绍xss、csrf攻击？
- XSS（跨站脚本攻击）是通过在受信任的网页中注入恶意脚本来攻击用户浏览器，以窃取信息或执行恶意操作。
为了防止XSS，应验证和过滤用户输入，确保插入到网页中的内容是安全的。
- CSRF（跨站请求伪造）攻击利用用户在登录状态下的身份认证，自动携带cookie来执行未经授权的操作，通过诱使用户访问恶意网页或点击恶意链接来实施攻击。
为了防止CSRF，可以使用CSRF令牌进行身份验证；服务器端给cookie设置sameSite=strict，使得Cookie在跨站请求时不会被发送
### 6.TCP三次握手过程？
- （1）客户端向服务器发送一个SYN包，包含随机数x
- （2）服务器收到客户端发送的SYN包后，向客户端发送一个SYN-ACK包，包含确认嘛x+1和随机数y
- （3）客户端收到服务器的SYN-ACK包后，向服务器发送一个ACK包，包含确认码y+1
### 7.TCP四次挥手过程？
- （1）客户端向服务器发送一个FIN包，表述客户端不再发送数据
- （2）服务器收到客户端发送的FIN包之后，向客户端发送一个ACK包。
- （3）服务器再向客户端发送一个FIN包，表示服务器已经不再发送数据
- （4）客户端收到服务器FIN包后，向服务器发送一个ACK包
### 8.说一说网络的模型
有OSI模型和tcp/ip模型
- OSI7层模型：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层
其中，物理层负责比特流，链路层负责传输帧，网络层负责数据包的路由和转发，传输层负责数据的可靠传输，会话层负责建立和维护会话，表示层负责数据格式的转换，应用层负责应用程序间的通信。
- tcp/ip模型：
物理层。 蓝牙、wifi、光纤、网线接头
数据链路层。以太网协议、p2p协议
网络层。ip、icmp、arp
传输层。tcp/udp
应用层。http、smtp、ftp、 dns

### 9.说一说tcp和udp的区别
- （1）TCP是一种面向连接的协议，通信双方在传输数据之前需要先建立连接，通过三次握手建立可靠的通信通道。UDP是一种无连接的协议，通信双方可以直接发送数据包，无需建立连接。
- （2）TCP提供可靠的数据传输。它使用序列号、确认应答和重传机制来确保数据的完整性和可靠性。如果发生丢包或错误，TCP会自动重传数据，保证数据的正确到达。UDP不提供可靠性保证，数据包的发送和接收没有任何确认或重传机制，因此可能会出现丢包或乱序的情况。
- （3）TCP保证数据的有序传输，即数据包按照发送的顺序在接收端重新组装。UDP不保证数据包的顺序，接收端接收到的数据包可能以任意顺序到达。
- （4）TCP具有拥塞控制机制，它会根据网络的拥塞情况动态调整数据的传输速率，以避免网络拥塞。UDP没有拥塞控制机制，数据包会以恒定的速率发送，无法适应网络拥塞的变化。
- （5）TCP的头部相对较大，包含序列号、确认号、窗口大小等信息，用于实现可靠性和顺序性。UDP的头部相对较小，只包含源端口和目标端口等基本信息，因此具有较小的开销。
- （6）TCP适用于对数据完整性和可靠性要求较高的应用，如文件传输、电子邮件、网页浏览等。UDP适用于对实时性要求较高的应用，如实时视频、音频通话、在线游戏等，因为UDP具有较低的延迟和较少的开销。

## 框架篇
### 1.介绍一下vue组件通信方法？
- （1）Props / $emit：父组件通过Props将数据传递给子组件，子组件可以接收并使用这些数据。子组件可以通过$emit方法触发自定义事件，将数据发送给父组件。这种单向数据流的方式适用于父子组件之间的通信。
- （2）$emit / $on：在非父子组件之间进行通信时，可以使用$emit方法触发自定义事件，并在需要接收数据的组件上使用$on监听事件，从而实现组件之间的通信。
- （3）$refs：通过在子组件上使用ref属性，父组件可以通过$refs来访问子组件的实例。这样父组件就可以直接调用子组件的方法或访问子组件的数据。
- （4）Event Bus：创建一个全局的事件总线，可以使用Vue实例作为中央事件总线，通过$emit触发事件，$on监听事件。任何组件都可以订阅或发布事件，从而实现组件之间的通信。
- （5）Vuex：Vuex是Vue的官方状态管理库，适用于中大型应用程序。它通过创建一个全局的状态管理器，将状态集中管理，并提供了一些特定的方法来改变状态，以实现组件之间的通信。
- （6）Provide / Inject：通过父组件使用provide来提供数据，然后子组件使用inject来注入这些数据。这种方式可以在祖先组件和后代组件之间建立一种依赖关系，实现跨层级的通信。

### 2.watch和computed的区别？
- watch用于监视数据变化并执行相应操作，适用于异步或复杂逻辑。
- computed是计算属性，是基于Vue的响应式系统来实现的，基于依赖数据自动更新，适用于同步计算和简单逻辑。
### 3.Vue生命周期，各个周期做了什么？
生命周期是每个组件从创建到销毁的过程中所经历的各个阶段。Vue 组件的生命周期由一系列的生命周期钩子函数组成，这些钩子函数允许开发者在组件的不同阶段执行自定义的逻辑。下面是 Vue 组件的生命周期及其各个阶段的功能：
- （1）beforeCreate（创建前）：
此时组件实例尚未创建，无法访问组件中的数据和方法。
- （2）created（创建完成）：
可以访问到组件中的数据和方法，但还未挂载到 DOM 上。
- （3）beforeMount（挂载前）：
可以进行一些准备工作，但无法访问到组件中的 DOM 元素。
- （4）mounted（组件挂载到DOM完成）：
可以访问到组件中的 DOM 元素，执行 DOM 相关的操作，如添加事件监听器、操作 DOM 等。
- （5）beforeUpdate（更新前）：
此时组件尚未重新渲染，可以在这里进行状态的保存或准备工作。
- （6）updated（更新完成）：
组件已重新渲染，并且 DOM 也已更新。
- （7）beforeDestroy（销毁前）：
可以进行一些清理工作，如清除定时器、取消订阅等。
- （8）destroyed（销毁完成）：
组件实例已经被销毁，无法访问组件中的数据和方法。
需要注意的是，在 Vue 3 中，Vue 2.x 版本中的 beforeCreate 和 created 钩子函数被合并为一个新的钩子函数 setup，用于设置组件的状态和响应式数据。同时，destroyed 钩子函数被重命名为 unmounted。
### 4.说一说Vue的Object.defineProperty()和proxy的区别？
Vue响应式指的是：组件的data发生变化，立刻触发视图的更新

- Vue 2.x 使用 Object.defineProperty()，而 Vue 3.x 使用 Proxy 来实现数据的响应式。Object.defineProperty() 是一个较旧的方法，用于实现对象的属性监测，而 Proxy 是一个更现代、更强大的特性，用于创建对象的代理并拦截操作。

- Object.defineProperty() 是 JavaScript 原生提供的一个方法，用于在一个对象上定义一个新的属性或修改现有属性的特性。Vue.js 在 Vue 2.x 版本中使用 Object.definePropert()来实现数据响应式。它通过定义对象的 get 和 set 方法来拦截对属性的访问和修改，从而实现对属性的监测和响应。Object.defineProperty() 有一些限制，例如只能监测对象的属性，不能监测数组的变化，需要深度递归监听对象的每个属性等。

- Proxy 是 ES6 引入的一个新特性，它可以用于创建一个代理对象，用于拦截对目标对象的操作。Proxy 提供了丰富的拦截操作方法，如 get、set、deleteProperty、has 等，可以拦截更多类型的操作。Proxy 可以直接监听整个对象以及对象的动态新增和删除，而无需递归监听。Proxy 的性能比 Object.defineProperty() 更好，并且提供了更多的功能和灵活性。

### 5.vue data为什么通过函数返回对象形式进行赋值？
- 为了确保每个组件实例都有独立的数据对象，而不是共享同一个数据对象。
- 当一个组件被创建时，data 函数会被调用，返回一个对象，该对象就成为了该组件实例的数据对象。由于每个组件实例都会调用一次 data 函数，因此每个组件实例都会有一个独立的数据对象，互不干扰。

### 6.说一说vue的keepalive？
当 <keep-alive> 包裹一个动态组件时，它会缓存这个组件的实例，而不是销毁它。
这意味着当组件切换时，原来的组件实例会保留在内存中，而不是被销毁，以便在下次需要时直接复用，而不用重新创建和初始化。
### 7.说一说v-if和v-show的区别？
- v-if:条件满足时渲染元素，不满足则销毁；执行过程中会创建和销毁DOM节点，适用于条件不经常改变的情况。
- v-show：相当于display:none，不会销毁dom节点，适用于频繁切换显示状态的场景。
### 8.说一说vue中的$nextTick？
$nextTick方法接受一个回调函数作为参数，该回调函数会在DOM更新完成后被调用。这个方法可以用于在更新DOM后执行一些操作，例如操作DOM元素、获取更新后的DOM状态或执行其他需要依赖DOM更新后的操作。可以使用这个方法确保再你访问该元素之前，dom已经被更新。

### 9.说一说vuex
Vuex是状态管理的库。
vuex有几个重要的属性
- 使用state选项定义应用的状态数据，可以在全局访问。
- 使用mutations选项定义修改状态的方法，通过提交commit来调用mutations。
- 使用actions选项定义异步操作或批量的状态修改方法，通过分发dispatch来调用actions。
- 使用getters选项定义派生状态的方法，可以根据需要对状态进行计算和转换。
  
pinia更适合写vue3，vuex更适合写vue2。Pinia是基于Vue 3的Composition API设计的，与其相互配合使用，可以更好地利用Composition API的优势。而Vuex是为Vue 2设计的，使用的是对象风格的API，与Vue 2的Options API更为兼容。
Vuex是一个全局的状态管理库，它只有一个单一的store用于管理应用程序的状态。而Pinia则允许您在应用程序中创建多个独立的store。每个store都可以包含自己的状态、actions和getters，使得状态的组织和管理更加模块化和灵活。
pinia 取消了原有的 mutations，合并成了 actions，且我们在取值的时候可以直接点到那个值，而不需要在.state，方法也是如此。
## 浏览器
### 1.说一说http缓存？
- HTTP缓存是一种机制，它允许浏览器或代理服务器在本地保存Web资源的副本，并在下一次请求相同资源时，直接从本地缓存中获取数据，而无需再次向服务器发送请求。
  
HTTP缓存可以分为两种类型：强缓存和协商缓存。
- 强缓存（Strong Caching）：在强缓存中，浏览器首先检查缓存中的响应头部信息，如Cache-Control（相对较新。可设置max-age/no cache）和Expires字段。如果没过期，则直接从缓存中获取资源，而无需向服务器发起请求。
- 协商缓存（Conditional Caching）：如果强缓存未命中，浏览器会向服务器发送请求，并带上缓存相关的头部信息，如If-Modified-Since和If-None-Match。服务器根据这些头部信息来判断资源是否有更新。如果资源未被修改，则服务器返回一个特殊的响应状态码（如304 Not Modified），告诉浏览器可以使用缓存的副本，从而避免了传输完整的资源数据。
  
通过合理设置缓存策略，可以减少网络传输量、加快页面加载速度，提高用户体验，并减轻服务器的负载。常用的缓存控制字段包括Cache-Control，用于定义缓存的行为和有效期，以及ETag和Last-Modified，用于进行协商缓存判断。通过使用这些机制，可以在满足资源更新需求的同时，最大程度地利用本地缓存，提高Web应用的性能和效率。
### 2.强缓存触发时会有disk cache和memory cache两种，见过吗？
强缓存是可以被储存在两个地方，磁盘和内存。
- 磁盘缓存是将缓存数据储存在客户端磁盘上，它可以持久化缓存，即使浏览器关闭也可以使用。
- 内存缓存是将缓存数据存储在客户端内存中，它的优势在于访问速度更快，但是如果内存不足或浏览器关闭，将会丢失，需要重新从服务器获取。。
3.说一下对跨域的理解？
跨域是指浏览器在执行网络请求时，收到同源策略限制，无法直接访问不同源（协议、域名、端口其中之一不同）的资源。
常见的跨域解决方案：
（1）CORS：在服务器端设置响应头，允许特定的跨域请求，设置Access-Control-Allow-Origin: https://example.com
（2）JSONP（JSON with Padding）：JSONP 是一种在客户端实现的跨域技术。它利用了 <script> 标签不受同源策略的限制，发送跨域请求。只支持get请求。
（3）代理服务器：客户端通过向同源服务器发送请求，然后同源服务器再将请求发送到目标服务器，获取数据后再返回给客户端。这种方式需要在同源服务器上设置代理，将跨域请求转发到目标服务器。具体实现方式可以使用中间件或反向代理工具，如 Node.js 中的 Express 中间件或 Nginx 反向代理配置。
（4）WebSocket：WebSocket 是一种双向通信协议，可以在不同域之间建立持久的连接。由于 WebSocket 是通过 HTTP 协议进行握手后建立连接，之后转换为独立的协议进行通信，因此它可以绕过浏览器的同源策略。
在客户端使用 JavaScript 建立 WebSocket 连接，在服务器端处理 WebSocket 连接请求，以进行实时的双向通信。
### 4.说说浏览器是如何渲染页面的？
（1）解析HTML，生成DOM树
（2）解析CSS，生成CSSOM树
（3）两棵树结合，生成render树
（4）计算布局，绘制页面的所有节点
（5）绘制布局
### 5.说一说hashrouter和histodyrouter的区别和原理？
HistoryRouter使用 HTML5 提供的 History API来实现的（pushState将新的状态添加到浏览器的历史记录栈；replaceState用新的状态替换当前的历史记录项），HashRouter是监听#符号后的内容来进行实现。

区别：
（1）history的url没有#号，hash有#号
（2）HistoryRouter 需要后端服务器的支持，因为它修改了真实的 URL 路径，需要服务器根据路径返回对应的 HTML 页面。而 HashRouter 不需要后端服务器的支持，因为它使用 URL 中的哈希部分进行路由切换，哈希部分不会发送到服务器，服务器只需返回一个主 HTML 页面。
（3）history会触发添加到浏览器的历史记录栈中，hash不会触发


## JS篇
### computed和watch的区别？
computed 是计算属性，watch是监听器，监听某个数据发生变化，然后执行一些操作。
Computed 更适合处理基于已有数据的计算值，它可以自动缓存和更新，而 Watch 更适合用于监听某些需要手动处理的数据变化，它可以在数据变化时触发一些额外的操作。
### 1.数组去重有哪些方法？
a.`const newArr=[...new Set(arr)]`
b.`const newArr=filter((value,index,arr)=>return value.indexOf(value)===index)`
c.`const newArr = arr.reduce((unique, item) => {
  return unique.includes(item) ? unique : [...unique, item];
}, []);`
### 2.深拷贝和浅拷贝的区别？数组深拷贝方法？对象深拷贝方法？
对于引用数据类型来说，比如普通对象、数组、正则，浅拷贝就是拷贝指向它的那个指针，这两个变量共用一块内存空间。深拷贝是重新开辟一块内存，复制对象本身。
数组深拷贝方法：a重新创建一个数组然后遍历赋值 b使用展开运算符 [...originalArray] c使用slice()方法 let newArr=arr.slice()
对象深拷贝方法：a 手动实现递归深拷贝函数 b 使用json序列化和反序列化const newObj=JSON.parse(JSON.stringify(obj)) 缺点是无法复制函数、正则表达式、循环引用 c 引入lodash库 _.deepClone(obj)方法
### 2.js数据类型有哪些
基本数据类型：Number，String，Boolean,  Null, Undefined,    BigInt,Symbol
引用数据类型：对象（包括普通对象、数组、函数、正则等）
### 3.获取js变量类型的方法？
a typeof缺点是如果该变量是对象，只能返回Object，不能区分具体类型。例外的是Function会返回Function
b instance of 是判断是否是特定的数据类型的，返回true or false
c Object.prototype.toString.call()可以返回具体的类型
### 4.说一说promise？
Promise 是 JavaScript 中处理异步操作的一种方式。它是一种代表异步操作最终完成或失败的对象。Promise 对象有三个状态：Pending、Fulfilled和Rejected。通过.then()方法指定成功时的处理函数，通过.catch()方法指定失败时的处理函数。使用 Promise 可以更好地处理异步代码，避免回调地狱。
### 5.说一说promise.all和promise.race、Promise.allSettled？
都是接收一个由多个Promise对象组成的数组，并返回一个新的Promise对象。这个新的Promise对象

Promise.all 等待所有 Promise 完成，所有的Promise对象都变为resolved状态时才会被resolved，否则只要有一个Promise对象变为rejected状态，它就会被提前终止并返回一个rejected的Promise对象。
Promise.race 只要参数的Promise实例有一个率先改变状态，则状态改变，返回最先解决或拒绝的 Promise 的结果。
Promise.allSettled 等待所有 Promise 完成，并返回一个包含每个 Promise 结果的数组，无论它们是被解决还是被拒绝。与Promise.all不同的是，Promise.allSettled不会提前终止，即使其中某个Promise对象被rejected，它也会等待所有的Promise对象都完成后才返回结果。
### 6.说一说原型和原型链？instanceof原理？
原型是js每个对象都具有的属性，用于共享属性和方法。每个对象都有一个_proto_属性，指向它的原型对象。（每个构造函数都有一个prototype属性，指向它示例对象的原型对象。）
由于每个对象都有自己的原型，它的原型也有原型，这样就形成了一条原型链。当我们访问一个对象的属性或方法时，js会先查找对象本身是否有该属性或方法，如果没有，它会继续在原型链上向上查找，直到找到或者到达原型链的顶端（即Object.prototype）
A instanceof B是检测对象A是不是B的实例。检测是基于原型链查找的，是找B的prototype有没有在A的原型链上
### 7.箭头函数有哪些特点？
a 语法简洁 b 如果只有一个表达式的话，会隐式返回，不需手动写return c 箭头函数没有自己的this、arguments、super，而是继承了其外部作用域。这意味着箭头函数内部的this值是由函数定义位置上的外部作用域决定的，而不是在运行时确定的。也无法显式绑定this。
d 由于没有自己的this值，不能使用new来创建对象示例->无法作为构造函数
### 8.扩展运算符用过吗，什么场景下？
扩展运算符可以取出参数对象中的所以可遍历属性，浅拷贝进当前对象中。
可以用于数组去重（结合Set）、数组拷贝、伪数组转真数组。
### 9.new操作符都做了哪些事？
a 创建一个空对象
b 设置该对象的原型对象。将新对象的 _Proto_指向构造函数的 prototype 属性
c 将新创建的对象作为this的上下文
d 如果构造函数没有显式返回一个对象，则 new 操作符会隐式返回新创建的对象。
### 10.说一说js事件循环？
js的任务分为同步任务和异步任务。遇到同步任务就放到执行栈上去执行，遇到异步任务就把它丢给异步模块处理，处理好了的异步任务就会进行任务队列中等待。等到执行栈上的同步任务全部处理完了之后，就进入执行炸中执行。其中，异步任务又分为宏任务和微任务，宏任务包括script标签、setTimeOut、setInterval，微任务包括promise和process.nextTick。对于异步任务来说，事件循环的每个轮次中，首先执行所有的微任务，按照它们被添加到任务队列的顺序依次执行。然后再执行宏任务，如果在执行宏任务的过程中有新的微任务生成，它们会被立即执行，确保微任务优先于下一个宏任务执行。

总结起来，JavaScript 事件循环是一种处理同步和异步任务的机制。同步任务按顺序执行，而异步任务被放入事件循环中，按照微任务优先于宏任务的顺序执行。这种机制确保了js可以处理并发的异步操作。
### 11.promise.all方法的使用场景？数组中必须每一项都是promise对象吗？不是promise对象会如何处理？
使用场景：并行执行多个异步操作，等待它们全部完成后进行下一步处理。如果数组中有非Promise对象的项，它们将被自动包装为已解决（resolved）的Promise对象。
### 12.说一说this的指向？
- （1）全局上下文：在全局作用域中，this指向全局对象（浏览器中是window对象，Node.js环境中是global对象）。
- （2）函数上下文：
a在函数作为对象的方法调用时，this指向调用该方法的对象。
b直接通过函数名来调用时，this指向全局对象（在严格模式下是undefined）。
c用作构造函数，通过new关键字创建了一个新的对象实例
d使用call、apply或bind方法时，可以显式地指定this的值。
- （3）箭头函数上下文：箭头函数的this指向其定义时的上下文，而不是调用时的上下文。它捕获了函数定义时所在的作用域的this值。
### 13.说一说call、apply、bind的作用和区别？
都可以显式改变this的指向。
call、apply会立即执行改变了this指向后的函数并返回指向结果。而bind是返回一个新的函数，不会立即执行。
call和apply的区别是，call的第二个参数及以后是一个个的参数，apply的第二个参数是一个数组
### 14.let、const、var的区别是什么？什么是块级作用域？
var的作用域是函数作用域，没有块的概念，可以跨块访问，不能跨函数访问。有变量提升。可以重复声明，后面的声明会覆盖前面的声明。
let、const的作用域是块级作用域，没有变量提升，不能重复声明。
let是声明变量，可以重新赋值。const是声明常量，不能重新赋值。
块级作用域是指变量在块（一对花括号{}）内部定义，并且在该块的外部不可访问。
变量提升：js在解析代码的时候，将变量和函数声明提前至作用域顶部
### 15.说一说js的内存泄露和垃圾回收？
程序中已经释放的堆内存未释放，造成系统资源的浪费。js是一种自动垃圾回收语言，js引擎在运行时会自动回收不再使用的内存。通常使用"标记-清除"算法，该算法会遍历对象的引用关系，并标记所有可达的对象。然后，它会清除未被标记的对象，并回收它们所占用的内存空间。
### 16.ES6新增了哪些东西？
（1）块级作用域与let、const关键字：引入了块级作用域，通过使用let和const关键字声明变量和常量，使得变量的作用域更加清晰并且可以避免变量提升的问题。
（2）箭头函数：提供了更简洁的函数定义语法，箭头函数具有词法作用域和更方便的this绑定。
（3）解构赋值：可以从数组或对象中提取值并赋给变量，使得数据的提取更加便捷。
（4）模板字面量：通过使用反引号（`）创建字符串模板，可以方便地插入变量和执行表达式。
（5）默认参数：函数参数可以设置默认值，简化了函数的调用和定义。
（6）扩展运算符：使用三个点（...）可以将数组或对象展开，使得在函数调用、数组和对象字面量中的使用更加灵活。
（7）类和模块：引入了类的概念，通过class关键字可以更方便地定义对象的结构和行为。同时，也引入了模块的概念，通过import和export可以更好地组织和管理代码。
（8）Promise和异步操作：引入了Promise对象，提供了一种更便捷的处理异步操作的方式，避免了回调地狱的问题
（9）迭代器和生成器：通过迭代器和生成器可以更容易地实现迭代和异步编程模型
（10）新的数据类型和方法：引入了Symbol作为一种新的数据类型，提供了更多的内置方法，如Array.from()、Array.of()、Object.assign()等，方便了开发者的日常工作。
（11）引入了两种数据结构Map和Set。Map是一种键值对的集合，其中每个键都是唯一的，通过键可以获取对应的值。Set是一种存储唯一值的集合，每个值只会出现一次，可以用于去重或存储一组互不重复的值。
### 17.说一说防抖和节流？
防抖和节流都是用于控制事件的触发频率的。
- 防抖的原理是在事件触发后等待一段时间，如果在等待时间内再次触发该事件，则重新计时。只有在等待时间结束后，事件没有再次触发，才会执行相应的处理函数。
怎么实现：使用setTimeout函数设置一个等待时间，在等待时间内再次触发函数调用时，会先清除之前的定时器。用闭包来保存定时器的状态。
应用：实时搜索框
- 节流的原理是规定一个时间间隔，在这个时间间隔内，只能触发一次函数调用。如果在时间间隔内多次触发函数调用，只有第一次会执行，其余的触发会被忽略。
实现：使用时间戳来控制函数的执行时间，当两次函数调用时，之间的时间间隔大于设定的时间间隔时，才执行被节流的函数，并且更新时间戳为now
应用：频繁点击按钮
### 18.说一说js的导入导出模块方式？
模块是一种封装和复用代码的方式。主要有两种方式。
CommonJS使用require和module.exports来导入和导出模块
es6使用import和export来导入导出模块
### 19.ajax、axios、fetch的区别？
ajax是一种计数统称，主要利用XHR实现异步通信，它很重要的特性之一就是让页面实现局部刷新。
axios基于promise的http库，提供简洁的API和拦截器，易于使用
fetch是原生的http请求api，基于promise，简洁易用。但在老的浏览器中需使用polyfill。
### 20.数组常用方法
push、pop、shift、unshift、splice、sort、concat、join
21.map()和foreach的区别？
- map()方法接收一个处理数组元素的回调函数，会返回一个新数组。
- foreach也是接收一个回调函数，但它没有返回值，只是遍历一遍数组，也不会改变原数组。
## 数据结构、算法、os
### 1.进程和线程的区别？
一个进程可以包括多个线程。进程是操作系统分配资源和进行任务调度的基本单位，每个经常都有独立的内存空间、寄存器状态和系统资源。线程是进程中的一个执行单元，是cpu调度和分配的基本单位，同一个进程的多个线程共享进程的内存空间和系统资源。

进程间通信需要使用特定的机制（如管道、消息队列、共享内存等）；线程间通信直接读写共享数据来实现。

比如一个qq音乐播放器是一个进程，但是其中又有许多线程。
浏览器的不同页面是同一个进程但是有单独的线程。
### 2.数组和链表的区别？使用场景？
数组是一种顺序存储结构，在内存中占连续的空间，每个元素可以通过索引直接访问。链表是一种链式存储结构，他发元素储存在不连续的内存空间中，并提供指针链接在一起。
数组适用场景：需要快速访问任意位置的元素时
链表使用场景：当需要频繁进行插入和删除操作，或者不确定数据量大小时。

### 3.说一说对LRU算法的理解？
LRU 算法的基本思想是，当需要替换（淘汰）一个资源时，选择最近最少使用的资源进行替换。可以用双向链表和哈希表相结合来实现。

### 4.说说栈和堆的区别？
栈和堆都是内存中用于储存数据的区域。存储局部变量和函数参数。每当函数被调用时，该函数的局部变量和函数参数会被压入栈中，函数执行完毕后会自动释放这些变量所占用的栈空间。，访问速度快，空间相对较小。堆用于存储动态分配的内存，访问速度较慢，空间较大。
ps.全局变量不是存储在栈中，而是存储在程序的数据段或静态存储区中。

### 5.栈和队列的区别？
栈先进后出，队列先进先出。
栈：递归、函数调用、表达式求值、括号匹配。
队列：任务调度、消息队列、缓存、广度优先搜索等问题。

### 6.请解释一下编译原理中的词法分析器和语法分析器的作用。
编译原理是指编译器的设计和实现原理。编译器是将高级语言转换成机器语言的程序。词法分析器是编译器中的一部分，负责将源代码分割成一个一个的词素，也就是分割成关键字、标识符、常量等基本元素。词法分析器则负责根据语法规则将词素组成语法树，并进行语法分析和语义分析等操作，最终生成目标代码。
ps编译原理包括：词法分析、语法分析、语义分析、中间代码生成、目标代码生成

### 7.请解释一下哈希表的原理和应用场景。
它通过将关键字映射到一个地址来实现快速访问。哈希表通常用于实现map、关联数组等需要快速查找的场景。

### 递归和迭代
递归是自己调用自己，迭代是重复执行一些步骤

### 虚拟内存的概念？
虚拟内存是计算机操作系统 一种技术，它将计算机中物理内存和磁盘空间结合使用，为程序提供了一个比实际物理内存更大的地址空间。其作用是在需要时动态地将程序转移到磁盘上。
虚拟内存也存在一些缺点，如访问虚拟内存的速度较慢，页置换会增加系统开销。
常见的排序算法和时间复杂度？
冒泡排序，选择排序，插入排序。时间复杂度是O(n2)
快速排序、归并排序是O(nlogn)
快速排序：选择一个基准的数，将数组分成小于和大于等于基准元素两部分，然后对这两部分分别递归进行快速排序。
归并排序：将数组分为若干个子数组，对每个子数组进行排序，然后将已排序的子数组合并成一个有序数组。

### 死锁的概念和产生死锁的条件？
死锁是两个或多个进程都在等待对方持有的资源，然后就都无法继续执行了。
产生死锁的条件：
互斥条件：至少有一个资源是互斥的，就是一次只能被一个进程占用。当进程占用了该资源时，其他进程必须等待。
请求与保持条件：进程已经占有了至少一个资源，同时又提出了新的资源请求，并且正在等待该资源被满足。在等待期间，进程继续持有已经获取的资源。
不可剥夺条件：已经分配给一个进程或线程的资源不能被强行抢占，只能由持有该资源的进程或线程显式释放。
循环等待条件：存在一个进程资源的循环链，其中每个进程都在等待下一个进程所持有的资源。换句话说，存在一个进程序列P1、P2、...、Pn，其中P1等待P2所持有的资源，P2等待P3所持有的资源，...，Pn等待P1所持有的资源。

### 说一说时间复杂度和空间复杂度？你怎么看待时间换空间？ 
时间复杂度和空间复杂度是用来评估算法效率的指标的。

时间换空间是在算法设计中权衡时间和空间开销的策略，可以通过增加额外的空间来减少时间开销，或者通过减少空间占用来增加执行时间。

### 如何判断一个链表是环形的？
快慢指针法。如果链表是环形的，那么快指针终究会追上慢指针。如果链表不是环形的，那么快指针会到达链表末尾。

### 如何判断一个字符串是否为回文字符串？
可以采用双指针法，设置左右两个指针分别在字符串的头部和尾部，依次向中间移动，比较左右指针所指向的字符是否相等。