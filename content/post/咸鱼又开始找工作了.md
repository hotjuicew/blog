---
title: "咸鱼又开始找工作了"
date: 2023-05-31T17:36:11+08:00
categories: []
tags: []
draft: true
---

不努力是不会有回报的。嗯！

## JS篇
1.数组去重有哪些方法？
a.`const newArr=[...new Set(arr)]`
b.`const newArr=filter((value,index,arr)=>return value.indexOf(value)===index)`
c.`const newArr = arr.reduce((unique, item) => {
  return unique.includes(item) ? unique : [...unique, item];
}, []);`
2.深拷贝和浅拷贝的区别？数组深拷贝方法？对象深拷贝方法？
对于引用数据类型来说，比如普通对象、数组、正则，浅拷贝就是拷贝指向它的那个指针，这两个变量共用一块内存空间。深拷贝是重新开辟一块内存，复制对象本身。
数组深拷贝方法：a重新创建一个数组然后遍历赋值 b使用展开运算符 [...originalArray] c使用slice()方法 let newArr=arr.slice()
对象深拷贝方法：a 手动实现递归深拷贝函数 b 使用json序列化和反序列化const newObj=JSON.parse(JSON.stringify(obj)) 缺点是无法复制函数、正则表达式、循环引用 c 引入lodash库 _.deepClone(obj)方法
2.js数据类型有哪些
基本数据类型：Number，String，Boolean,  Null, Undefined,    BigInt,Symbol
引用数据类型：对象（包括普通对象、数组、函数、正则等）
3.获取js变量类型的方法？
a typeof缺点是如果该变量是对象，只能返回Object，不能区分具体类型。例外的是Function会返回Function
b instance of 是判断是否是特定的数据类型的，返回true or false
c Object.prototype.toString.call()可以返回具体的类型
4.说一说promise？
Promise 是 JavaScript 中处理异步操作的一种方式。它是一种代表异步操作最终完成或失败的对象。Promise 对象有三个状态：Pending、Fulfilled和Rejected。通过.then()方法指定成功时的处理函数，通过.catch()方法指定失败时的处理函数。使用 Promise 可以更好地处理异步代码，避免回调地狱。
5.说一说promise.all和promise.race、Promise.allSettled？
都是接收一个由多个Promise对象组成的数组，并返回一个新的Promise对象。这个新的Promise对象

Promise.all 等待所有 Promise 完成，所有的Promise对象都变为resolved状态时才会被resolved，否则只要有一个Promise对象变为rejected状态，它就会被提前终止并返回一个rejected的Promise对象。
Promise.race 只要参数的Promise实例有一个率先改变状态，则状态改变，返回最先解决或拒绝的 Promise 的结果。
Promise.allSettled 等待所有 Promise 完成，并返回一个包含每个 Promise 结果的数组，无论它们是被解决还是被拒绝。与Promise.all不同的是，Promise.allSettled不会提前终止，即使其中某个Promise对象被rejected，它也会等待所有的Promise对象都完成后才返回结果。
6.说一说原型和原型链？instanceof原理？
原型是js每个对象都具有的属性，用于共享属性和方法。每个对象都有一个_proto_属性，指向它的原型对象。（每个构造函数都有一个prototype属性，指向它示例对象的原型对象。）
由于每个对象都有自己的原型，它的原型也有原型，这样就形成了一条原型链。当我们访问一个对象的属性或方法时，js会先查找对象本身是否有该属性或方法，如果没有，它会继续在原型链上向上查找，直到找到或者到达原型链的顶端（即Object.prototype）
A instanceof B是检测对象A是不是B的实例。检测是基于原型链查找的，是找B的prototype有没有在A的原型链上
7.箭头函数有哪些特点？
a 语法简洁 b 如果只有一个表达式的话，会隐式返回，不需手动写return c 箭头函数没有自己的this、arguments、super，而是继承了其外部作用域。这意味着箭头函数内部的this值是由函数定义位置上的外部作用域决定的，而不是在运行时确定的。也无法显式绑定this。
d 由于没有自己的this值，不能使用new来创建对象示例->无法作为构造函数
8.扩展运算符用过吗，什么场景下？
扩展运算符可以取出参数对象中的所以可遍历属性，浅拷贝进当前对象中。
可以用于数组去重（结合Set）、数组拷贝、伪数组转真数组。
9.new操作符都做了哪些事？
a 创建一个空对象
b 设置该对象的原型对象。将新对象的 _Proto_指向构造函数的 prototype 属性
c 将新创建的对象作为this的上下文
d 如果构造函数没有显式返回一个对象，则 new 操作符会隐式返回新创建的对象。
10.说一说js事件循环？
js的任务分为同步任务和异步任务。遇到同步任务就放到执行栈上去执行，遇到异步任务就把它丢给异步模块处理，处理好了的异步任务就会进行任务队列中等待。等到执行栈上的同步任务全部处理完了之后，就进入执行炸中执行。其中，异步任务又分为宏任务和微任务，宏任务包括script标签、setTimeOut、setInterval，微任务包括promise和process.nextTick。对于异步任务来说，事件循环的每个轮次中，首先执行所有的微任务，按照它们被添加到任务队列的顺序依次执行。然后再执行宏任务，如果在执行宏任务的过程中有新的微任务生成，它们会被立即执行，确保微任务优先于下一个宏任务执行。

总结起来，JavaScript 事件循环是一种处理同步和异步任务的机制。同步任务按顺序执行，而异步任务被放入事件循环中，按照微任务优先于宏任务的顺序执行。这种机制确保了js可以处理并发的异步操作。
11.promise.all方法的使用场景？数组中必须每一项都是promise对象吗？不是promise对象会如何处理？
使用场景：并行执行多个异步操作，等待它们全部完成后进行下一步处理。如果数组中有非Promise对象的项，它们将被自动包装为已解决（resolved）的Promise对象。
12.说一说this的指向？
（1）全局上下文：在全局作用域中，this指向全局对象（浏览器中是window对象，Node.js环境中是global对象）。
（2）函数上下文：
a在函数作为对象的方法调用时，this指向调用该方法的对象。
b直接通过函数名来调用时，this指向全局对象（在严格模式下是undefined）。
c用作构造函数，通过new关键字创建了一个新的对象实例
d使用call、apply或bind方法时，可以显式地指定this的值。
（3）箭头函数上下文：箭头函数的this指向其定义时的上下文，而不是调用时的上下文。它捕获了函数定义时所在的作用域的this值。
13.说一说call、apply、bind的作用和区别？
都可以显式改变this的指向。
call、apply会立即执行改变了this指向后的函数并返回指向结果。而bind是返回一个新的函数，不会立即执行。
call和apply的区别是，call的第二个参数及以后是一个个的参数，apply的第二个参数是一个数组
14.let、const、var的区别是什么？什么是块级作用域？
var的作用域是函数作用域，没有块的概念，可以跨块访问，不能跨函数访问。有变量提升。可以重复声明，后面的声明会覆盖前面的声明。
let、const的作用域是块级作用域，没有变量提升，不能重复声明。
let是声明变量，可以重新赋值。const是声明常量，不能重新赋值。
块级作用域是指变量在块（一对花括号{}）内部定义，并且在该块的外部不可访问。
15.说一说js的内存泄露和垃圾回收？
程序中已经释放的堆内存未释放，造成系统资源的浪费。js是一种自动垃圾回收语言，js引擎在运行时会自动回收不再使用的内存。js的垃圾回收是通过引用计数实现的，原理是，如果一个对象有其他对象引用他，它的引用计数就会