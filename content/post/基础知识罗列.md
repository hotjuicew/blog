### 1.JavaScript 八种数据类型

基本数据类型（原始值）：

- Number（数值，包含NaN）
- String（字符串）
- Boolean（布尔值）
- Undefined（未定义/未初始化）
- Null（空对象）
- Symbol（独一无二的值，ES6 新增）
- BigInt （大整数，能够表示超过 Number 类型大小限制的整数，ES 2020新增）
复杂数据类型（引用值）：

- Object（对象。Array/数组 和 function/函数 也属于对象的一种）
### 2.原型链

对象都是由构造函数创建，对象的__proto__属性指向其原型对象，构造函数的prototype属性指向其创建的对象实例的原型对象，所以对象的__proto__属性等于创建它的构造函数的prototype属性。

1.引用类型都是对象，每个对象都有原型对象。
2.对象都是由构造函数创建，对象的__proto__属性指向其原型对象，构造函数的prototype属性指向其创建的对象实例的原型对象，(这个原型对象中默认有一个`constructor`属性，指回该构造函数)所以对象的__proto__属性等于创建它的构造函数的prototype属性。
3.所有通过字面量表示法创建的普通对象的构造函数为Object
4.所有原型对象都是普通对象，构造函数为Object
5.所有函数的构造函数是Function
6.Object.prototype没有原型对象
![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/9/166f83af5e67ebcf~tplv-t2oaga2asx-zoom-in-crop-mark:3402:0:0:0.awebp)

1.instanceof操作符:想要知道一个对象的具体类型，就需要使用到instanceof
instanceof运算符用于检查右边构造函数的prototype属性是否出现在左边对象的原型链中的任何位置。其实它表示的是一种原型链继承的关系。
2.new操作符
当我们使用new时，做了些什么？
 a.创建一个全新对象，并将其`__proto__`属性指向构造函数的prototype属性。
 b.将构造函数调用的this指向这个新对象，并执行构造函数。
 c.如果构造函数返回对象类型Object(包含Functoin, Array, Date, RegExg, Error等)，则正常返回，否则返回这个新的对象。
真的是继承吗？
前面我们讲到每一个对象都会从原型“继承”属性，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的JavaScript》中的话，就是：
继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性，所以与其叫继承，委托的说法反而更准确些。

3.Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：

1. 初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；
2. 开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；
3. 确定入口：根据配置中的 entry 找出所有的入口文件；
4. 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；
5. 完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；
6. 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；
7. 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。

### 3.XSS和CSRF

xss是跨站脚本攻击：攻击者在网站上注入恶意脚本，对客户端网页进行篡改。

有很多种方式进行 XSS 攻击，但它们的共同点为：将一些隐私数据像 cookie、session 发送给攻击者，将受害者重定向到一个由攻击者控制的网站，在受害者的机器上进行一些恶意操作。

XSS的类型
a反射型（非持久）：通过URL参数直接注入
b存储型（持久）：存储到数据库后读取时注入
c基于DOM：被执行的恶意脚本会修改页面脚本结构

XSS的注入点（会被浏览器执行）
HTML的节点内容或属性、javascript代码、富文本

XSS 攻击的防范
a.浏览器内置了防范 XSS 的措施，例如 CSP
b.HttpOnly 防止劫取 Cookie：
c.对于用户的任何输入要进行检查、过滤和转义:输入检查一般是检查用户输入的数据中是否包含 <，> 等特殊字符，如果存在，则对特殊字符进行过滤或编码，这种方式也称为 XSS Filter。

CSRF是跨站请求伪造:与XSS不同的是，XSS是攻击者直接对我们的网站A进行注入攻击，CSRF是通过网站B(带上网站A的cookies)对网站A进行伪造请求。

CSRF具有的特点
a.伪造请求不经过网站A
b.伪造请求的域名不是网站A

CSRF的防御
增加验证码
	CSRF的一个特点是伪造请求不经过网站A,那么我们可以通过增加网站A的验证手段，例如增加图形验证码或短信验证码等等，只有通过验证的请求才算合法。
对于CSRF的第二个特点伪造请求的域名不是网站A,那么通过限制cookies不被其他域名网站使用,来达到防御的目的，具体的做法是：
cookies设置sameSite属性的值为strict，这样只有同源网站的请求才会带上cookies。但是此方案有浏览器兼容问题。

