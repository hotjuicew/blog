---
title: "Legacy Responsive Web Design 笔记"
date: 2022-05-23T01:04:13+08:00
categories: [前端]
tags: [前端三件套]
draft: true
---

偶然发现FreeCodeCamp这个网站，想着很多基础知识都生疏了（或者说本来就不咋熟练），想做一遍题目，熟悉一下。这里记录一些之前没见过 或者忘得差不多的一些小点
# html，css

## 基础CSS 

1.[attr=value] 属性选择器
	例如，下面的代码会改变所有 type 为 radio 的元素的外边距。

```css
[type='radio'] {
  margin: 20px 0px 20px 0px;
}
```
2.理解绝对单位与相对单位
	绝对单位：MDN文档认为px为绝对单位。
	相对单位：是相对于其他东西的，可能是父元素字体的大小，或者视口的大小。列一些常见的相对单位。
	em	父级的字体大小，在印刷属性的情况下 font-size，和元素本身的字体大小，在其他属性的情况下，如width.

|      | 几倍于              |
| ---- | ------------------- |
| ex   | 元素字体的 x 高度。 |
| rem  | 根元素的字体大小。  |
| lh   | 元素的行高。        |
| vw   | 视口宽度的 1%。     |
| vh   | 视口高度的 1%。     |
| vmin | 视口较小尺寸的 1%。 |
| vmax | 视口较大尺寸的 1%。 |

3.CSS样式的优先级
	Important>行内样式>id选择>class选择
	eg.
	给粉红文本元素的颜色声明添加关键词 !important，以确保 h1 元素为粉红色。
	如下所示：
```css
color: red !important;
```
4.创建一个自定义的 CSS 变量

只需要在变量名前添加两个连字符号，并为其赋值即可，例子如下：

```css
--penguin-skin: gray;
```

创建变量后，CSS 属性可以通过调用变量名来使用它对应的值。

```css
background: var(--penguin-skin);
```
补充：
使用变量来作为 CSS 属性值的时候，可以设置一个备用值来防止由于某些原因导致变量不生效的情况。让浏览器在找不到你的变量时可以显示一种颜色。
下面是操作方式：

```css
background: var(--penguin-skin, black);
```
5.:root
:root 这个 CSS 伪类匹配文档树的根元素。对于 HTML 来说，:root 表示 <html> 元素，除了优先级更高之外，与 html 选择器相同。
eg.
在声明全局 CSS 变量时 :root 会很有用：

```css
:root {
  --main-color: hotpink;
  --pane-padding: 5px 42px;
}
```
### 应用视觉设计
1.
使用 u 标签给文本添加下划线;
使用 em 标签来强调文本;
用 s 标签来给文字添加删除线;
用 hr 标签来创建一条宽度撑满父元素的水平线;((((可以考虑用到我的模板里，嘻嘻))))
opacity 属性用来设置元素的透明度；
text-transform 属性给文本添加大写效果；
2.top, right, bottom, left指的是当前元素相对于top, right, bottom, left向对面移动多远
3.
position：relative 相对定位
position：absolute 绝对定位。 会将元素从当前的文档流里面移除，周围的元素会忽略它。绝对定位比较特殊的一点是元素的定位参照于最近的 positioned 祖先元素。 如果它的父元素没有添加定位规则（默认是 position: relative;），浏览器会继续寻找直到默认的 body 标签。
position: fixed.  fixed 和 absolute 的最明显的区别在于，前者定位的元素不会随着屏幕滚动而移动。
4.元素的 float 属性。 浮动元素脱离文档流
5.在应用设计中经常需要把一个块级元素水平居中显示，实现方式是把块级元素的 margin 值设置为 auto。
6.hsl()根据其色调、饱和度和亮度分量表示sRGB颜色。一个可选的alpha分量表示颜色的透明度。
7.linear-gradient() 实现线性渐变， 以下是它的语法：

```css
background: linear-gradient(gradient_direction, color 1, color 2, color 3, ...);
```
第一个参数指定了颜色过渡的方向——它的值是角度，90deg 表示垂直渐变（从左到右），45deg 表示沿对角线渐变（从左下方到右上方）。 其他参数指定了渐变颜色的顺序：
eg 

```css
background: linear-gradient(90deg, red, yellow, rgb(204, 204, 255));
```

8.CSS 属性 transform 里面的 scale() 函数可以用来改变元素的显示比例。 
9.伪元素 ::before 和 ::after。 ::before 创建一个伪元素，它是所选元素的第一个子元素； ::after 创建一个伪元素，它是所选元素的最后一个子元素。::before 和 ::after 必须配合 content 来使用。 这个属性通常用来给元素添加内容诸如图片或者文字。 尽管有时 ::before 和 ::after 是用来实现形状而非文字，但 content 属性仍然是必需的，此时它的值可以是空字符串。
10.给元素添加动画：animation 属性以及 @keyframes 规则。 animation 属性控制动画的外观，@keyframes 规则控制动画中各阶段的变化。
animation-name 用来设置动画的名称，也就是我们稍后要在 @keyframes 里用到的名称。
animation-duration 设置动画所花费的时间。
eg.id 为 anim 的元素，我们在代码中将它的 animation-name 设置为 colorful，同时设置 animation-duration 为 3 秒。 然后我们把 @keyframes 规则添加到名为 colorful 的动画属性上。 在动画开始时（0%）的背景颜色为蓝色，在动画结束时（100%）的背景颜色为黄色。 注意我们不只可以设置开始和结束，而是从 0% 到 100% 间的任意位置都可以设置。
animation-fill-mode 指定了在动画结束时元素的样式

```css
#anim {
  animation-name: colorful;
  animation-duration: 3s;
}

@keyframes colorful {
  0% {
    background-color: blue;
  }
  100% {
    background-color: yellow;
  }
}
```
### 应用无障碍（这里的用户包括有视觉障碍、听觉障碍或认知障碍的用户）
1.HTML5 新标签
article 用于独立且完整的内容，而 section 用于对与主题相关的内容进行分组。 举个例子：如果一本书是一个 article 的话，那么每个章节就是 section。 
nav 导航
audio 标签用于呈现音频内容或音频流，它也具有语义化特性。 音频内容也需要备用文本，供聋哑人或听力困难的人使用。 这可以通过页面上的文本或与字幕链接来实现。

audio 标签支持 controls 属性， 用于显示浏览器默认播放、停止和其他控制，以及支持键盘功能。 这是一个布尔值属性，意味着它不需要一个值，它在标签上存在即开启设置。

 figure 标签以及与之相关的 figcaption 标签。 它们一起用于展示可视化信息（如：图片、图表）及其标题。 
举个例子，注意 figcaption 包含在 figure 标签中，并且可以与其他标签组合使用：

```css
<figure>
  <img src="roundhouseDestruction.jpeg" alt="Photo of Camper Cat executing a roundhouse kick">
  <br>
  <figcaption>
    Master Camper Cat demonstrates proper form of a roundhouse kick.
  </figcaption>
</figure>
```

2.`label` 标签的文本内容通常会是表单组件的名称或标签。 这些文本表明了组件的意义，也提升了表单的可访问性。 `label` 标签的 `for` 属性将标签与表单组件绑定（`label` 标签的 `for` 属性和input的id要一致）；同时，屏幕阅读器也会读取 `for` 属性的属性值。

```css
<form>
  <label for="name">Name:</label>
  <input type="text" id="name" name="name">
</form>
```

3.`fieldset` 标签包裹整组单选按钮，实现这个功能。 它经常使用 `legend` 标签来提供分组的描述，以便屏幕阅读器用户会阅读 `fieldset` 元素中的每个选项。

4.`input` 标签，它可以用来创建多种表单控件。 它的 `type` 属性指定了所要创建的 `input` 标签类型。除了 `text` 与 `submit` 类型的 input 标签。 HTML5 规范添加了 `date` 类型来创建日期选择器。

5.HTML5 还引入了 `time` 标签与 `datetime` 属性来标准化时间。 `time` 元素是一个行内元素，用于在一个页面上包裹在日期或时间外面。  辅助设备可以获取`datetime` 

```html
<p>Master Camper Cat officiated the cage match between Goro and Scorpion <time datetime="2013-02-13">last Wednesday</time>, which ended in a draw.</p>
```

6.如果我们想在页面中添加一些只对屏幕阅读器可见的内容，可以用 CSS 来实现。 当信息为视觉格式（例如图表）时，但屏幕阅读器用户需要备用文稿（例如表格）来访问数据，在这种情况下， 使用 CSS 将屏幕的只读元素放到浏览器窗口可视区域之外。eg

```css
.sr-only {
  position: absolute;
  left: -10000px;
  width: 1px;
  height: 1px;
  top: auto;
  overflow: hidden;
}
```

### 响应式网页设计原则

1.媒体查询

媒体查询是 CSS3 中引入的一项新技术，它可以根据不同的视口大小调整内容的布局。 视口是指浏览器中，用户可见的网页内容。 视口会随访问网站的设备不同而改变。媒体查询由媒体类型组成，如果媒体类型与展示网页的设备类型匹配，则应用对应的样式。 你可以在媒体查询中使用各种选择器和样式。

下面是一个媒体查询的例子，当设备宽度小于或等于 `100px` 时返回内容：

```css
@media (max-width: 100px) { /* CSS Rules */ }
```

以下定义的媒体查询，是当设备高度大于或等于 `350px` 时返回内容：

```css
@media (min-height: 350px) { /* CSS Rules */ }
```

注意，只有当媒体类型与所使用的设备的类型匹配时，媒体查询中定义的 CSS 才生效。

2.使图片自适应设备尺寸

用 CSS 来让图片自适应其实很简单。 你只需要给图片添加这些属性:

```css
img {
  max-width: 100%;
  height: auto;
}
```

设置 `max-width` 值为 `100%` 可确保图片不超出父容器的范围；设置 `height` 属性为 `auto` 可以保持图片的原始宽高比。

3.让图像正确出现在高分辨率显示器

随着联网设备的增加，设备间的区别不仅发生在尺寸和规格上，还发生在用于显示的设备上。 像素密度就是区分不同显示设备的一个指标，它一般会以 PPI（Pixel Per Inch，即每英寸像素）或 DPI（每英寸点数）为计量单位。 最著名的显示器就是 Apple MacBook Pro 笔记本电脑上的“视网膜显示屏”（现亦用于 iMac）。 由于“视网膜显示屏”和“非视网膜显示屏”显示器之间像素密度的不同，某些未考虑高分辨率显示器的图像在高分辨率显示器上渲染时，可能因出现“像素化”而不够清晰。

让图像正确出现在高分辨率显示器（例如 MacBook Pros “Revistina display”）上的最简单方式， 是定义它们的 `width` 和 `height` 值为原始值的一半。 下面是一个仅使用原始高度和宽度一半的图像示例：

```html
<style>
  img { height: 250px; width: 250px; }
</style>
<img src="coolPic500x500" alt="A most excellent picture">
```

4.使排版根据设备尺寸自如响应

除了使用 `em` 或 `px` 设置文本大小，你还可以用视窗单位来做响应式排版。 视窗单位和百分比都是相对单位，但它们是基于不同的参照物。

四个不同的视窗单位分别是：

- `vw`：如 `10vw` 的意思是视窗宽度的 10%。
- `vh：` 如 `3vh` 的意思是视窗高度的 3%。
- `vmin：` 如 `70vmin` 的意思是视窗的高度和宽度中较小一个的 70%。
- `vmax：` 如 `100vmax` 的意思是视窗的高度和宽度中较大一个的 100%。

### Flexbox（弹性盒子）

Flexbox（弹性盒子）是最新版本的 CSS（即 CSS3）中引入的一种强大且兼容性好的布局方法。使用 flexbox，我们可以很容易地处理好页面上的元素布局，并创建可以自动缩小和放大的动态用户界面。

1.只要在一个元素的 CSS 中添加 `display: flex;`，就可以使用其它 flex 属性来构建响应式页面了。

补充几篇文章：
[Flex 布局教程：语法篇](https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)
[当我们在使用 display: flex 的时候，到底发生了什么](https://juejin.cn/post/6844903892963033096)
[将弹性项目固定到容器底部](https://stackoverflow.com/questions/45555815/pin-a-flex-item-to-the-bottom-of-the-container)

2.

flex 容器（flex 子元素的父元素）属性：flex-direction，justify-content，align-items，flex-wrap

flex 子元素属性：flex-shrink，flex-grow，flex-basis，order，align-self



当容器的宽度小于里面所有子元素的宽度之和时，所有子元素都会自动压缩。子元素的 `flex-shrink` 接受数值作为属性值。 数值越大，则该元素与其他元素相比会被压缩得更厉害。 比如，一个项目的 `flex-shrink` 属性值为 `1`，另一个项目的 `flex-shrink` 属性值为 `3`，那么后者相比前者会受到 `3` 倍压缩。

相对于`flex-shrink` ，`flex-grow` 会在容器太大时对子元素作出调整。

`flex-basis` 属性定义了在使用 CSS 的 `flex-shrink` 或 `flex-grow` 属性对元素进行调整前，元素的初始大小。

 3.flex 属性有一个简写方式。 `flex-grow`、`flex-shrink` 和 `flex-basis` 属性可以在 `flex` 中一并设置。

例如，`flex: 1 0 10px;` 会把项目属性设为 `flex-grow: 1;`、`flex-shrink: 0;` 以及 `flex-basis: 10px;`。 属性的默认设置是 `flex: 0 1 auto;`。

4.`order` 属性告诉 CSS flex 容器里子元素的顺序。 默认情况下，项目排列顺序与源 HTML 文件中顺序相同。 这个属性接受数字作为参数，可以使用负数。

5.align-self属性允许你调整单个子元素自己的对齐方式，而不会影响到全部子元素。因为 `float`、`clear` 和 `vertical-align` 等调整对齐方式的属性都不能应用于 flex 子元素，所以这个属性显得十分有用。

### CSS网格

通过将属性 `display` 的值设为 `grid`，HTML 元素就可以变为网格容器。 通过前面的操作，你可以对该容器使用与 CSS 网格（CSS Grid）相关的属性。

**注意：** 在 CSS 网格中，父元素称为容器（container），它的子元素称为项（items）。

##### 网格容器

1.使用 grid-template-columns 添加多列 使用 grid-template-rows 添加多行

```css
.container {
  display: grid;
    /* 请给网格容器设置三个列，每列宽度均为 100px。 */
  grid-template-columns: 100px 100px 100px;
}
```

2.使用 CSS 网格单位来更改列和行的大小

在 CSS 网格中，可以使用绝对单位（如 `px`）或相对单位（如 `em`）来定义行或列的大小。 下面的单位也可以使用：

`fr`：设置列或行占剩余空间的比例，

`auto`：设置列宽或行高自动等于它的内容的宽度或高度，

`%`：将列或行调整为它的容器宽度或高度的百分比

```css
grid-template-columns: auto 50px 10% 2fr 1fr;
```

这段代码添加了五个列。 第一列的宽与它的内容宽度相等；第二列宽 50px；第三列宽是它容器的 10%；最后两列，将剩余的宽度平均分成三份，第四列占两份，第五列占一份。

3.使用 grid-column-gap 创建多列之间的间距  使用 grid-row-gap 创建多行之间的间距

`grid-gap` 属性是 `grid-row-gap` 和 `grid-column-gap` 的简写属性，它更方便使用。 如果 `grid-gap` 只有一个值，那么这个值表示行与行之间、列与列之间的间距均为这个值。 如果有两个值，那么第一个值表示行间距，第二个值表示列间距。

##### 网格项

1.使用 grid-column和grid-row 来控制网格项大小。

网格中，假想的水平线和垂直线被称为线（lines）。 这些线在网格的左上角从 1 开始编号，垂直线向右、水平线向下累加计数。

这是一个 3x3 网格的线条：<img src="D:\workspace\hotjuice_website\static\images\image-20220524150930065.png" alt="image-20220524150930065" style="zoom:50%;" />

要设置一个网格项占据几列，你可以使用 `grid-column` 属性加上网格线条的编号来定义网格项开始和结束的位置。

示例如下：

```css
grid-column: 1 / 3;
```

这会让网格项从左侧第一条线开始到第三条线结束，占用两列。



2.使用网格项的 `justify-self` 属性，设置其内容的位置在单元格内沿水平轴的对齐方式。默认情况下，这个属性的值是 `stretch`，这将使内容占满整个单元格的宽度。 该 CSS 网格属性也可以使用其他的值：

`start`：使内容在单元格左侧对齐，

`center`：使内容在单元格居中对齐，

`end`：使内容在单元格右侧对齐。

类似地，使用 align-self 垂直对齐项目。

使用 justify-items 水平对齐所有项目 使用 align-items 垂直对齐所有项目。

3.将网格划分为区域模板。

你可以将网格中的一些单元格组合成一个区域（area），并为该区域指定一个自定义名称。 可以通过给容器加上 `grid-template-areas` 来实现：

```css
grid-template-areas:
  "header header header"
  "advert content content"
  "advert footer footer";
```

上面的代码将网格单元格分成四个区域：`header`、`advert`、`content` 和 `footer`。 每个单词代表一个单元格，每对引号代表一行。



使用 grid-area 属性将项目放置在网格区域中

像上一个挑战那样，在为网格添加区域模板后，可以通过引用你所定义的区域的名称，将元素放入相应的区域。 为此，你需要对网格项使用 `grid-area`：

```css
.item1 {
  grid-area: header;
}
```

这样，class 为 `item1` 的网格项就被放到了 `header` 区域里。 在这种情况下，该项目将使用整个顶行，因为该整行被命名为 `header` 区域。

4.使用 grid-area 创建区域模板

 `grid-area` 属性还有另一种使用方式。 如果网格中没有定义区域模板，你也可以像这样为它添加一个模板：

```css
item1 { grid-area: 1/1/2/4; }
```

这里使用了你之前学习的网格线编号来定义网格项的区域。 上例中数字代表这些值：

```css
grid-area: horizontal line to start at / vertical line to start at / horizontal line to end at / vertical line to end at;
```

因此，示例中的网格项将占用第 1 条水平网格线（起始）和第 2 条水平网格线（终止）之间的行，及第 1 条垂直网格线（起始）和第 4 条垂直网格线（终止）之间的列。

5.使用 repeat 函数

使用 `repeat` 方法指定行或列的重复次数，后面加上逗号以及需要重复的值。

以下为添加 100 行网格的例子，每行高度均为 50px：

```css
grid-template-rows: repeat(100, 50px);
```

你还可以用 repeat 方法重复多个值，并在定义网格结构时与其他值一起使用。 比如：

```css
grid-template-columns: repeat(2, 1fr 50px) 20px;
```

效果相当于：

```css
grid-template-columns: 1fr 50px 1fr 50px 20px;
```

6.使用 minmax 函数限制项目大小

内置函数 `minmax` 也可用于设置 `grid-template-columns` 和 `grid-template-rows` 的值。 它的作用是在网格容器改变大小时限制网格项的大小。 为此，你需要指定网格项允许的尺寸范围。 例如：

```css
grid-template-columns: 100px minmax(50px, 200px);
```

在上面的代码中，我们通过 `grid-template-columns` 添加了两列，第一列宽度为 100px，第二列宽度最小值是 50px，最大值是 200px。

7.使用 auto-fill 创建弹性布局

repeat 方法带有一个名为自动填充（auto-fill）的功能。 它的功能是根据容器的大小，尽可能多地放入指定大小的行或列。 你可以通过结合 `auto-fill` 和 `minmax` 来更灵活地布局。

```css
 grid-template-columns:repeat(auto-fill, minmax(60px, 1fr));
```

上面的代码效果是这样：首先，列的宽度会随容器大小改变。其次，只要容器宽度不足以插入一个宽为 60px 的列，当前行的所有列就都会一直拉伸。请自己调整宽度，动手试一下就不难理解了。 **注意：** 如果容器宽度不足以将所有网格项放在同一行，余下的网格项将会移至新的一行。

8.使用 auto-fit 创建弹性布局

`auto-fit` 效果几乎和 `auto-fill` 一样。 不同点仅在于，当容器的大小大于各网格项之和时，`auto-fill` 会持续地在一端放入空行或空列，这样就会使所有网格项挤到另一边；而 `auto-fit` 则不会在一端放入空行或空列，而是会将所有网格项拉伸至合适的大小。

**注意：** 如果容器宽度不足以将所有网格项放在同一行，余下的网格项将会移至新的一行。

![image-20220524163707674](D:\workspace\hotjuice_website\static\images\image-20220524163707674.png)

9.应用：使用媒体查询创建响应式布局

将 CSS 网格与使用媒体查询结合使用，如使用媒体查询重新排列网格区域、更改网格尺寸以及重新排列网格项位置，我们可以让制作出的网站更具响应性。

在右侧的预览区中，当网页可视区域的宽不小于 300px 时，列数从 1 变为 2。 并且，广告（advertisement）区域会完全占据左列。

当网页可视区域的宽不小于 `400px` 时，请让 header 区域完全占据最顶行，footer 区域完全占据最底行。

```css
@media (min-width: 300px){
    .container{
      grid-template-columns: auto 1fr;
      grid-template-rows: auto 1fr auto;
      grid-template-areas:
        "advert header"
        "advert content"
        "advert footer";
    }
  }

  @media (min-width: 400px){
    .container{
      grid-template-areas:
      /* 只修改这一行下面的代码 */
        "header header"
        "advert content"
        "footer footer";
      /* 只修改这一行上面的代码 */
    }
  }
```

10.在网格中创建网格

将元素转换为网格只会影响其子元素（即直接后代元素，英文为 direct descendants。意思是一个元素的所有后代元素中，父级元素为该元素的所有元素）。 因此，如果我们把某个子元素设置为网格，就会得到一个嵌套的网格。

例如，如果我们设置 class 为 `item3` 的元素的 `display` 和 `grid-template-columns` 属性，就会得到一个嵌套的网格。

请设置 `display` 和 `grid-template-columns`，使类为 `item3` 元素转换为有两列且宽度为 `auto` 和 `1fr` 的网格。

### 五个项目用到的知识

1.[CSS-水平居中、垂直居中、水平垂直居中](https://segmentfault.com/a/1190000014116655)

2.



偶然发现FreeCodeCamp这个网站，想着很多基础知识都生疏了（或者说本来就不咋熟练），想做一遍题目，熟悉一下。这个仓库存放Legacy Responsive Web Design认证部分的五个响应式网页设计项目。

1.[制作一个致敬页](https://tribute-page.freecodecamp.rocks/)

  学习了rem的具体用法。看例子网页是将html设置一个以px为单位的font-size，其他地方都以rem为单位。
  学习了[CSS-水平居中、垂直居中、水平垂直居中](https://segmentfault.com/a/1190000014116655)

2.[制作一个调查表格](https://survey-form.freecodecamp.rocks/)

  表单内容一定要用<form></form>包裹，不能用div



3.[制作一个产品登录页](https://product-landing-page.freecodecamp.rocks/)

4.[制作一个技术文档页面](https://technical-documentation-page.freecodecamp.rocks/)

5.[制作一个个人作品集展示页](https://personal-portfolio.freecodecamp.rocks)

# JavaScript 

## 基础 JavaScript

1.当你使用 let 时，同名的变量只能声明一次。
const 意味着它常量值，这意味着一旦一个变量被赋值为 const，它就不能被重新赋值
2.字符串的不变性
在 JavaScript 中，字符串（String）的值是不可变的（immutable），这意味着一旦字符串被创建就不能被改变。

例如，下面的代码：
```js
let myStr = "Bob";
myStr[0] = "J";
```
是不会把变量 myStr 的值改变成 Job 的，因为变量 myStr 是不可变的。 注意，这并不意味着 myStr 永远不能被改变，只是字符串字面量 string literal 的各个字符不能被改变。 改变 myStr 的唯一方法是重新给它赋一个值，例如：
```js
let myStr = "Bob";
myStr = "Job";
```
3.  .push() 接受一个或多个参数（parameters），并把它压入到数组的末尾。.pop() 函数移除数组末尾的元素并返回这个元素。 .shift() 工作原理就像 .pop()，但它移除的是第一个元素，而不是最后一个。.unshift() 函数用起来就像 .push() 函数一样，但不是在数组的末尾添加元素，unshift() 在数组的头部添加元素。
4.  严格相等运算符（===）是相对相等操作符（==）的另一种比较操作符。 与相等操作符转换数据类型不同，严格相等运算符不会做类型转换。
5.  如果你的对象有非字符串属性的话，JavaScript 会自动将它们转为字符串。所以js属性名都是字符串
6.  读取对象属性可以用点表示法和方括号表示法。对名称中带有空格的属性使用括号表示法，并且要把这个属性加上引号。
```js
const gloveBoxContents = myStorage.car.inside['glove box']
```
7.  可以像更改属性一样给 JavaScript 对象添加属性。同样可以删除对象的属性，例如：
```js
delete ourDog.bark;
```
8.对象和字典一样，可以用来存储键/值对。 如果数据是扁平的，你可以用对象来查找你想要的值，而不是链式使用 switch 或 if/else 语句。
```js
const alpha = {
  1:"Z",
  2:"Y",
  3:"X",
  4:"W",
  ...
  24:"C",
  25:"B",
  26:"A"
};

alpha[2];
alpha[24];

const value = 2;
alpha[value];
```
alpha[2] 是字符串 Y，alpha[24] 是字符串 C，alpha[value] 是字符串 Y。
9.检查一个对象属性是否存在.
```js
const myObj = {
  top: "hat",
  bottom: "pants"
};

myObj.hasOwnProperty("top");
myObj.hasOwnProperty("middle");
```
第一个 hasOwnProperty 返回 true，第二个返回 false。
10.Math.random()生成0-1，左闭右开
11.Math.floor() 向下取整，获得它最近的整数。
12.生成某个范围内的随机整数
```js
Math.floor(Math.random() * (max - min + 1)) + min
```
13.parseInt() 函数解析一个字符串返回一个整数。

## ES6 

1.优先使用const
2.const 声明并不会真的保护数据不被改变。 
使用 const 声明只能防止变量标识符的重新分配。

```js
const s = [5, 6, 7];
s = [1, 2, 3];
s[2] = 45;
console.log(s);
```
s = [1, 2, 3] 将导致错误。 console.log 将显示值 [5, 6, 45]。
但可以使用对各元素赋值的方法来改变对象中的内容
为了确保数据不被改变，JavaScript 提供了一个函数 Object.freeze。任何更改对象的尝试都将被拒绝，如果脚本在严格模式下运行，将抛出错误。
3.箭头函数`const myFunc = () => "value";`
4.ES6 里允许给函数传入默认参数，来构建更加灵活的函数。

```js
const greeting = (name = "Anonymous") => "Hello " + name;
```
5.rest 操作符(也就是...)可以用于创建有一个变量来接受任意数量的参数的函数。 这些参数被储存在一个可以在函数内部读取的数组中。
```js
// 使sum函数可以接收任意数量的参数，并返回它们的总和。
const sum=(...args)=>{
  return args.reduce((a,b)=> a+b,0)//这里把0设为初始值
}
```
补充：reduce() 方法对数组中的每个元素按序执行一个由您提供的 reducer 函数，每一次运行 reducer 会将先前元素的计算结果作为参数传入，最后将其结果汇总为单个返回值。
第一次执行回调函数时，不存在“上一次的计算结果”。如果需要回调函数从数组索引为 0 的元素开始执行，则需要传递初始值。否则，数组索引为 0 的元素将被作为初始值 initialValue，迭代器将从第二个元素开始执行（索引为 1 而不是 0）。
6.展开操作符(...arr) ，可以展开数组，把数组变成..., ..., ...的形式
 ps看上去和rest 操作符一样的
下面的例子中，Math.max() 函数中需要传入的是一系列由逗号分隔的参数，而不是一个数组。 展开操作符可以提升代码的可读性，使代码易于维护。
```js
const arr = [6, 89, 3, 45];
const maximus = Math.max(...arr);
//maximus 的值应该是 89。
```
...arr 返回一个解压的数组。 也就是说，它展开数组。 然而，展开操作符只能够在函数的参数中或者数组中使用。
```
const spreaded = ...arr;//报错
const arr2 = [...arr1];//可以
```
7.解构赋值
```js
const user = { name: 'John Doe', age: 34 };
const { name, age } = user;
```
在这里，自动创建 name 和 age 变量，并将 user 对象相应属性的值赋值给它们。name 的值应该是字符串 John Doe， age 的值应该是数字 34。作用相当于
```js
const user = { name: 'John Doe', age: 34 };
const name = user.name;
const age = user.age;
```
又一个例子
```js
const HIGH_TEMPERATURES = {
  yesterday: 75,
  today: 77,
  tomorrow: 80
};
const {today,tomorrow}=HIGH_TEMPERATURES
```
8.可以给解构的值赋予一个新的变量名， 通过在赋值的时候将新的变量名放在冒号后面来实现。
```js
const user = { name: 'John Doe', age: 34 };
const { name: userName, age: userAge } = user;
```
9.解构赋值可以嵌套
10.使用解构赋值从数组中分配变量
```js
const [a, b,,, c] = [1, 2, 3, 4, 5, 6];
console.log(a, b, c);
```
控制台将显示 a、b 和 c 的值为 1, 2, 5。
11.解构数组
```js
const [a, b,,, c] = [1, 2, 3, 4, 5, 6];
console.log(a, b, c);
```
控制台将显示 a、b 和 c 的值为 1, 2, 5。
```js
let a = 8, b = 6;
// 使用数组解构来交换变量 a 与 b 的值，使 a 接收 b 的值，而 b 接收 a 的值。
[a,b]=[b,a]
```
用这个方法可以交换两个数的数值

解构数组的某些情况下，我们可能希望将剩下的元素放进另一个数组里面。
```js
const [a, b, ...arr] = [1, 2, 3, 4, 5, 7];
console.log(a, b);
console.log(arr);
```
控制台将显示 1, 2 和 [3, 4, 5, 7]。
12.在某些情况下，你可以在函数的参数里直接解构对象。
请看以下代码：
```js
const profileUpdate = (profileData) => {
  const { name, age, nationality, location } = profileData;

}
```
上面的操作解构了传给函数的对象。 这样的操作也可以直接在参数里完成：
```js
const profileUpdate = ({ name, age, nationality, location }) => {

}
```
当 profileData 被传递到上面的函数时，从函数参数中解构出值以在函数内使用。
另一个例子：
```js
const stats = {
  max: 56.78,
  standard_deviation: 4.34,
  median: 34.54,
  mode: 23.87,
  min: -0.75,
  average: 35.85
};
const half = ({max,min}) => (max + min) / 2.0; 
```
13.模板字符串可以使用多行字符串和字符串插值功能。
请看以下代码：
```js
const person = {
  name: "Zodiac Hasbro",
  age: 56
};

const greeting = `Hello, my name is ${person.name}!
I am ${person.age} years old.`;

console.log(greeting);
```
控制台将显示字符串 Hello, my name is Zodiac Hasbro! 和 I am 56 years old.。

这里发生了许多事情。 首先，这个例子使用反引号（`），而不是引号（' 或者 "）将字符串括起来。 其次，注意代码和输出中的字符串都是多行的。 不需要在字符串中插入 \n。 上面使用的 ${variable} 语法是一个占位符。 这样一来，你将不再需要使用 + 运算符来连接字符串。 当需要在字符串里增加变量的时候，你只需要在变量的外面括上 ${ 和 }，并将其放在模板字符串里就可以了。 同样，你可以在字符串中包含其他表达式，例如 ${a + b}。 这个新的方式使你可以更灵活地创建复杂的字符串。
14.使用简单字段编写简洁的对象字面量声明
请看以下代码：
```js
const getMousePosition = (x, y) => ({
  x: x,
  y: y
});
```
getMousePosition 简单的函数，返回拥有两个属性的对象。 ES6 提供了一个语法糖，消除了类似 x: x 这种冗余的写法。 你可以只写一次 x，解释器会自动将其转换成 x: x（或效果相同的内容）。 下面是使用这种语法重写的同样的函数：
```js
const getMousePosition = (x, y) => ({ x, y });
```
另一个例子
```js
const createPerson = (name, age, gender) => {
  return {
    name: name,
    age: age,
    gender: gender
  };
};
```
可简化为
```js
const createPerson = (name, age, gender) => {
  return {
    name, age, gender
  };
};
```
15.用 ES6 的语法在对象中定义函数的时候，可以删除 function 关键词和冒号。 请看以下例子：
```js
const person = {
  name: "Taylor",
  sayHello() {
    return `Hello! My name is ${this.name}.`;
  }
};
```
等同于
```js
const person = {
  name: "Taylor",
  sayHello: function() {
    return `Hello! My name is ${this.name}.`;
  }
};
```
16.使用 class 语法定义构造函数 (class 只是一个语法糖)
在 ES5 里面，我们通常会定义一个构造函数 ，然后使用 new 关键字来实例化一个对象：
```js
var SpaceShuttle = function(targetPlanet){
  this.targetPlanet = targetPlanet;
}
var zeus = new SpaceShuttle('Jupiter');
```
class 语法只是简单地替换了构造函数  的写法：
```js
class SpaceShuttle {
  constructor(targetPlanet) {
    this.targetPlanet = targetPlanet;
  }
}
const zeus = new SpaceShuttle('Jupiter');
```
**注意：**首字母大写驼峰命名法 UpperCamelCase 是 ES6 class 命名的惯例，就像上面的 SpaceShuttle。

constructor 方法是一个特殊方法，用于创建和初始化 class 创建的对象。
17.使用 getter 和 setter 来控制对象的访问
getter和setter一般放到class里面
Getter 函数的作用是可以让对象返回一个私有变量，而不需要直接去访问私有变量。
Setter 函数的作用是可以基于传进的参数来修改对象中私有变量。 这些修改可以是计算，或者是直接替换之前的值。
```js
class Book {
  constructor(author) {
    this._author = author;
  }
  // getter
  get writer() {
    return this._author;
  }
  // setter
  set writer(updatedAuthor) {
    this._author = updatedAuthor;
  }
}
const novel = new Book('anonymous');
console.log(novel.writer);
novel.writer = 'newAuthor';
console.log(novel.writer);
```
注意： 通常会在私有变量前添加下划线（_）。 然而，这种做法本身并不是将变量变成私有的,这只是一种书写习惯
18.创建一个模块脚本
```js
<script type="module" src="filename.js"></script>
```
使用了 module 类型的脚本可以使用 import 和 export 特性

19.用 export 来重用代码块

假设有一个文件 `math_functions.js`，该文件包含了数学运算相关的一些函数。 其中一个存储在变量 `add` 里，该函数接受两个数字作为参数返回它们的和。 你想在几个不同的 JavaScript 文件中使用这个函数。 要实现这个目的，就需要 `export` 它。

```js
export const add = (x, y) => {
  return x + y;
}
```

上面是导出单个函数常用方法，还可以这样导出：

```js
const add = (x, y) => {
  return x + y;
}

export { add };
```

导出变量和函数后，就可以在其它文件里导入使用从而避免了代码冗余。 重复第一个例子的代码可以导出多个对象或函数，在第二个例子里面的导出语句中添加更多值也可以导出多项，例子如下：

```js
export { add, subtract };
```

20.通过 import 复用 JavaScript 代码
import 可以导入文件或模块的一部分。 在之前的课程里，例子从 math_functions.js 文件里导出了 add。 下面看一下如何在其它文件导入它：

```js
import { add } from './math_functions.js';
```
在这里，import 会在 math_functions.js 里找到 add，只导入这个函数，忽略剩余的部分。 ./ 告诉程序在当前文件的相同目录寻找 math_functions.js 文件。 用这种方式导入时，相对路径（./）和文件扩展名（.js）都是必需的。

通过在 import 语句里添加项目，可以从文件里导入多个项目，如下：
```js
import { add, subtract } from './math_functions.js';
```
添加 import 语句，使当前文件可以使用你在之前课程里导出的 uppercaseString 和 lowercaseString 函数。 函数在当前路径下的 string_functions.js 文件里。
21.用 * 从文件中导入所有内容

假设你有一个文件，你希望将其所有内容导入到当前文件中。 可以用 `import * as` 语法来实现。 下面是一个从同目录下的 `math_functions.js` 文件中导入所有内容的例子：

```js
import * as myMathModule from "./math_functions.js";
```

上面的 `import` 语句会创建一个叫作 `myMathModule` 的对象。 这只是一个变量名，可以随便命名。 对象包含 `math_functions.js` 文件里的所有导出，可以像访问对象的属性那样访问里面的函数。 下面是使用导入的 `add` 和 `subtract` 函数的例子：

```js
myMathModule.add(2,3);
myMathModule.subtract(5,3);
```

22.用 export default 创建一个默认导出

在 `export` 的课程中，你学习了命名导出语法， 这可以在其他文件中引用一些函数或者变量。

还需要了解另外一种被称为默认导出的 `export` 的语法。 在文件中只有一个值需要导出的时候，通常会使用这种语法。 它也常常用于给文件或者模块创建返回值。

下面是使用 `export default` 的例子：

```js
export default function add(x, y) {
  return x + y;
}

export default function(x, y) {
  return x + y;
}
```

第一个是命名函数，第二个是匿名函数。

`export default` 用于为模块或文件声明一个返回值，在每个文件或者模块中应当只默认导出一个值。 此外，你不能将 `export default` 与 `var`、`let` 或 `const` 同时使用。

23.导入一个默认的导出

在上一个挑战里，学习了 `export default` 的用法。 还需要一种 `import` 的语法来导入默认的导出。 在下面的例子里，`add` 是 `math_functions.js` 文件的默认导出。 以下是如何导入它：

```js
import add from "./math_functions.js";
```

这个语法有一处特别的地方， 被导入的 `add` 值没有被花括号（`{}`）所包围。 `add` 只是一个变量的名字，对应 `math_functions.js` 文件的任何默认导出值。 在导入默认导出时，可以使用任何名字。

24.创建一个 JavaScript Promise

Promise 是异步编程的一种解决方案 - 它在未来的某时会生成一个值。 任务完成，分执行成功和执行失败两种情况。 `Promise` 是构造器函数，需要通过 `new` 关键字来创建。 构造器参数是一个函数，该函数有两个参数 - `resolve` 和 `reject`。 通过它们来判断 promise 的执行结果。 用法如下：

```js
const myPromise = new Promise((resolve, reject) => {

});
```

25.通过 resolve 和 reject 完成 Promise

Promise 有三个状态：`pending`、`fulfilled` 和 `rejected`。 上一个挑战里创建的 promise 一直阻塞在 `pending` 状态里，因为没有调用 promise 的完成方法。 Promise 提供的 `resolve` 和 `reject` 参数就是用来结束 promise 的。 Promise 成功时调用 `resolve`，promise 执行失败时调用 `reject`， 如下文所述，这些方法需要有一个参数。

```js
const myPromise = new Promise((resolve, reject) => {
  if(condition here) {
    resolve("Promise was fulfilled");
  } else {
    reject("Promise was rejected");
  }
});
```

上面的示例使用字符串作为这些函数的参数，但参数实际上可以是任何格式。 通常，它可能是一个包含数据的对象，你可以将它放在网站或其他地方。

以下是一个例子，使 promise 可以处理成功和失败情况。 如果 `responseFromServer` 是 `true`，调用 `resolve` 方法使 promise 成功。 给 `resolve` 传递值为 `We got the data` 的字符串。 如果 `responseFromServer` 是 `false`， 使用 `reject` 方法并传入值为 `Data not received` 的字符串。
```js
const makeServerRequest = new Promise((resolve, reject) => {
  // responseFromServer 表示从服务器获得一个响应
  let responseFromServer;
  if(responseFromServer) {
    resolve('We got the data')
  } else {  
    reject ('Data not received')
  }
});
```

26.用 then 处理 Promise 完成的情况

当程序需要花费未知的时间才能完成时（比如一些异步操作），一般是服务器请求，promise 很有用。 服务器请求会花费一些时间，当结束时，需要根据服务器的响应执行一些操作。 这可以用 `then` 方法来实现， 当 promise 完成 `resolve` 时会触发 `then` 方法。

```js
const makeServerRequest = new Promise((resolve, reject) => {
  // responseFromServer 设置为 true，表示从服务器获得有效响应
  let responseFromServer = true;

  if(responseFromServer) {
    resolve("We got the data");
  } else {  
    reject("Data not received");
  }
});
makeServerRequest.then(
  result => {
console.log(result)
}
)
```

27.使用 catch 处理 Promise 失败的情况

当 promise 失败时会调用 `catch` 方法。 当 promise 的 `reject` 方法执行时会直接调用。 用法如下：

```js
myPromise.catch(error => {

});
```

`error` 是传入 `reject` 方法的参数。

```js
const makeServerRequest = new Promise((resolve, reject) => {
  // responseFromServer 设置为 false，表示从服务器获得无效响应
  let responseFromServer = false;

  if(responseFromServer) {
    resolve("We got the data");
  } else {  
    reject("Data not received");
  }
});

makeServerRequest.then(result => {
  console.log(result);
});
makeServerRequest.catch(error => {
  console.log(error);
});
```
## 正则表达式
1.JavaScript 中有多种使用正则表达式的方法。 测试正则表达式的一种方法是使用 `.test()` 方法。 `.test()` 方法会把编写的正则表达式和字符串（即括号内的内容）匹配，如果成功匹配到字符，则返回 `true`，反之，返回 `false`。
```js
let testStr = "freeCodeCamp";
let testRegex = /Code/;
testRegex.test(testStr);
```
`test` 方法会返回 `true`。
2.|
如果你想匹配 `yes` 或 `no`，你需要的正则表达式是 `/yes|no/`。
3.i忽略大小写
这里给出使用该标志的一个实例 /ignorecase/i。 这个字符串可以匹配字符串 ignorecase、igNoreCase 和 IgnoreCase。
4.提取匹配项
`.test()` 方法。 只是检查了一个匹配模式是否存在于字符串中。 还可以使用 `.match() `方法来提取找到的实际匹配项。可以使用字符串来调用 .match() 方法，并在括号内传入正则表达式。

请看下面的举例：

```js
"Hello, World!".match(/Hello/);
let ourStr = "Regular expressions";
let ourRegex = /expressions/;
ourStr.match(ourRegex);
```
这里第一个 `match` 将返回 `["Hello"]` 第二个将返回 `["expressions"]`。
5.全局匹配
若要多次搜寻或提取模式匹配，可以使用 g 标志。如果不使用g的话，默认只能提取或搜寻一次匹配。

```js
let testStr = "Repeat, Repeat, Repeat";
let ourRegex = /Repeat/;
testStr.match(ourRegex);
```
在这里 `match` 将返回 `["Repeat"]`。
若要多次搜寻或提取模式匹配，可以使用 `g` 标志。
```js
let repeatRegex = /Repeat/g;
testStr.match(repeatRegex);
```
这里 `match` 返回值 `["Repeat", "Repeat", "Repeat"]`
6.用通配符.匹配任何内容
通配符 . 将匹配任何一个字符。 可以像使用正则表达式中任何其他字符一样使用通配符。 例如，如果想匹配 hug、huh、hut 和 hum，可以使用正则表达式 /hu./
7.可以使用字符集 更灵活的匹配字符。 可以把字符集放在方括号（[ 和 ]）之间来定义一组需要匹配的字符串。
例如，如果想要匹配 bag、big 和 bug，但是不想匹配 bog。 可以创建正则表达式 /b[aiu]g/ 来执行此操作。 [aiu] 是只匹配字符 a、i 或者 u 的字符集。
如果要匹配连续的字符， 可以使用连字符（`-`）来定义要匹配的字符范围。
例如，要匹配小写字母 `a` 到 `e`，你可以使用 `/[a-e]/`。`/[0-5]/` 匹配 `0` 和 `5` 之间的任意数字，包含 `0` 和 `5`。
创建一个正则表达式，使其可以匹配 `h` 和 `s` 之间的一系列字母，以及 `2` 和 `6` 之间的一系列数字。 

```js
let myRegex = /[h-s2-6]/ig; 
```
8.也可以创建一个不想匹配的字符集合。 这些类型的字符集称为否定字符集
要创建否定字符集，需要在开始括号后面和不想匹配的字符前面放置脱字符（即^）。

例如，/[^aeiou]/gi 匹配所有非元音字符。 注意，字符 .、!、[、@、/ 和空白字符等也会被匹配，该否定字符集仅排除元音字符。
9.可以使用 + 符号来匹配出现一次或重复出现多次的字符
例如，/a+/g 会在 abc 中匹配到一个匹配项，并且返回 ["a"]。 因为 + 的存在，它也会在 aabc 中匹配到一个匹配项，然后返回 ["aa"]。
如果它是检查字符串 abab，它将匹配到两个匹配项并且返回["a", "a"]，因为a字符不连续，在它们之间有一个b字符。 最后，因为在字符串 bcd 中没有 a，因此找不到匹配项。
10.字符后加*可以匹配出现零次或多次的字符

```js
let soccerWord = "gooooooooal!";
let gPhrase = "gut feeling";
let oPhrase = "over the moon";
let goRegex = /go*/;//匹配0个或多个o
soccerWord.match(goRegex);
gPhrase.match(goRegex);
oPhrase.match(goRegex);
```
11.正则表达式默认是贪婪匹配。贪婪（greedy）匹配会匹配到符合正则表达式匹配模式的字符串的最长可能部分，并将其作为匹配项返回。 另一种方案称为懒惰（lazy）匹配，它会匹配到满足正则表达式的字符串的最小可能部分。
可以在限定符后面加`？`来将此正则表达式变成懒惰匹配

12.`^`符号的另一种用法

在之前的挑战中，使用字符集中前插入符号（`^`）来创建一个否定字符集，形如 `[^thingsThatWillNotBeMatched]`。 除了在字符集中使用之外，插入符号（^）用于匹配文本是否在字符串的开始位置
```js
let firstString = "Ricky is first and can be found.";
let firstRegex = /^Ricky/;
firstRegex.test(firstString);
let notFirst = "You can't find Ricky now.";
firstRegex.test(notFirst);
```
第一次 `test` 调用将返回 `true`，而第二次调用将返回 `false`。
13.与^相对， $ 来搜寻字符串的结尾

```js
let theEnding = "This is a never ending story";
let storyRegex = /story$/;
storyRegex.test(theEnding);
let noEnding = "Sometimes a story will have to end";
storyRegex.test(noEnding);
```
第一次 `test` 调用将返回 `true`, 而第二次调用将返回 `false`。
14.元字符\w等同于[A-Za-z0-9_]，此字符类匹配大写字母和小写字母、数字以及下划线字符 (`_`)。
可以使用 \W 搜寻和 \w相反的匹配模式。\W匹配非字母数字字符
15.\d等同于[0-9]，\D等同于字符串 [^0-9]
16.\s匹配空白字符，\S 匹配非空白字符，不匹配空格、回车符、制表符、换页符和换行符

17.数量说明符{}匹配出现的次数
例如，要匹配出现 3 到 5 次字母 a 的在字符串 ah，正则表达式应为/a{3,5}h/。也可以只指定上限 /a{,5}h/或只指定下限/a{3,}h/。也可以指定匹配的确切数量/a{3}h/
18.符号后加? 指定可能存在的元素
例如，美式英语和英式英语略有不同，可以使用问号来匹配两种拼写。
```js
let american = "color";
let british = "colour";
let rainbowRegex= /colou?r/;
rainbowRegex.test(american);
rainbowRegex.test(british);
```
上面的 `test` 都会返回 `true`。

19.正向先行断言和负向先行断言
正向先行断言会查看并确保搜索匹配模式中的元素存在，但实际上并不匹配。 正向先行断言的用法是 (?=...)，其中 ... 就是需要存在但不会被匹配的部分。
另一方面，负向先行断言会查看并确保搜索匹配模式中的元素不存在。 负向先行断言的用法是 (?!...)，其中 ... 是希望不存在的匹配模式。 如果负向先行断言部分不存在，将返回匹配模式的其余部分。

```js
let quit = "qu";
let noquit = "qt";
let quRegex= /q(?=u)/;
let qRegex = /q(?!u)/;
quit.match(quRegex);
noquit.match(qRegex);
```

这两次 `match` 调用都将返回 `["q"]`。

先行断言的更实际用途是检查一个字符串中的两个或更多匹配模式。 这里有一个简单的密码检查器，密码规则是 3 到 6 个字符且至少包含一个数字：

```js
let password = "abc123";
let checkPass = /(?=\w{3,6})(?=\D*\d)/;
checkPass.test(password);
```

20.`()` 来检查字符组
如果想在字符串找到 `Penguin` 或 `Pumpkin`，可以用这个正则表达式：`/P(engu|umpk)in/g`。
然后使用 `test()` 方法检查 test 字符串里面是否包含字符组。
```js
let testStr = "Pumpkin";
let testRegex = /P(engu|umpk)in/;
testRegex.test(testStr);
```
`test` 方法会返回 `true`。

21.使用捕获组重用模式你可以使用 `/row row row/`。但如果你不知道重复的特定单词，怎么办？ 捕获组 可以用于找到重复的子字符串。捕获组是通过把要捕获的正则表达式放在括号中来构建的。 在这个例子里， 目标是捕获一个包含字母数字字符的词，所以捕获组是将 `\w+` 放在括号中：`/(\w+)/`。分组匹配的子字符串被保存到一个临时的“变量”， 可以使用同一正则表达式和反斜线及捕获组的编号来访问它（例如：`\1`）。 捕获组按其开头括号的位置自动编号（从左到右），从 1 开始。下面的示例是匹配被空格隔开的两个相同单词：

```js
let repeatRegex = /(\w+) \1 \1/;
repeatRegex.test(repeatStr); // Returns true
repeatStr.match(repeatRegex); // Returns ["row row row", "row"]
```
在 `reRegex` 中使用捕获组来匹配一个只由相同的数字重复三次组成的由空格分隔字符串。
```js
let repeatNum = "42 42 42";
let reRegex = /^(\d+) \1 \1$/; // 如果不加^和$，就可以匹配3个及以上的42，加了之后就只能匹配42 42 42
let result = reRegex.test(repeatNum);
```

22.可以在字符串上使用 `.replace()` 方法来搜索并替换字符串中的文本。 `.replace()` 的输入首先是想要搜索的正则表达式匹配模式。 第二个参数是用于替换匹配的字符串或用于执行某些操作的函数。

```js
let wrongText = "The sky is silver.";
let silverRegex = /silver/;
wrongText.replace(silverRegex, "blue");
```

`replace` 调用将返回字符串 `The sky is blue.`。

你还可以使用美元符号（`$`）访问替换字符串中的捕获组。

```js
"Code Camp".replace(/(\w+)\s(\w+)/, '$2 $1');
```

调用 `replace` 将返回字符串 `Camp Code`。

23.删除开头和结尾的空白
```js
let hello = "   Hello, World!  ";
let wsRegex = /^\s+|\s+$/g; 
let result = hello.replace(wsRegex,"");
```
## 调试
1.console.log()可以在控制台看到日志，console.clear() 清除控制台日志
2.使用 typeof 检查变量的类型
当你以 JavaScript 对象（JSON）的形式访问和使用外部数据时尤其要小心类型错误
3.捕获拼错的变量名和函数名
一个语法级别的问题是打字太快带来的低级拼写错误。
变量或函数名的错写、漏写或大小写弄混都会让浏览器尝试查找并不存在的东西，并报出“引用错误”。 JavaScript 变量和函数名称区分大小写。
## 基础数据结构
1.数组可以存储不同类型的数据
```js
let simpleArray = ['one', 2, 'three', true, false, undefined, null];
console.log(simpleArray.length);
```
调用 `console.log` 显示 7。
2.splice() 可以让我们从数组中的**任意位置连续**删除**任意数量**的元素。
splice() 最多可以接受 3 个参数
splice() 的第一个参数代表从数组中的哪个索引开始移除元素，而第二个参数表示要从数组中的这个位置开始删除多少个元素。 例如：
 例如：
```js
let array = ['today', 'was', 'not', 'so', 'great'];
array.splice(2, 2);
```
这里我们移除 2 个元素，首先是第三个元素（索引为 2）。 `array` 会有值 `['today', 'was', 'great']`。
`splice()` 不仅会修改调用该方法的数组，还会返回一个包含被移除元素的数组
3.splice()替换元素
第三个参数可以是一个或多个元素，这些元素会被添加到删除位置。 这样，我们能够便捷地将数组中的一个或多个连续元素换成其他的元素。
4.使用 slice() 复制数组元素
slice() 只接收 2 个输入参数：第一个是开始提取元素的位置（索引），第二个是提取元素的结束位置（索引）。左闭右开
5.使用展开运算符...复制数组
```js
let thisArray = [true, true, undefined, false, null];
let thatArray = [...thisArray];
```
thatArray 等于 [true, true, undefined, false, null]。 thisArray 保持不变， thatArray 包含与 thisArray 相同的元素。
6.展开语法（spread）的另一个重要用途是合并数组，或者将某个数组的所有元素插入到另一个数组的任意位置。

```js
let thisArray = ['sage', 'rosemary', 'parsley', 'thyme'];
let thatArray = ['basil', 'cilantro', ...thisArray, 'coriander'];
```
7.使用 indexOf() 检查元素是否存在
indexOf() 方法接受一个元素作为输入参数，并返回该元素在数组中的位置（索引）；若该元素不存在于数组中则返回 -1。

8.对象（object）本质上是键值对（key-value pair）的集合。 或者说，一系列被映射到唯一标识符的数据就是对象；习惯上，唯一标识符叫做属性（property）或者键（key）；数据叫做值（value）。 让我们来看一个简单的例子：

```js
const tekkenCharacter = {
  player: 'Hwoarang',
  fightingStyle: 'Tae Kwon Doe',
  human: true
};
```

上面的代码定义了一个叫做 `tekkenCharacter` 的“铁拳”游戏人物对象。 它有三个属性，每个属性都对应一个特定的值。 如果我们想为它再添加一个叫做 `origin` 的属性，可以这样写：

```js
tekkenCharacter.origin = 'South Korea';
```

上面的代码中，我们使用了点号表示法。 如果我们现在输出 `tekkenCharacter` 对象，便可以看到它具有 `origin` 属性。 接下来，因为这个人物在游戏中有着与众不同的橘色头发， 我们可以通过方括号表示法来为它添加这个属性，像这样：

```js
tekkenCharacter['hair color'] = 'dyed orange';
```

如果要设置的属性中存在空格，或者要设置的属性是一个变量，那我们必须使用方括号表示法（bracket notation）来为对象添加属性。 在上面的代码中，我们把属性（hair color）放到引号里，以此来表示整个字符串都是需要设置的属性。 如果我们不加上引号，那么中括号里的内容会被当作一个变量来解析，这个变量对应的值就会作为要设置的属性， 请看这段代码：

```js
const eyes = 'eye color';

tekkenCharacter[eyes] = 'brown';
```

执行以上所有示例代码后，对象会变成这样：

```js
{
  player: 'Hwoarang',
  fightingStyle: 'Tae Kwon Doe',
  human: true,
  origin: 'South Korea',
  'hair color': 'dyed orange',
  'eye color': 'brown'
};
```

总结：用点表示法，可以省略引号，用方括号表示法不能省略引号
```js
foods.bananas =13
foods['grapes']=35
```

如果要设置的属性中存在空格，或者要设置的属性是一个变量，那我们必须使用方括号表示法

9.使用 delete 关键字删除对象属性
10.检查对象是否具有某个属性
两种不同的方式来实现这个功能： 一个是通过 `hasOwnProperty()` 方法，另一个是使用 `in` 关键字。 假如我们有一个 `users` 对象，为检查它是否含有 `Alan` 属性，可以这样写：

```js
users.hasOwnProperty('Alan');
'Alan' in users;
```
这两者结果都应该为 `true`。

11.使用 for...in 语句遍历对象

```js
for (let user in users) {
  console.log(user);
}
```
12.使用 Object.keys() 生成由对象的所有属性组成的数组
我们可以给 Object.keys() 方法传入一个对象作为参数，来生成包含对象所有键的数组。 这会返回一个由对象中所有属性（字符串）组成的数组。 需要注意的是，数组中元素的顺序是不确定的。
```js
let users = {
  Alan: {
    age: 27,
    online: false
  },
  Jeff: {
    age: 32,
    online: true
  },
  Sarah: {
    age: 48,
    online: false
  },
  Ryan: {
    age: 19,
    online: true
  }
};
function getArrayOfUsers(obj) {
return Object.keys(obj)
}
console.log(getArrayOfUsers(users));
```
输出[ 'Alan', 'Jeff', 'Sarah', 'Ryan' ]
13. Map 和 Set这两种数据结构与我们现在学到的对象十分类似，但它们在对象的基础上提供了一些额外的功能。

## 基础算法
1.反转字符串
请反转传入函数的字符串。
在反转字符串之前，你可能需要将其切分成包含字符的数组。
函数的返回结果应为字符串。
```js
function reverseString(str) {
  let newStr=''
  for(let i=str.length-1;i>=0;i--){
    newStr+=str[i]
  }
  return newStr;
}
```
2.找出字符串中的最长单词
返回给出的句子中，最长单词的长度。
函数的返回值应是一个数字。
```js
function findLongestWordLength(str) {
  let words = str.split(' ');
  let maxLength = 0;
  for (let i = 0; i < words.length; i++) {
    if (words[i].length > maxLength) {
      maxLength = words[i].length;
    }
  }
  return maxLength;
}
findLongestWordLength("The quick brown fox jumped over the lazy dog");
```

3.确认结尾
检查字符串（第一个参数 `str`）是否以给定的目标字符串（第二个参数 `target`）结束。
这个挑战 可以*用 ES2015 引入的 `.endsWith()` 方法来解决。但在这个挑战中，请使用 JavaScript 的字符串子串方法。

